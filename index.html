<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V20 é–€æª»è§£æ”¾+å„€è¡¨æ¿ç‰ˆ</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* åŸºç¤å…¨è¢å¹• */
    body { font-family: 'Segoe UI', monospace; background: #000; margin: 0; overflow: hidden; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 0; }
    video { display: none; }

    /* UI å±¤ */
    .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

    /* è¨ˆåˆ†æ¿ */
    .score-container { 
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center;
    }
    .score-board { 
        padding: 10px 50px; border-radius: 20px; text-align: center; 
        background: rgba(0, 0, 0, 0.6); border: 3px solid #555; transition: all 0.1s; 
    }
    #count { font-size: 110px; font-weight: 900; line-height: 1; color: #fff; }
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; }

    /* å·¦å´å„€è¡¨æ¿ (Debug Panel) */
    .debug-panel {
        position: absolute; top: 20px; left: 20px;
        background: rgba(0, 0, 0, 0.7); border: 1px solid #444;
        padding: 15px; border-radius: 10px; text-align: left;
        color: #fff; font-size: 14px; line-height: 1.6;
    }
    .debug-row { display: flex; justify-content: space-between; width: 180px; }
    .val { font-weight: bold; }
    .pass { color: #00ff00; } /* é”æ¨™ç¶ è‰² */
    .fail { color: #fff; opacity: 0.5; } /* æœªé”æ¨™ç™½è‰² */
    .locked { color: #ff0000; } /* å†·å»ä¸­ç´…è‰² */

    /* é˜²ç¦¦ç‹€æ…‹ */
    .guard-status { margin-top: 10px; display: flex; gap: 15px; }
    .g-dot { width: 12px; height: 12px; border-radius: 50%; background: #444; border: 1px solid #777; }
    .active .g-dot { background: #00ff00; box-shadow: 0 0 10px #00ff00; border-color: #fff; }
    .guard-item { display: flex; align-items: center; gap: 5px; color: #777; font-weight: bold; font-size: 12px; }
    .guard-item.active { color: #00ff00; }

    /* ç‰¹æ•ˆèˆ‡å‹•ç•« */
    .score-board.tier-1 { border-color: #00d2ff; box-shadow: 0 0 20px #00d2ff; }
    .score-board.tier-2 { border-color: #ffd700; box-shadow: 0 0 30px #ffd700; }
    .score-board.tier-3 { border-color: #ff4500; box-shadow: 0 0 40px #ff4500; }
    .hit-pop { animation: pop 0.1s ease-out; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }

    /* æŒ‰éˆ• */
    #start-btn, #reset-btn { position: absolute; pointer-events: auto; cursor: pointer; border: none; font-weight: bold; border-radius: 50px; color: white; }
    #start-btn { top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 60px; font-size: 24px; background: #0984e3; box-shadow: 0 0 30px rgba(9, 132, 227, 0.8); z-index: 100; }
    #reset-btn { bottom: 30px; right: 30px; padding: 12px 25px; background: #d63031; display: none; z-index: 100; }
  </style>
</head>
<body>

<div class="video-container">
  <video id="input_video" playsinline></video>
  <canvas id="output_canvas"></canvas>
</div>

<div class="ui-layer">
  <div class="debug-panel" id="debug-panel">
      <div style="border-bottom:1px solid #555; margin-bottom:5px;">LEFT ARM</div>
      <div class="debug-row"><span>Z-Depth:</span> <span id="val-lz" class="val">0.00</span></div>
      <div class="debug-row"><span>Angle:</span> <span id="val-la" class="val">0Â°</span></div>
      <div class="debug-row"><span>Speed:</span> <span id="val-ls" class="val">0.00</span></div>
      <div class="debug-row"><span>Target:</span> <span id="val-lt" class="val">NO</span></div>
      
      <div style="border-bottom:1px solid #555; margin-bottom:5px; margin-top:10px;">RIGHT ARM</div>
      <div class="debug-row"><span>Z-Depth:</span> <span id="val-rz" class="val">0.00</span></div>
      <div class="debug-row"><span>Angle:</span> <span id="val-ra" class="val">0Â°</span></div>
      <div class="debug-row"><span>Speed:</span> <span id="val-rs" class="val">0.00</span></div>
      <div class="debug-row"><span>Target:</span> <span id="val-rt" class="val">NO</span></div>
  </div>

  <div class="score-container">
    <div class="score-board" id="score-board">
      <div class="count-label">COMBO</div>
      <div id="count">0</div>
    </div>
    <div class="guard-status">
        <div id="g-left" class="guard-item"><div class="g-dot"></div> L-GUARD</div>
        <div id="g-right" class="guard-item"><div class="g-dot"></div> R-GUARD</div>
    </div>
  </div>
</div>

<button id="start-btn" onclick="initGame()">ğŸ¥Š å•Ÿå‹• V20 è¨ºæ–·ç‰ˆ</button>
<button id="reset-btn" onclick="resetCount()">RESET</button>

<script>
// --- éŸ³æ•ˆ ---
const PUNCH_SOUND_URL = 'punch.mp3'; 
let audioContext, punchBuffer;
async function loadSound() {
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        const res = await fetch(PUNCH_SOUND_URL);
        const buf = await res.arrayBuffer();
        punchBuffer = await audioContext.decodeAudioData(buf);
    } catch(e) {}
}
function playSound() {
    if (!audioContext || !punchBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const src = audioContext.createBufferSource();
    src.buffer = punchBuffer;
    src.connect(audioContext.destination);
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    src.start(0);
}

// --- V20 åƒæ•¸ï¼šé–€æª»å¤§è§£æ”¾ ---
const CONFIG = {
    // é–€æª»å€¼ (Thresholds)
    triggerZ: 0.15,      // [å¤§é™] åªè¦ > 0.15 å°±éé—œ (åŸæœ¬ 0.28)
    minSpeed: 0.02,      // [å¤§é™] åªè¦ > 0.02 å°±éé—œ (åŸæœ¬ 0.04)
    minArmAngle: 105,    // [å¤§é™] åªè¦ > 105åº¦ å°±éé—œ (åŸæœ¬ 140)
    
    // é‡ç½®åƒæ•¸
    resetZ: 0.25,        // å°æ–¼æ­¤å€¼é‡ç½®
    resetAngle: 95,      // å°æ–¼æ­¤è§’åº¦é‡ç½®

    hitRadiusRatio: 0.8, // ç›®æ¨™åœˆå¤§å° (0.8 = å¯¬é¬†)
    guardDistRatio: 0.65,
    cooldownFrames: 2
};

// ç‹€æ…‹
let count = 0;
let leftState = 0, rightState = 0;
let leftCooldown = 0, rightCooldown = 0;
let leftGuardGrace = 0, rightGuardGrace = 0;
let lastLeftZ = 0, lastRightZ = 0;
let floatTexts = [];

// DOM å…ƒç´ 
const video = document.getElementById('input_video');
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const countEl = document.getElementById('count');
const board = document.getElementById('score-board');
const gl = document.getElementById('g-left');
const gr = document.getElementById('g-right');

// Debug DOM
const dbg = {
    lz: document.getElementById('val-lz'), la: document.getElementById('val-la'),
    ls: document.getElementById('val-ls'), lt: document.getElementById('val-lt'),
    rz: document.getElementById('val-rz'), ra: document.getElementById('val-ra'),
    rs: document.getElementById('val-rs'), rt: document.getElementById('val-rt')
};

function spawnHit(x, y, isLeft) {
    if (floatTexts.length > 10) floatTexts.shift();
    floatTexts.push({ x, y, text: "HIT!", color: isLeft ? '#00d2ff' : '#ff9f43', life: 20, vy: -5 });
}

function calculate3DAngle(a, b, c) {
    const v1 = { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
    const v2 = { x: c.x - b.x, y: c.y - b.y, z: c.z - b.z };
    const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
    const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);
    return Math.acos(dot / (mag1 * mag2)) * (180.0 / Math.PI);
}

// æ›´æ–°å„€è¡¨æ¿
function updateDebugPanel(isLeft, z, angle, speed, inZone, cooldown) {
    const p = isLeft ? 'l' : 'r';
    const elZ = dbg[p+'z'], elA = dbg[p+'a'], elS = dbg[p+'s'], elT = dbg[p+'t'];
    
    // æ•¸å€¼é¡¯ç¤º
    elZ.innerText = z.toFixed(2);
    elA.innerText = Math.round(angle) + "Â°";
    elS.innerText = speed.toFixed(3);
    elT.innerText = inZone ? "YES" : "NO";

    // é¡è‰²åˆ¤å®š
    if (cooldown > 0) {
        // å†·å»ä¸­å…¨éƒ¨ç´…å­—
        elZ.className = elA.className = elS.className = elT.className = "val locked";
    } else {
        elZ.className = (z > CONFIG.triggerZ) ? "val pass" : "val fail";
        elA.className = (angle > CONFIG.minArmAngle) ? "val pass" : "val fail";
        elS.className = (speed > CONFIG.minSpeed) ? "val pass" : "val fail";
        elT.className = inZone ? "val pass" : "val fail";
    }
}

function processHand(shoulder, elbow, wrist, nose, scale, state, cooldown, lastZ, label) {
    let newState = state;
    let hit = false;
    
    const currentZ = shoulder.z - wrist.z;
    const velocity = currentZ - lastZ;
    const armAngle = calculate3DAngle(shoulder, elbow, wrist);
    const distToNose = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
    const inHitZone = distToNose < (scale * CONFIG.hitRadiusRatio);
    const isLeft = (label === 'L');

    // æ›´æ–°å„€è¡¨æ¿
    updateDebugPanel(isLeft, currentZ, armAngle, velocity, inHitZone, cooldown);

    if (state === 0) { // Ready
        // åˆ¤å®šï¼šæ·±åº¦ + é€Ÿåº¦ + è§’åº¦ + åœ¨åœˆå…§ (ä¸æª¢æŸ¥å¦ä¸€éš»æ‰‹é˜²ç¦¦äº†)
        if (currentZ > CONFIG.triggerZ && 
            velocity > CONFIG.minSpeed && 
            armAngle > CONFIG.minArmAngle &&
            inHitZone && 
            cooldown <= 0
           ) {
            newState = 1;
            hit = true;
        }
    } 
    else if (state === 1) { 
        newState = 2; 
    } 
    else if (state === 2) { 
        // é‡ç½®
        if (currentZ < CONFIG.resetZ || armAngle < CONFIG.resetAngle) {
            newState = 0; 
        }
    }

    return { newState, hit, currentZ };
}

function onResults(results) {
    if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }
    const cw = canvas.width, ch = canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, cw, ch);
    ctx.drawImage(results.image, 0, 0, cw, ch);

    if (results.poseLandmarks) {
        const lm = results.poseLandmarks;
        const nose = lm[0];
        const lS = lm[11], lE = lm[13], lW = lm[15];
        const rS = lm[12], rE = lm[14], rW = lm[16];
        const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

        if (nose && lS && rS && lW && rW) {
            const scale = Math.hypot(lS.x - rS.x, lS.y - rS.y) * 2.5;

            // éª¨æ¶
            ctx.lineWidth = 3; ctx.strokeStyle = "#00ff00"; ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(lS.x * cw, lS.y * ch); ctx.lineTo(lE.x * cw, lE.y * ch); ctx.lineTo(lW.x * cw, lW.y * ch);
            ctx.moveTo(rS.x * cw, rS.y * ch); ctx.lineTo(rE.x * cw, rE.y * ch); ctx.lineTo(rW.x * cw, rW.y * ch);
            ctx.moveTo(lS.x * cw, lS.y * ch); ctx.lineTo(rS.x * cw, rS.y * ch);
            ctx.stroke();

            // æ“Šæ‰“åœˆ (Hit Zone)
            const hitR = scale * CONFIG.hitRadiusRatio;
            const isPunching = (leftState === 1 || rightState === 1);
            ctx.beginPath();
            ctx.strokeStyle = isPunching ? "rgba(255, 255, 255, 0.9)" : "rgba(255, 0, 0, 0.3)";
            ctx.fillStyle = isPunching ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 0, 0, 0.05)";
            ctx.arc(nose.x * cw, nose.y * ch, hitR * cw, 0, 2 * Math.PI);
            ctx.stroke(); ctx.fill();

            // é˜²ç¦¦ç‹€æ…‹ (åƒ…é¡¯ç¤ºï¼Œä¸å½±éŸ¿è§¸ç™¼)
            const gDist = scale * CONFIG.guardDistRatio;
            if (Math.hypot(lW.x - chin.x, lW.y - chin.y) < gDist) leftGuardGrace = 5; else if (leftGuardGrace > 0) leftGuardGrace--;
            if (Math.hypot(rW.x - chin.x, rW.y - chin.y) < gDist) rightGuardGrace = 5; else if (rightGuardGrace > 0) rightGuardGrace--;
            const gL = leftGuardGrace > 0, gR = rightGuardGrace > 0;
            
            if (gL) gl.classList.add('active'); else gl.classList.remove('active');
            if (gR) gr.classList.add('active'); else gr.classList.remove('active');

            if (lastLeftZ === 0) { lastLeftZ = lS.z - lW.z; lastRightZ = rS.z - rW.z; }

            const resL = processHand(lS, lE, lW, nose, scale, leftState, leftCooldown, lastLeftZ, 'L');
            const resR = processHand(rS, rE, rW, nose, scale, rightState, rightCooldown, lastRightZ, 'R');

            leftState = resL.newState; lastLeftZ = resL.currentZ;
            rightState = resR.newState; lastRightZ = resR.currentZ;

            if (resL.hit) hitLogic(true, lW.x, lW.y);
            if (resR.hit) hitLogic(false, rW.x, rW.y);

            if (leftCooldown > 0) leftCooldown--;
            if (rightCooldown > 0) rightCooldown--;
            
            drawDot(lW, gL); drawDot(rW, gR);
        }
    }
    
    drawFloatingTexts(cw, ch);
    ctx.restore();
}

function hitLogic(isLeft, x, y) {
    count++;
    countEl.innerText = count;
    countEl.classList.remove('hit-pop'); void countEl.offsetWidth; countEl.classList.add('hit-pop');
    if(isLeft) leftCooldown = CONFIG.cooldownFrames; else rightCooldown = CONFIG.cooldownFrames;
    playSound();
    spawnHit(x, y, isLeft);
    board.className = 'score-board';
    if(count >= 100) board.classList.add('tier-3');
    else if(count >= 40) board.classList.add('tier-2');
    else if(count >= 20) board.classList.add('tier-1');
}

function drawDot(w, active) {
    ctx.beginPath();
    ctx.fillStyle = active ? "#00ff00" : "#d63031";
    ctx.arc(w.x * canvas.width, w.y * canvas.height, 10, 0, 2*Math.PI);
    ctx.fill();
}

function drawFloatingTexts(cw, ch) {
    ctx.scale(-1, 1);
    ctx.font = "900 60px Arial"; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
    for(let i=floatTexts.length-1; i>=0; i--){
        let t = floatTexts[i];
        let rx = -(cw - t.x*cw);
        ctx.fillStyle = t.color;
        ctx.strokeText(t.text, rx, t.y*ch); ctx.fillText(t.text, rx, t.y*ch);
        t.y += t.vy/ch; t.life--;
        if(t.life<=0) floatTexts.splice(i, 1);
    }
}

const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
pose.onResults(onResults);

async function initGame() {
    await loadSound();
    const camera = new Camera(video, { onFrame: async () => { await pose.send({image: video}); }, width: 1280, height: 720 });
    await camera.start();
    document.getElementById('start-btn').style.display = 'none';
    document.getElementById('reset-btn').style.display = 'block';
}
function resetCount() { count = 0; countElement.innerText = 0; board.className = 'score-board'; }
</script>
</body>
</html>
