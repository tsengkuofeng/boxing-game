  <script>
    // =========================================================
    //  TURBO V2 - 物理邏輯優化版 (防誤判、防連點)
    // =========================================================

    // --- 0. 音效系統 (維持原本優化) ---
    const PUNCH_SOUND_URL = 'punch.mp3'; 
    let audioContext = null;
    let punchBuffer = null;

    async function loadSound() {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            const response = await fetch(PUNCH_SOUND_URL);
            const arrayBuffer = await response.arrayBuffer();
            punchBuffer = await audioContext.decodeAudioData(arrayBuffer);
            console.log("音效系統：READY");
        } catch (error) {
            console.error("音效錯誤:", error);
        }
    }

    function playPunchSound() {
        if (!audioContext || !punchBuffer) return;
        if (audioContext.state === 'suspended') audioContext.resume();
        const source = audioContext.createBufferSource();
        source.buffer = punchBuffer;
        source.connect(audioContext.destination);
        source.start(0);
    }

    // --- 1. 取得網頁元素 ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { alpha: false });
    const countElement = document.getElementById('count');
    const scoreBoard = document.querySelector('.score-board'); 
    const statusElement = document.getElementById('status');
    const startBtn = document.getElementById('start-btn'); 
    const resetBtn = document.getElementById('reset-btn'); 

    // --- 2. 物理參數設定 (關鍵修改處) ---
    const CONFIG = {
        // [修改 1] 嚴格觸發：手要伸得更直 (原本 0.65 -> 改為 0.85)
        triggerRatio: 0.85, 
        
        // [修改 2] 嚴格重置：手要縮得更回來才能打下一拳 (原本 0.50 -> 改為 0.40)
        // 這能解決「一拳變多拳」的問題，強迫你必須確實收拳
        resetRatio: 0.40,   
        
        // [新增] 最低速度要求：避免「擺架勢」被算成出拳
        // 單位是：每幀移動距離佔畫面寬度的比例
        minSpeed: 0.015,
        
        // 冷卻幀數
        cooldownFrames: 5 
    };

    // 狀態變數
    let count = 0;
    let leftStage = "down", rightStage = "down";
    let leftCooldown = 0, rightCooldown = 0;
    let floatingTexts = []; 

    // 用來計算速度的「上一幀位置」
    let prevLeftWrist = { x: 0, y: 0 };
    let prevRightWrist = { x: 0, y: 0 };

    // --- 3. 工具函數 ---
    function calculateDistance(a, b) {
      return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }

    function drawVisualText(ctx, text, visualX, visualY, color) {
      ctx.save();
      ctx.scale(-1, 1); 
      ctx.font = `bold 60px Arial`;
      ctx.fillStyle = color;
      ctx.fillText(text, -visualX, visualY); 
      ctx.restore();
    }

    function spawnFloatingText(x, y, text, color) {
        if(floatingTexts.length > 20) floatingTexts.shift();
        floatingTexts.push({ x, y, text, color, life: 15, offsetY: 0 });
    }

    function updateFireEffect(currentCount) {
      if (!scoreBoard) return;
      const currentClass = scoreBoard.classList.contains('fire-lv3') ? 3 : 
                           scoreBoard.classList.contains('fire-lv2') ? 2 :
                           scoreBoard.classList.contains('fire-lv1') ? 1 : 0;
      let targetClass = 0;
      if (currentCount >= 100) targetClass = 3;
      else if (currentCount >= 80) targetClass = 2;
      else if (currentCount >= 50) targetClass = 1;

      if (currentClass !== targetClass) {
          scoreBoard.classList.remove('fire-lv1', 'fire-lv2', 'fire-lv3');
          if (targetClass > 0) scoreBoard.classList.add(`fire-lv${targetClass}`);
      }
    }

    window.resetCount = function() {
      count = 0; 
      countElement.innerText = count; 
      floatingTexts = []; 
      if (scoreBoard) scoreBoard.classList.remove('fire-lv1', 'fire-lv2', 'fire-lv3');
      statusElement.innerText = "RESET OK"; 
      statusElement.style.color = "white";
    }

    // --- 4. 核心邏輯 ---
    function onResults(results) {
      // 解析度控制
      const targetWidth = Math.min(window.innerWidth, 1280); 
      const aspectRatio = videoElement.videoHeight / videoElement.videoWidth || 0.75;
      const targetHeight = targetWidth * aspectRatio;

      if (canvasElement.width !== targetWidth) {
          canvasElement.width = targetWidth;
          canvasElement.height = targetHeight;
      }
      const cw = canvasElement.width;
      const ch = canvasElement.height;

      // 繪圖
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, cw, ch);
      canvasCtx.drawImage(results.image, 0, 0, cw, ch);

      // 浮動文字更新
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        let ft = floatingTexts[i];
        ft.life--; ft.offsetY -= 5;
        const visualX = cw - (ft.x * cw); 
        drawVisualText(canvasCtx, ft.text, visualX, (ft.y * ch) + ft.offsetY, ft.color);
        if (ft.life <= 0) floatingTexts.splice(i, 1);
      }

      // 冷卻倒數
      if (leftCooldown > 0) leftCooldown--;
      if (rightCooldown > 0) rightCooldown--;

      if (results.poseLandmarks) {
        drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: 'rgba(255, 255, 255, 0.2)', lineWidth: 1});
        
        const lm = results.poseLandmarks;
        const nose = lm[0];
        const leftShoulder = lm[11], rightShoulder = lm[12];
        const leftWrist = lm[15], rightWrist = lm[16];

        if (nose && leftShoulder && rightShoulder && leftWrist && rightWrist) {
          const shoulderWidth = calculateDistance(leftShoulder, rightShoulder);
          const stableScale = shoulderWidth * 2.5; // [調整] 參考比例尺稍微加大

          // 繪製目標中心
          const targetX = (nose.x - (stableScale * 0.6)) * cw; 
          const targetY = nose.y * ch;
          canvasCtx.beginPath();
          canvasCtx.strokeStyle = "#00FF00"; 
          canvasCtx.lineWidth = 4;
          canvasCtx.arc(targetX, targetY, 20, 0, 2 * Math.PI); 
          canvasCtx.stroke();

          // --- 左手處理 ---
          // 計算速度 (現在位置 - 上一幀位置)
          let leftSpeed = calculateDistance(leftWrist, prevLeftWrist);
          leftStage = processHand(
              leftShoulder, leftWrist, stableScale, leftStage, "L", 
              leftCooldown, CONFIG, leftSpeed
          );
          // 更新上一幀位置
          prevLeftWrist = { x: leftWrist.x, y: leftWrist.y };

          // --- 右手處理 ---
          let rightSpeed = calculateDistance(rightWrist, prevRightWrist);
          rightStage = processHand(
              rightShoulder, rightWrist, stableScale, rightStage, "R", 
              rightCooldown, CONFIG, rightSpeed
          );
          prevRightWrist = { x: rightWrist.x, y: rightWrist.y };
        }
      }
      canvasCtx.restore();
    }

    // 萬用手部處理函數 (包含防抖動與速度偵測)
    function processHand(shoulder, wrist, scale, currentStage, label, currentCooldown, config, speed) {
      const wristDist = calculateDistance(shoulder, wrist);
      const ratio = wristDist / scale;
      
      let nextStage = currentStage;
      const isLeft = label === "L";

      // 狀態機邏輯
      if (currentStage === "down") {
        // [新增條件] 必須同時滿足：
        // 1. 伸展比例夠大 (ratio > 0.85)
        // 2. 速度夠快 (speed > 0.015) -> 避免靜止擺架勢被誤判
        // 3. 冷卻結束
        if (currentCooldown === 0 && ratio > config.triggerRatio && speed > config.minSpeed) {
            nextStage = "punch";
        }
      }
      else if (currentStage === "punch") {
        // 一旦進入 Punch 狀態，必須等到手縮回到很短 (resetRatio 0.40) 才會觸發判定
        // 這能避免手伸直抖動時重複計分
        if (ratio < config.triggerRatio) { 
           // 這裡我們稍微寬鬆一點，只要開始縮回就算擊中，但必須完全縮回才能重置
           // 為了避免瞬間誤判，我們直接讓它擊中後進入 retract
           
           // 擊中效果
           count++;
           countElement.innerText = count;
           countElement.classList.remove('pop-effect');
           void countElement.offsetWidth;
           countElement.classList.add('pop-effect');
           
           playPunchSound();
           updateFireEffect(count);

           const color = isLeft ? "#00FFFF" : "#FFA500";
           spawnFloatingText(wrist.x, wrist.y, "+1", color);
           
           statusElement.innerText = isLeft ? "LEFT HIT!" : "RIGHT HIT!";
           statusElement.style.color = color;

           // 設定冷卻
           if (isLeft) leftCooldown = config.cooldownFrames;
           else rightCooldown = config.cooldownFrames;

           nextStage = "retract";
        }
      }
      else if (currentStage === "retract") {
        // [關鍵] 必須縮回到非常靠近身體 (0.40)，才能重置回 down 狀態
        // 這強迫使用者必須「確實收拳」才能打下一拳
        if (ratio < config.resetRatio) {
            nextStage = "down"; 
        }
      }

      return nextStage;
    }

    // --- 初始化與啟動 ---
    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ modelComplexity: 0, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    pose.onResults(onResults);

    window.initGame = async function() {
      console.log("正在嘗試啟動...");
      statusElement.innerText = "STARTING...";
      statusElement.style.color = "yellow";

      await loadSound();
      if (audioContext && audioContext.state === 'suspended') await audioContext.resume();

      const camera = new Camera(videoElement, {
        onFrame: async () => { await pose.send({image: videoElement}); }
      });

      try {
          await camera.start();
          statusElement.innerText = "READY";
          statusElement.style.color = "white";
          startBtn.style.display = 'none'; 
          resetBtn.style.display = 'block';
      } catch (e) {
          console.error(e);
          alert("攝影機啟動失敗，請確認權限或網址 (https/localhost)");
          statusElement.innerText = "CAM ERROR";
      }
    }
  </script>
