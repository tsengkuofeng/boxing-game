<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V19 è§’åº¦é‡ç½®é †æš¢ç‰ˆ</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* åŸºç¤å…¨è¢å¹•è¨­å®š */
    body { font-family: 'Segoe UI', sans-serif; background: #000; margin: 0; overflow: hidden; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 0; }
    video { display: none; }

    /* UI å±¤ */
    .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; }

    /* è¨ˆåˆ†æ¿ */
    .score-board { margin-top: 30px; padding: 15px 60px; border-radius: 20px; text-align: center; background: rgba(0, 0, 0, 0.6); border: 3px solid #555; transition: all 0.1s; }
    #count { font-size: 100px; font-weight: 900; line-height: 1; color: #fff; }
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; margin-bottom: 5px; }

    /* ç‹€æ…‹ç‡ˆ (Debugç”¨ï¼Œé¡¯ç¤ºæ˜¯å¦å¡ä½) */
    .state-indicator { margin-top: 5px; font-size: 12px; color: #555; display: flex; gap: 10px; }
    .state-dot { width: 8px; height: 8px; border-radius: 50%; background: #333; }
    .state-dot.ready { background: #00ff00; box-shadow: 0 0 5px #00ff00; } /* ç¶ ç‡ˆï¼šå¯å‡ºæ‹³ */
    .state-dot.busy { background: #ff0000; } /* ç´…ç‡ˆï¼šå¡åœ¨å‡ºæ‹³/å›æ”¶ä¸­ */

    /* é˜²ç¦¦UI */
    .info-bar { display: flex; gap: 20px; margin-top: 10px; justify-content: center; }
    .guard-box { display: flex; align-items: center; gap: 5px; color: #777; font-weight: bold; font-size: 14px; }
    .guard-led { width: 10px; height: 10px; border-radius: 50%; background: #444; border: 1px solid #777; }
    .guard-box.active { color: #00ff00; }
    .guard-box.active .guard-led { background: #00ff00; box-shadow: 0 0 10px #00ff00; border-color: #fff; }

    /* æŒ‰éˆ• */
    #start-btn, #reset-btn { position: absolute; pointer-events: auto; cursor: pointer; border: none; font-weight: bold; border-radius: 50px; color: white; }
    #start-btn { top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 60px; font-size: 24px; background: #0984e3; box-shadow: 0 0 30px rgba(9, 132, 227, 0.8); z-index: 100; }
    #reset-btn { bottom: 30px; right: 30px; padding: 12px 25px; background: #d63031; display: none; z-index: 100; }
    
    /* æ•¸æ“šé¡¯ç¤º */
    .debug-info { position: absolute; bottom: 30px; left: 30px; color: #00ff00; font-family: monospace; font-size: 16px; text-align: left; text-shadow: 1px 1px 0 #000; }

    /* ç‰¹æ•ˆ */
    .score-board.tier-1 { border-color: #00d2ff; box-shadow: 0 0 20px #00d2ff; }
    .score-board.tier-2 { border-color: #ffd700; box-shadow: 0 0 30px #ffd700; }
    .score-board.tier-3 { border-color: #ff4500; box-shadow: 0 0 40px #ff4500; }
    .hit-pop { animation: pop 0.1s ease-out; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }
  </style>
</head>
<body>

<div class="video-container">
  <video id="input_video" playsinline></video>
  <canvas id="output_canvas"></canvas>
</div>

<div class="ui-layer">
  <div class="score-board" id="score-board">
    <div class="count-label">COMBO</div>
    <div id="count">0</div>
    
    <div class="state-indicator">
       <div id="state-l" class="state-dot ready"></div> L-READY
       <div id="state-r" class="state-dot ready"></div> R-READY
    </div>

    <div class="info-bar">
      <div id="guard-left" class="guard-box"><div class="guard-led"></div> L-GUARD</div>
      <div id="guard-right" class="guard-box"><div class="guard-led"></div> R-GUARD</div>
    </div>
  </div>
  <div class="debug-info" id="debug-text">System Ready</div>
</div>

<button id="start-btn" onclick="initGame()">ğŸ¥Š å•Ÿå‹• V19 é †æš¢é€£æ“Šç‰ˆ</button>
<button id="reset-btn" onclick="resetCount()">RESET</button>

<script>
// --- éŸ³æ•ˆ ---
const PUNCH_SOUND_URL = 'punch.mp3'; 
let audioContext, punchBuffer;
async function loadSound() {
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        const res = await fetch(PUNCH_SOUND_URL);
        const buf = await res.arrayBuffer();
        punchBuffer = await audioContext.decodeAudioData(buf);
    } catch(e) {}
}
function playSound() {
    if (!audioContext || !punchBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const src = audioContext.createBufferSource();
    src.buffer = punchBuffer;
    src.connect(audioContext.destination);
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    src.start(0);
}

// --- V19 æ ¸å¿ƒåƒæ•¸ä¿®æ­£ ---
const CONFIG = {
    triggerZ: 0.28,     // å‡ºæ‹³åˆ¤å®šæ·±åº¦
    minSpeed: 0.04,     // å‡ºæ‹³åˆ¤å®šé€Ÿåº¦
    minArmAngle: 140,   // å‡ºæ‹³åˆ¤å®šè§’åº¦ (å¿…é ˆæ‰“ç›´)

    // [é—œéµä¿®æ­£] é‡ç½®æ¢ä»¶æ”¾å¯¬
    resetZ: 0.25,       // åŸæœ¬ 0.20 -> æ”¹ 0.25 (ç¨å¾®æ”¶å›å³å¯)
    resetAngle: 100,    // [æ–°å¢] åªè¦æ‰‹è‚˜è§’åº¦å°æ–¼ 100åº¦ï¼Œå¼·åˆ¶é‡ç½® (ä¸ç®¡ Z åœ¨å“ª)

    hitRadiusRatio: 0.7, 
    guardDistRatio: 0.65,
    cooldownFrames: 2   // å†·å»æ™‚é–“ç¸®çŸ­ï¼Œè®“é€£æ“Šæ›´çˆ½
};

// ç‹€æ…‹è®Šæ•¸
let count = 0;
let leftState = 0, rightState = 0; // 0:Ready, 1:Punch, 2:Retract
let leftCooldown = 0, rightCooldown = 0;
let leftGuardGrace = 0, rightGuardGrace = 0;
let lastLeftZ = 0, lastRightZ = 0;
let floatTexts = [];
let debugLeftAngle = 0, debugRightAngle = 0;

// DOM
const video = document.getElementById('input_video');
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const countEl = document.getElementById('count');
const board = document.getElementById('score-board');
const gl = document.getElementById('guard-left');
const gr = document.getElementById('guard-right');
const debugEl = document.getElementById('debug-text');
const stateL = document.getElementById('state-l');
const stateR = document.getElementById('state-r');

function spawnHit(x, y, isLeft) {
    if (floatTexts.length > 10) floatTexts.shift();
    floatTexts.push({ x, y, text: "HIT!", color: isLeft ? '#00d2ff' : '#ff9f43', life: 20, vy: -5 });
}

function calculate3DAngle(a, b, c) {
    const v1 = { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
    const v2 = { x: c.x - b.x, y: c.y - b.y, z: c.z - b.z };
    const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
    const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);
    return Math.acos(dot / (mag1 * mag2)) * (180.0 / Math.PI);
}

function processHand(shoulder, elbow, wrist, nose, scale, state, cooldown, isOppGuarding, lastZ) {
    let newState = state;
    let hit = false;
    
    const currentZ = shoulder.z - wrist.z;
    const velocity = currentZ - lastZ;
    const armAngle = calculate3DAngle(shoulder, elbow, wrist);

    // è·é›¢åˆ¤å®š
    const distToNose = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
    const inHitZone = distToNose < (scale * CONFIG.hitRadiusRatio);

    // ç‹€æ…‹æ©Ÿé‚è¼¯
    if (state === 0) { // Ready
        if (currentZ > CONFIG.triggerZ && 
            velocity > CONFIG.minSpeed && 
            inHitZone && 
            cooldown <= 0 && 
            isOppGuarding &&
            armAngle > CONFIG.minArmAngle
           ) {
            newState = 1;
            hit = true;
        }
    } 
    else if (state === 1) { 
        newState = 2; // æ‰“åˆ°å¾Œé¦¬ä¸Šé€²å…¥å›æ”¶æª¢æ¸¬
    } 
    else if (state === 2) { // Retract
        // [V19 ä¿®æ­£] é›™é‡é‡ç½®æ¢ä»¶ï¼šæ·±åº¦å›ä¾†äº† OR æ‰‹å½æ›²äº†
        if (currentZ < CONFIG.resetZ || armAngle < CONFIG.resetAngle) {
            newState = 0; // é‡ç½®å®Œæˆï¼Œå¯ä»¥æ‰“ä¸‹ä¸€æ‹³
        }
    }

    return { newState, hit, currentZ, armAngle };
}

function onResults(results) {
    if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }
    const cw = canvas.width, ch = canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, cw, ch);
    ctx.drawImage(results.image, 0, 0, cw, ch);

    if (results.poseLandmarks) {
        const lm = results.poseLandmarks;
        const nose = lm[0];
        const lS = lm[11], lE = lm[13], lW = lm[15];
        const rS = lm[12], rE = lm[14], rW = lm[16];
        const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

        if (nose && lS && rS && lW && rW) {
            const scale = Math.hypot(lS.x - rS.x, lS.y - rS.y) * 2.5;

            // éª¨æ¶
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#00ff00";
            ctx.lineCap = "round"; ctx.lineJoin = "round";
            ctx.beginPath();
            ctx.moveTo(lS.x * cw, lS.y * ch); ctx.lineTo(lE.x * cw, lE.y * ch); ctx.lineTo(lW.x * cw, lW.y * ch);
            ctx.moveTo(rS.x * cw, rS.y * ch); ctx.lineTo(rE.x * cw, rE.y * ch); ctx.lineTo(rW.x * cw, rW.y * ch);
            ctx.moveTo(lS.x * cw, lS.y * ch); ctx.lineTo(rS.x * cw, rS.y * ch);
            ctx.stroke();

            // æ“Šæ‰“åœˆ
            const hitR = scale * CONFIG.hitRadiusRatio;
            ctx.beginPath();
            const isPunching = (leftState === 1 || rightState === 1);
            ctx.strokeStyle = isPunching ? "rgba(255, 255, 255, 0.9)" : "rgba(255, 0, 0, 0.3)";
            ctx.fillStyle = isPunching ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 0, 0, 0.05)";
            ctx.arc(nose.x * cw, nose.y * ch, hitR * cw, 0, 2 * Math.PI);
            ctx.stroke(); ctx.fill();

            // é˜²ç¦¦èˆ‡é‚è¼¯
            const gDist = scale * CONFIG.guardDistRatio;
            if (Math.hypot(lW.x - chin.x, lW.y - chin.y) < gDist) leftGuardGrace = 5; else if (leftGuardGrace > 0) leftGuardGrace--;
            if (Math.hypot(rW.x - chin.x, rW.y - chin.y) < gDist) rightGuardGrace = 5; else if (rightGuardGrace > 0) rightGuardGrace--;
            const gL = leftGuardGrace > 0, gR = rightGuardGrace > 0;
            if (gL) gl.classList.add('active'); else gl.classList.remove('active');
            if (gR) gr.classList.add('active'); else gr.classList.remove('active');

            if (lastLeftZ === 0) { lastLeftZ = lS.z - lW.z; lastRightZ = rS.z - rW.z; }

            const resL = processHand(lS, lE, lW, nose, scale, leftState, leftCooldown, gR, lastLeftZ);
            const resR = processHand(rS, rE, rW, nose, scale, rightState, rightCooldown, gL, lastRightZ);

            leftState = resL.newState; lastLeftZ = resL.currentZ; debugLeftAngle = resL.armAngle;
            rightState = resR.newState; lastRightZ = resR.currentZ; debugRightAngle = resR.armAngle;

            // æ›´æ–° UI ç‹€æ…‹ç‡ˆ
            stateL.className = (leftState === 0) ? "state-dot ready" : "state-dot busy";
            stateR.className = (rightState === 0) ? "state-dot ready" : "state-dot busy";

            if (resL.hit) hitLogic(true, lW.x, lW.y);
            if (resR.hit) hitLogic(false, rW.x, rW.y);

            if (leftCooldown > 0) leftCooldown--;
            if (rightCooldown > 0) rightCooldown--;
            
            drawDot(lW, gL); drawDot(rW, gR);
        }
    }
    
    debugEl.innerText = `L-Angle: ${Math.round(debugLeftAngle)}Â° | R-Angle: ${Math.round(debugRightAngle)}Â°`;
    drawFloatingTexts(cw, ch);
    ctx.restore();
}

function hitLogic(isLeft, x, y) {
    count++;
    countEl.innerText = count;
    countEl.classList.remove('hit-pop'); void countEl.offsetWidth; countEl.classList.add('hit-pop');
    if(isLeft) leftCooldown = CONFIG.cooldownFrames; else rightCooldown = CONFIG.cooldownFrames;
    playSound();
    spawnHit(x, y, isLeft);
    board.className = 'score-board';
    if(count >= 100) board.classList.add('tier-3');
    else if(count >= 40) board.classList.add('tier-2');
    else if(count >= 20) board.classList.add('tier-1');
}

function drawDot(w, active) {
    ctx.beginPath();
    ctx.fillStyle = active ? "#00ff00" : "#d63031";
    ctx.arc(w.x * canvas.width, w.y * canvas.height, 10, 0, 2*Math.PI);
    ctx.fill();
}

function drawFloatingTexts(cw, ch) {
    ctx.scale(-1, 1);
    ctx.font = "900 60px Arial"; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
    for(let i=floatTexts.length-1; i>=0; i--){
        let t = floatTexts[i];
        let rx = -(cw - t.x*cw);
        ctx.fillStyle = t.color;
        ctx.strokeText(t.text, rx, t.y*ch); ctx.fillText(t.text, rx, t.y*ch);
        t.y += t.vy/ch; t.life--;
        if(t.life<=0) floatTexts.splice(i, 1);
    }
}

const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
pose.onResults(onResults);

async function initGame() {
    await loadSound();
    const camera = new Camera(video, { onFrame: async () => { await pose.send({image: video}); }, width: 1280, height: 720 });
    await camera.start();
    document.getElementById('start-btn').style.display = 'none';
    document.getElementById('reset-btn').style.display = 'block';
}
function resetCount() { count = 0; countEl.innerText = 0; board.className = 'score-board'; }
</script>
</body>
</html>
