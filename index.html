<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>XMAS BOXING V7.2 (Face Hit Fix)</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">
<style>
/* =========================================
   【全局與背景】
   ========================================= */
body { 
  font-family: 'Montserrat', sans-serif; 
  text-align: center; margin: 0; overflow: hidden; 
  color: #fff; background: #000;
  overscroll-behavior: none;
  user-select: none;
  -webkit-user-select: none;
}
.scene-background {
  position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
  z-index: -1; overflow: hidden;
  background: radial-gradient(circle at 50% 20%, #1a2a6c, #b21f1f00),
              linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
}
.moon {
  position: absolute; top: 40px; right: 40px; width: 100px; height: 100px;
  background: #fff; border-radius: 50%;
  box-shadow: 0 0 30px #fdfbf7, 0 0 80px rgba(255, 255, 255, 0.4);
  filter: blur(0.5px);
}
.snow-ground {
  position: absolute; bottom: 0; left: 0; width: 100%; height: 25%;
  background: linear-gradient(to bottom, #eef2f3, #8e9eab);
  border-radius: 100% 100% 0 0 / 30px 30px 0 0;
  box-shadow: 0 -10px 20px rgba(255,255,255,0.2);
}
.snowflake {
  position: absolute; top: -10px; background: white; border-radius: 50%; opacity: 0.8;
  animation: fall linear infinite;
  box-shadow: 0 0 5px rgba(255,255,255,0.8);
}
@keyframes fall {
  0% { top: -10%; transform: translateX(0); opacity: 0; }
  10% { opacity: 1; }
  100% { top: 105%; transform: translateX(20px); opacity: 0.3; }
}

/* =========================================
   【UI 佈局】
   ========================================= */
.container { position: relative; width: 100vw; height: 100vh; }
video, canvas { 
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
  object-fit: cover; transform: scaleX(-1); z-index: 0; 
}

/* --- 1. 登入頁面 --- */
#landing-layer {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  z-index: 100;
  display: flex; flex-direction: column; justify-content: center; align-items: center;
  background: rgba(0,0,0,0.4); 
  transition: opacity 0.5s ease;
}

.landing-title {
  font-size: 48px; font-weight: 900; color: #00d2ff;
  text-shadow: 0 0 20px rgba(0, 210, 255, 0.8);
  margin-bottom: 40px; letter-spacing: 4px;
  text-transform: uppercase;
  max-width: 90%;
  line-height: 1.2;
}

/* --- 2. 遊戲 HUD (靠右) --- */
#game-hud {
  position: absolute; 
  top: 85px; 
  right: 20px; 
  left: auto; 
  transform: none; 
  z-index: 50;
  display: none; 
  opacity: 0;
  transition: opacity 0.5s ease;
  pointer-events: none; 
}

.score-board { 
  background: rgba(15, 23, 42, 0.6); 
  backdrop-filter: blur(12px);
  padding: 10px 25px; 
  border-radius: 24px; 
  border: 1px solid rgba(255, 255, 255, 0.15); 
  box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
  text-align: center;
  display: inline-block;
}

#count { 
  font-size: 60px; 
  font-weight: 900; line-height: 1; 
  background: -webkit-linear-gradient(#fff, #cbd5e1);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 0 10px rgba(255,255,255,0.5));
}
.count-label { font-size: 12px; color: #94a3b8; letter-spacing: 3px; font-weight: 700; margin-bottom: 5px; }
#status { margin-top: 5px; font-size: 16px; font-weight: 700; color: #38bdf8; text-shadow: 0 0 5px rgba(56,189,248,0.5); }

/* --- 按鈕 --- */
#start-btn { 
  padding: 25px 60px; font-size: 28px; font-weight: 800; font-family: 'Montserrat', sans-serif;
  color: #fff; background: linear-gradient(135deg, #ef4444, #b91c1c);
  border: none; border-radius: 60px; cursor: pointer; 
  box-shadow: 0 0 40px rgba(239, 68, 68, 0.6);
  transition: transform 0.2s;
  touch-action: manipulation;
}
#start-btn:active { transform: scale(0.95); }

#reset-btn {
  position: absolute; top: 20px; right: 20px; z-index: 999;
  background: rgba(255, 255, 255, 0.2); color: #fff; 
  border: 1px solid rgba(255,255,255,0.4); 
  width: 50px; height: 50px; border-radius: 50%;
  font-size: 24px; font-weight: 700; 
  cursor: pointer; display: none; backdrop-filter: blur(5px);
  display: none; 
  align-items: center; justify-content: center;
  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}
#reset-btn:hover { background: rgba(255, 255, 255, 0.35); }
#reset-btn:active { transform: scale(0.9); }

@media (max-width: 768px) {
  .landing-title { font-size: 32px; }
  #start-btn { padding: 20px 40px; font-size: 20px; width: 80%; }
  #reset-btn { width: 55px; height: 55px; top: 15px; right: 15px; }
  #game-hud { top: 80px; right: 15px; transform: none; }
  .score-board { padding: 8px 20px; }
  #count { font-size: 50px; }
}

@media (min-width: 1024px) {
  .landing-title { font-size: 70px; margin-bottom: 60px; }
  #game-hud { transform: scale(1.2); transform-origin: top right; }
}

.pop-effect { animation: pop 0.1s ease-out; }
@keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }

</style>
</head>
<body>

<div class="scene-background">
  <div class="night-sky"><div class="moon"></div></div>
  <div class="snowflake" style="left: 10%; animation-delay: 0s; width: 8px; height: 8px;"></div>
  <div class="snowflake" style="left: 25%; animation-delay: 2s; width: 5px; height: 5px;"></div>
  <div class="snowflake" style="left: 45%; animation-delay: 4s; width: 10px; height: 10px;"></div>
  <div class="snowflake" style="left: 60%; animation-delay: 1s; width: 6px; height: 6px;"></div>
  <div class="snowflake" style="left: 85%; animation-delay: 3s; width: 9px; height: 9px;"></div>
  <div class="snow-ground"></div>
</div>

<div class="container">
  
  <div id="landing-layer">
    <div class="landing-title">XMAS BOXING<br>CHALLENGE</div>
    <button id="start-btn" onclick="initGame()">我的拳頭準備好了！</button>
  </div>

  <div id="game-hud">
    <div class="score-board">
      <div class="count-label">HITS</div>
      <div id="count">0</div>
      <div id="status">READY</div>
    </div>
  </div>

  <button id="reset-btn" onclick="resetCount()">↺</button>

  <div class="video-container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
// =========================================
//   1. 音效引擎
// =========================================
let audioCtx;
let punchBuffer = null;

async function loadAudio() {
    try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        const response = await fetch('punch.mp3');
        const arrayBuffer = await response.arrayBuffer();
        punchBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    } catch (e) {
        console.error("Audio Load Error:", e);
        statusElement.innerText = "AUDIO ERROR";
    }
}

function playHitSound(type) {
    if (!punchBuffer || !audioCtx) return;
    const source = audioCtx.createBufferSource();
    source.buffer = punchBuffer;
    if (type === 'heavy') source.playbackRate.value = 0.9;
    else source.playbackRate.value = 1.1;
    source.connect(audioCtx.destination);
    source.start(0);
}

// =========================================
//   2. 參數設定 (V7.2 - Face Hit Fix)
// =========================================
// 關鍵修正：降低 triggerRatio 讓「正前方短刺拳」也能觸發
const LEFT_HAND_CONFIG = {
    triggerRatio: 0.25, // 原本 0.38 -> 降至 0.25 (允許透視壓縮下的短拳)
    resetRatio: 0.30,   // 配合降低，讓縮回判定更靈敏
    minPunchAngle: 90,  // 角度放寬到 90度 (正拳手肘看起來會比較彎)
    cooldownFrames: 2
};

const RIGHT_HAND_CONFIG = {
    triggerRatio: 0.28, // 右手重拳稍微高一點點，避免誤判
    resetRatio: 0.30, 
    minPunchAngle: 90,
    cooldownFrames: 1
};

let count = 0;
let leftStage = "down"; 
let rightStage = "down";
let leftCooldown = 0;
let rightCooldown = 0;
let floatingTexts = []; 

const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');
const countElement = document.getElementById('count');
const statusElement = document.getElementById('status');
const landingLayer = document.getElementById('landing-layer');
const gameHud = document.getElementById('game-hud');
const resetBtn = document.getElementById('reset-btn');

// =========================================
//   3. 幾何計算
// =========================================
function calculateDistance(a, b) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

function calculateAngle(a, b, c) {
    const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
    let angle = Math.abs(radians * 180.0 / Math.PI);
    if (angle > 180.0) angle = 360 - angle;
    return angle;
}

// =========================================
//   4. 視覺繪製
// =========================================
function drawVisualText(ctx, text, visualX, visualY, color) {
  ctx.save();
  const internalX = ctx.canvas.width - visualX;
  ctx.translate(internalX, visualY);
  ctx.scale(-1, 1); 
  ctx.font = `900 40px 'Montserrat', sans-serif`;
  ctx.fillStyle = color;
  ctx.shadowColor = color;
  ctx.shadowBlur = 15;
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.strokeText(text, 0, 0);
  ctx.fillText(text, 0, 0); 
  ctx.restore();
}

function spawnFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 25, offsetY: 0, opacity: 1 });
}

function drawLine(ctx, a, b, color) {
    ctx.beginPath();
    ctx.moveTo(a.x * ctx.canvas.width, a.y * ctx.canvas.height);
    ctx.lineTo(b.x * ctx.canvas.width, b.y * ctx.canvas.height);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2; 
    ctx.stroke();
}

function drawDot(ctx, lm, color, radius=5) {
    const x = lm.x * ctx.canvas.width;
    const y = lm.y * ctx.canvas.height;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.shadowColor = color;
    ctx.shadowBlur = 10;
    ctx.stroke();
    ctx.shadowBlur = 0;
}

window.resetCount = function() {
  count = 0; 
  countElement.innerText = count; 
  floatingTexts = []; 
  leftCooldown = 0; rightCooldown = 0;
  leftStage = "down"; rightStage = "down";
  statusElement.innerText = "RESET OK"; 
}

// =========================================
//   5. 核心偵測邏輯 (V7.2 - Face Hit Optimized)
// =========================================
function onResults(results) {
  canvasElement.width = videoElement.videoWidth;
  canvasElement.height = videoElement.videoHeight;
  const cw = canvasElement.width;
  const ch = canvasElement.height;

  canvasCtx.save();
  canvasCtx.clearRect(0, 0, cw, ch);
  canvasCtx.drawImage(results.image, 0, 0, cw, ch);

  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    let ft = floatingTexts[i];
    ft.life--; ft.offsetY -= 5; ft.opacity -= 0.04;
    canvasCtx.globalAlpha = Math.max(0, ft.opacity);
    drawVisualText(canvasCtx, ft.text, cw - ft.x, ft.y + ft.offsetY, ft.color);
    canvasCtx.globalAlpha = 1.0;
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }

  if (leftCooldown > 0) leftCooldown--;
  if (rightCooldown > 0) rightCooldown--;

  if (results.poseLandmarks) {
    const lm = results.poseLandmarks;
    const skeletonColor = '#00ff00';
    const pairs = [[11,13], [13,15], [12,14], [14,16], [11,12]];
    pairs.forEach(p => {
        if(lm[p[0]] && lm[p[1]]) drawLine(canvasCtx, lm[p[0]], lm[p[1]], skeletonColor);
    });

    if (lm[11] && lm[12]) {
      const shoulderWidth = calculateDistance(lm[11], lm[12]);
      
      // 設定「腰線」：只要高於此線都算有效攻擊範圍 (包含胸口、頭部)
      let chestY = (lm[11].y + lm[12].y) / 2 + 0.1; // 肩膀稍微下面一點

      const nose = lm[0];
      const guardRadius = shoulderWidth * 0.8;

      if (lm[15]) {
         let dotColor = '#ff0000';
         if (nose && calculateDistance(lm[15], nose) < guardRadius) dotColor = '#00ff00';
         drawDot(canvasCtx, lm[15], dotColor, 8);
      }
      if (lm[16]) {
         let dotColor = '#ff0000';
         if (nose && calculateDistance(lm[16], nose) < guardRadius) dotColor = '#00ff00';
         drawDot(canvasCtx, lm[16], dotColor, 8);
      }

      if (lm[15] && lm[13] && lm[15].visibility > 0.5) {
        leftStage = processHandV7(lm[11], lm[13], lm[15], shoulderWidth, leftStage, "L", leftCooldown, LEFT_HAND_CONFIG, chestY);
      }
      if (lm[16] && lm[14] && lm[16].visibility > 0.5) {
        rightStage = processHandV7(lm[12], lm[14], lm[16], shoulderWidth, rightStage, "R", rightCooldown, RIGHT_HAND_CONFIG, chestY);
      }
    }
  }
  canvasCtx.restore();
}

function processHandV7(shoulder, elbow, wrist, scale, currentStage, label, cooldown, config, chestY) {
  // 1. 高度檢查：只要手比胸口高 (MediaPipe Y值越小越高)
  if (wrist.y > chestY) return currentStage;

  const dist = calculateDistance(shoulder, wrist);
  let ratio = dist / scale;
  if (label === "R") ratio *= 1.1; 

  const armAngle = calculateAngle(shoulder, elbow, wrist);
  const isArmStraight = armAngle > config.minPunchAngle;

  let nextStage = currentStage;

  if (currentStage === "down") {
    // 這裡 ratio 已經放寬，只要手臂有伸出且在胸部以上就算數
    if (ratio > config.triggerRatio && isArmStraight && cooldown === 0) {
      nextStage = "punch";
    }
  }
  else if (currentStage === "punch") {
    count++;
    countElement.innerText = count;
    
    const sb = document.querySelector('.score-board');
    sb.classList.remove('pop-effect');
    void sb.offsetWidth;
    sb.classList.add('pop-effect');

    if (label === "L") playHitSound('light'); 
    else playHitSound('heavy'); 

    if (label === "L") leftCooldown = config.cooldownFrames;
    else rightCooldown = config.cooldownFrames;

    const hitX = wrist.x * canvasElement.width;
    const hitY = wrist.y * canvasElement.height;
    const color = label === "L" ? "#00d2ff" : "#ff9900"; 
    spawnFloatingText(hitX, hitY, label === "L" ? "JAB!" : "CROSS!", color);
    
    statusElement.innerText = label === "L" ? "LEFT HIT!" : "RIGHT HIT!";
    statusElement.style.color = color;

    nextStage = "retract";
  }
  else if (currentStage === "retract") {
    if (ratio < config.resetRatio) {
      nextStage = "down"; 
    }
  }
  return nextStage;
}

// =========================================
//   6. 初始化
// =========================================
const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({ 
    modelComplexity: 1, 
    smoothLandmarks: true, 
    minDetectionConfidence: 0.5, 
    minTrackingConfidence: 0.5 
});
pose.onResults(onResults);

window.initGame = async function() {
  document.getElementById('start-btn').innerText = "啟動中...";
  await loadAudio();
  if (audioCtx && audioCtx.state === 'suspended') {
      await audioCtx.resume();
  }
  landingLayer.style.opacity = 0;
  setTimeout(() => { 
      landingLayer.style.display = 'none'; 
      gameHud.style.display = 'block';
      resetBtn.style.display = 'flex'; 
      setTimeout(() => gameHud.style.opacity = 1, 50);
  }, 500);
  const camera = new Camera(videoElement, {
    onFrame: async () => { await pose.send({image: videoElement}); },
    width: 640, height: 480
  });
  camera.start();
}
</script>
</body>
</html>
