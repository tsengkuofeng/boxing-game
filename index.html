<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>è–èª•æ‹³æ“Šç‰¹è¨“ - Christmas Boxing</title>
<style>
/* =========================================
   ã€æ–°å¢ã€‘è–èª•å¤œèƒŒæ™¯å ´æ™¯ CSS
   ========================================= */

/* å ´æ™¯å®¹å™¨ï¼šæ”¾åœ¨æœ€åº•å±¤ */
.scene-background {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  z-index: -1; /* é—œéµï¼æ”¾åœ¨æ”å½±æ©Ÿç•«é¢å¾Œé¢ */
  overflow: hidden;
  background: linear-gradient(to bottom, #020111 10%, #191d3a 50%, #2d3e5e 90%);
}

/* 1. æœˆäº® (ç™¼å…‰æ•ˆæœ) */
.moon {
  position: absolute;
  top: 50px; right: 50px;
  width: 80px; height: 80px;
  background: #fefcd7;
  border-radius: 50%;
  box-shadow: 0 0 20px #fefcd7, 0 0 50px rgba(254, 252, 215, 0.4);
}

/* 2. é›ªåœ° (ç™½è‰²) */
.snow-ground {
  position: absolute;
  bottom: 0; left: 0;
  width: 100%; height: 30%;
  background: #fffafa;
  border-top: 5px solid #e3e3e3;
  border-radius: 50% 50% 0 0 / 20px 20px 0 0;
}

/* 3. é›ªèŠ±å‹•ç•« */
.snowflake {
  position: absolute;
  top: -10px;
  background: white;
  border-radius: 50%;
  opacity: 0.8;
  animation: fall linear infinite;
}

@keyframes fall {
  0% { top: -10%; transform: translateX(0); }
  100% { top: 100%; transform: translateX(20px); }
}

/* é‡å°ä¸åŒé›ªèŠ±è¨­å®šä¸åŒå¤§å°å’Œé€Ÿåº¦ */
.snowflake:nth-child(2) { width: 8px; height: 8px; animation-duration: 7s; opacity: 0.6; }
.snowflake:nth-child(3) { width: 12px; height: 12px; animation-duration: 5s; opacity: 0.9; }
.snowflake:nth-child(4) { width: 6px; height: 6px; animation-duration: 8s; opacity: 0.5; }
.snowflake:nth-child(5) { width: 10px; height: 10px; animation-duration: 6s; opacity: 0.7; }
.snowflake:nth-child(6) { width: 9px; height: 9px; animation-duration: 9s; opacity: 0.8; }

/* =========================================
   UI èˆ‡ éŠæˆ²ä»‹é¢ CSS
   ========================================= */
body { 
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
  text-align: center; 
  background: transparent; /* è®“èƒŒæ™¯é€å‡º */
  color: #fff; 
  margin: 0; 
  overflow: hidden; 
}

.container { 
  position: relative; 
  width: 100vw; 
  height: 100vh; 
}

/* è®“ canvas è¦†è“‹åœ¨èƒŒæ™¯ä¸Šï¼Œä½†è¦åœ¨ UI ä¹‹ä¸‹ */
video, canvas { 
  position: absolute; 
  top: 0; left: 0; 
  width: 100%; height: 100%; 
  object-fit: cover; 
  transform: scaleX(-1);
  z-index: 0; 
}

/* --- è¨ˆåˆ†æ¿ --- */
.score-board { 
  position: absolute; 
  top: 80px; 
  left: 50%; 
  transform: translateX(-50%); 
  z-index: 10; 
  background: rgba(0, 0, 0, 0.6); 
  padding: 10px 40px; 
  border-radius: 20px; 
  border: 1px solid rgba(255, 255, 255, 0.3);
  pointer-events: none; 
  transition: all 0.3s ease;
}
#count { font-size: 70px; font-weight: 800; color: #fff; line-height: 1; }
.count-title { font-size: 14px; color: #ccc; letter-spacing: 2px; }
#status { margin-top: 5px; font-size: 18px; font-weight: bold; color: #ddd; }

/* --- é–‹å§‹æŒ‰éˆ• --- */
#start-btn { 
  position: absolute; 
  top: 50%; left: 50%; 
  transform: translate(-50%, -50%); 
  z-index: 50; 
  padding: 25px 50px; 
  font-size: 30px; 
  font-weight: 900;
  background: linear-gradient(135deg, #007bff, #0056b3); 
  color: white; 
  border: 4px solid rgba(255, 255, 255, 0.5); 
  border-radius: 60px; 
  cursor: pointer; 
  box-shadow: 0 0 30px rgba(0, 123, 255, 0.6); 
  white-space: nowrap;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.05); }
  100% { transform: translate(-50%, -50%) scale(1); }
}

/* --- æ­¸é›¶æŒ‰éˆ• --- */
#reset-btn {
  position: absolute;
  bottom: 40px; right: 20px;
  z-index: 100;
  background: #ff4757;
  color: white;
  border: 2px solid white;
  padding: 15px 30px;
  font-size: 18px;
  font-weight: bold;
  border-radius: 30px;
  cursor: pointer;
  display: none; 
}
#reset-btn:active { transform: scale(0.9); }

.pop-effect { animation: pop 0.1s ease-out; color: #00ff00 !important; }
@keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }

/* =========================================
   æ‰‹æ©Ÿæ©«å‘æ¨¡å¼ (Landscape) å„ªåŒ–
   ========================================= */
@media (max-height: 500px) and (orientation: landscape) {
  .score-board {
    top: 10px; left: 20px; transform: none; padding: 5px 20px; 
  }
  #count { font-size: 40px; }
  .count-title { font-size: 10px; }
  #status { font-size: 14px; margin-top: 0; }
  #start-btn { padding: 15px 30px; font-size: 20px; border-width: 2px; }
  #reset-btn { bottom: auto; top: 10px; right: 20px; padding: 8px 15px; font-size: 14px; }
}

/* =========================================
   å¤§è¢å¹• (Desktop) å„ªåŒ–
   ========================================= */
@media (min-width: 1024px) {
  .score-board {
    top: 60px; padding: 20px 80px; border-width: 3px; background: rgba(0, 0, 0, 0.7); 
    left: 50%; transform: translateX(-50%);
  }
  #count { font-size: 140px; text-shadow: 0 0 30px currentColor; }
  .count-title { font-size: 20px; letter-spacing: 5px; margin-bottom: 10px; }
  #status { font-size: 24px; }
}

/* =========================================
   ç«ç„°ç‡ƒç‡’ç‰¹æ•ˆ (ä¾ç…§åˆ†æ•¸è®Šè‰²)
   ========================================= */
.fire-lv1 {
  border-color: #ffd700 !important; color: #ffd700 !important;
  box-shadow: 0 0 15px rgba(255, 215, 0, 0.6), inset 0 0 10px rgba(255, 215, 0, 0.4);
  animation: burn-pulse 1s infinite alternate;
}
.fire-lv2 {
  border-color: #ff4500 !important; color: #ff4500 !important;
  box-shadow: 0 0 30px rgba(255, 69, 0, 0.8), inset 0 0 20px rgba(255, 69, 0, 0.5);
  animation: burn-pulse 0.4s infinite alternate;
}
.fire-lv3 {
  border-color: #00ffff !important; color: #00ffff !important;
  background: rgba(0, 255, 255, 0.1) !important;
  box-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #fff;
  animation: burn-max 0.1s infinite;
}

@keyframes burn-pulse {
  0% { box-shadow: 0 0 15px currentColor, inset 0 0 5px currentColor; }
  100% { box-shadow: 0 0 35px currentColor, inset 0 0 15px currentColor; transform: translateX(-50%) scale(1.05); }
}
@keyframes burn-max {
  0% { transform: translateX(-50%) translate(1px, 1px) scale(1.1); }
  25% { transform: translateX(-50%) translate(-1px, -2px) scale(1.1); }
  50% { transform: translateX(-50%) translate(-2px, 1px) scale(1.1); }
  75% { transform: translateX(-50%) translate(2px, 1px) scale(1.1); }
  100% { transform: translateX(-50%) translate(-1px, -1px) scale(1.1); }
}
</style>
</head>
<body>

<div class="scene-background">
  <div class="night-sky">
    <div class="moon"></div>
  </div>
  <div class="snowflake" style="left: 10%; animation-delay: 0s;"></div>
  <div class="snowflake" style="left: 30%; animation-delay: 2s;"></div>
  <div class="snowflake" style="left: 50%; animation-delay: 4s;"></div>
  <div class="snowflake" style="left: 70%; animation-delay: 1s;"></div>
  <div class="snowflake" style="left: 90%; animation-delay: 3s;"></div>
  
  <div class="snow-ground"></div>
</div>

<div class="container">
  <div class="score-board">
    <div class="count-title">TOTAL HITS</div>
    <div id="count">0</div>
    <div id="status">READY</div>
  </div>

  <div class="video-container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
  </div>

  <button id="start-btn" onclick="startCamera()">ğŸ¥Š é»æ“Šé–‹å§‹ (START)</button>
  <button id="reset-btn" onclick="resetCount()">æ­¸é›¶é‡ç½® (RESET)</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
// --- 0. éŸ³æ•ˆè¨­å®š (Sound Effect) ---
// ä½¿ç”¨çŸ­ä¿ƒçš„éŸ³æ•ˆç¶²å€ï¼Œæ”¯æ´é‡è¤‡æ’­æ”¾
const punchSoundLight = new Audio('https://assets.mixkit.co/active_storage/sfx/2151/2151-preview.mp3'); // è¼ƒè¼•çš„è²éŸ³ (Jab)
const punchSoundHeavy = new Audio('https://assets.mixkit.co/active_storage/sfx/2152/2152-preview.mp3'); // è¼ƒé‡çš„è²éŸ³ (Cross)

// é å…ˆè¼‰å…¥
punchSoundLight.load();
punchSoundHeavy.load();

// æ’­æ”¾éŸ³æ•ˆå‡½å¼ (è§£æ±ºå¿«é€Ÿé€£æ‰“æ™‚è²éŸ³è¢«åˆ‡æ–·çš„å•é¡Œ)
function playHitSound(type) {
    let soundToPlay = type === 'heavy' ? punchSoundHeavy : punchSoundLight;
    // è¤‡è£½ç¯€é»ï¼Œå…è¨±é‡ç–Šæ’­æ”¾
    let clone = soundToPlay.cloneNode();
    clone.volume = 0.8; // éŸ³é‡å¾®èª¿
    clone.play().catch(e => console.log("Audio play failed:", e));
}


// --- 1. å–å¾—ç¶²é å…ƒç´  ---
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');
const countElement = document.getElementById('count');
const scoreBoard = document.querySelector('.score-board'); 
const statusElement = document.getElementById('status');
const startBtn = document.getElementById('start-btn'); 
const resetBtn = document.getElementById('reset-btn'); 

// --- 2. åƒæ•¸è¨­å®š (å´é¢åˆ¤å®šé‚è¼¯) ---
// å·¦æ‰‹ (Jab)
const LEFT_CONFIG = {
  triggerRatio: 0.65, 
  resetRatio: 0.50,    
  angle: 100,           
  visibility: 0.4,      
  cooldownFrames: 5,    
  noseBlock: 0.30       
};

// å³æ‰‹ (Cross)
const RIGHT_CONFIG = {
  triggerRatio: 0.60,  
  resetRatio: 0.45,    
  angle: 90, 
  visibility: 0.3,
  cooldownFrames: 5,    
  noseBlock: 0.30       
};

const DOMINANCE_BUFFER = -0.05; 
const MAX_PUNCH_DURATION = 30; 
const ELEVATION_TOLERANCE = 0.3;

let count = 0;
let leftStage = "down"; 
let rightStage = "down";
let leftCooldown = 0;
let rightCooldown = 0;
let leftPunchTimer = 0;
let rightPunchTimer = 0;
let floatingTexts = []; 

// --- 3. å·¥å…·å‡½æ•¸ ---
function calculateAngle(a, b, c) {
  let radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
  let angle = Math.abs(radians * 180.0 / Math.PI);
  if (angle > 180.0) angle = 360 - angle;
  return angle;
}
function calculateDistance(a, b) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

function drawVisualText(ctx, text, visualX, visualY, color, fontSize = "24px") {
  ctx.save();
  const internalX = ctx.canvas.width - visualX;
  ctx.translate(internalX, visualY);
  ctx.scale(-1, 1); 
  ctx.font = `bold ${fontSize} Arial`;
  ctx.fillStyle = color;
  ctx.fillText(text, 0, 0); 
  ctx.restore();
}

function spawnFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 15, offsetY: 0 });
}

// ç«ç„°ç‰¹æ•ˆæ›´æ–°
function updateFireEffect(currentCount) {
  if (!scoreBoard) return;
  scoreBoard.classList.remove('fire-lv1', 'fire-lv2', 'fire-lv3');

  if (currentCount >= 100) {
    scoreBoard.classList.add('fire-lv3'); // MAX
  } else if (currentCount >= 80) {
    scoreBoard.classList.add('fire-lv2'); // Heavy
  } else if (currentCount >= 50) {
    scoreBoard.classList.add('fire-lv1'); // Light
  }
}

function triggerScoreBoardEffect() {
  countElement.classList.remove('pop-effect'); 
  void countElement.offsetWidth; 
  countElement.classList.add('pop-effect'); 
  updateFireEffect(count);
}

window.resetCount = function() {
  count = 0; 
  countElement.innerText = count; 
  floatingTexts = []; 
  leftCooldown = 0; rightCooldown = 0;
  leftStage = "down"; rightStage = "down";
  leftPunchTimer = 0; rightPunchTimer = 0;
  
  if (scoreBoard) {
    scoreBoard.classList.remove('fire-lv1', 'fire-lv2', 'fire-lv3');
  }
  
  statusElement.innerText = "RESET OK"; 
  statusElement.style.color = "white";
}

// --- 4. æ ¸å¿ƒé‚è¼¯ (åŒ…å«éŸ³æ•ˆè§¸ç™¼) ---
function onResults(results) {
  canvasElement.width = videoElement.videoWidth;
  canvasElement.height = videoElement.videoHeight;
  const cw = canvasElement.width;
  const ch = canvasElement.height;

  canvasCtx.save();
  // æ¸…é™¤ç•«å¸ƒï¼Œè®“èƒŒæ™¯é€å‡ºä¾†
  canvasCtx.clearRect(0, 0, cw, ch);
  
  // ç¹ªè£½åŠé€æ˜çš„æ”å½±æ©Ÿç•«é¢ï¼Œè®“èƒŒæ™¯å’Œäººå½±ç¨å¾®èåˆ (å¯é¸)
  // è‹¥è¦å¾ˆæ¸…æ¥šçš„äººåƒï¼ŒglobalAlpha è¨­ç‚º 1.0ï¼Œæˆ–ç›´æ¥ drawImage
  canvasCtx.drawImage(results.image, 0, 0, cw, ch);

  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    let ft = floatingTexts[i];
    ft.life--; ft.offsetY -= 5;
    
    const visualX = cw - ft.x; 
    drawVisualText(canvasCtx, ft.text, visualX, ft.y + ft.offsetY, ft.color, "60px");
    
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }

  if (leftCooldown > 0) leftCooldown--;
  if (rightCooldown > 0) rightCooldown--;

  // è¶…æ™‚é‡ç½®
  if (leftStage === "punch" && ++leftPunchTimer > MAX_PUNCH_DURATION) { leftStage = "down"; leftPunchTimer = 0; }
  else if (leftStage !== "punch") leftPunchTimer = 0;

  if (rightStage === "punch" && ++rightPunchTimer > MAX_PUNCH_DURATION) { rightStage = "down"; rightPunchTimer = 0; }
  else if (rightStage !== "punch") rightPunchTimer = 0;

  if (results.poseLandmarks) {
    drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: 'rgba(255, 255, 255, 0.4)', lineWidth: 1});
    
    const nose = results.poseLandmarks[0];
    const leftShoulder = results.poseLandmarks[11];
    const rightShoulder = results.poseLandmarks[12];
    const leftElbow = results.poseLandmarks[13];
    const rightElbow = results.poseLandmarks[14];
    const leftWrist = results.poseLandmarks[15];
    const rightWrist = results.poseLandmarks[16];

    if (nose && leftShoulder && rightShoulder) {
      const shoulderWidth = calculateDistance(leftShoulder, rightShoulder);
      const noseToShoulder = calculateDistance(nose, leftShoulder);
      const stableScale = Math.max(shoulderWidth, noseToShoulder * 1.8);

      const targetX = (nose.x - (stableScale * 1.2)) * cw;
      const targetY = nose.y * ch;

      canvasCtx.beginPath();
      canvasCtx.strokeStyle = "#00FF00"; 
      canvasCtx.lineWidth = 4;
      canvasCtx.arc(targetX, targetY, 20, 0, 2 * Math.PI); 
      canvasCtx.stroke();
      const visualTargetX = cw - targetX;
      drawVisualText(canvasCtx, "TARGET", visualTargetX - 40, targetY - 30, "rgba(0,255,0,0.8)", "16px");

      let leftRatio = 0, rightRatio = 0;
      if (leftElbow && leftWrist) leftRatio = calculateDistance(leftShoulder, leftWrist) / stableScale;
      if (rightElbow && rightWrist) rightRatio = calculateDistance(rightShoulder, rightWrist) / stableScale;

      const isLeftDominant = leftRatio > (rightRatio + DOMINANCE_BUFFER);
      const isRightDominant = rightRatio > (leftRatio + DOMINANCE_BUFFER);

      // å·¦æ‰‹è™•ç†
      if ((isLeftDominant || leftStage === "punch" || leftStage === "retract") && leftElbow && leftWrist && leftWrist.visibility > LEFT_CONFIG.visibility) {
        leftStage = processHand(leftShoulder, leftElbow, leftWrist, stableScale, leftStage, "L", nose, leftCooldown, LEFT_CONFIG);
      }

      // å³æ‰‹è™•ç†
      if ((isRightDominant || rightStage === "punch" || rightStage === "retract") && rightElbow && rightWrist && rightWrist.visibility > RIGHT_CONFIG.visibility) {
        rightStage = processHand(rightShoulder, rightElbow, rightWrist, stableScale, rightStage, "R", nose, rightCooldown, RIGHT_CONFIG);
      }
    }
  }
  canvasCtx.restore();
}

function processHand(shoulder, elbow, wrist, scale, currentStage, label, nose, currentCooldown, config) {
  const angle = calculateAngle(shoulder, elbow, wrist);
  const wristDist = calculateDistance(shoulder, wrist);
  const ratio = wristDist / scale;
  const wristToNoseDist = calculateDistance(wrist, nose);
  const noseRatio = wristToNoseDist / scale;

  let nextStage = currentStage;
  const isHighEnough = wrist.y < (shoulder.y + ELEVATION_TOLERANCE);

  // --- ç‹€æ…‹æ©Ÿé‚è¼¯ ---
  if (currentStage === "down") {
    if (currentCooldown === 0) {
      if (ratio > config.triggerRatio && noseRatio > config.noseBlock && isHighEnough) {
        nextStage = "punch";
      }
    }
  }
  else if (currentStage === "punch") {
    if (ratio < config.triggerRatio) {
      nextStage = "retract";
      
      // === æ“Šä¸­åˆ¤å®šæˆåŠŸ ===
      count++;
      countElement.innerText = count;
      triggerScoreBoardEffect(); 

      // ã€éŸ³æ•ˆè§¸ç™¼å€ã€‘
      // å·¦æ‰‹è¼•æ‹³ï¼Œå³æ‰‹é‡æ‹³
      if (label === "L") {
          playHitSound('light'); // æ’­æ”¾ Jab éŸ³æ•ˆ
      } else {
          playHitSound('heavy'); // æ’­æ”¾ Cross éŸ³æ•ˆ
      }

      if (label === "L") leftCooldown = config.cooldownFrames;
      else rightCooldown = config.cooldownFrames;

      const hitX = wrist.x * canvasElement.width;
      const hitY = wrist.y * canvasElement.height;
      const color = label === "L" ? "#00FFFF" : "#FFA500"; 
      spawnFloatingText(hitX + (Math.random()*40-20), hitY, "+1", color);
      statusElement.innerText = label === "L" ? "LEFT HIT!" : "RIGHT HIT!";
      statusElement.style.color = color;
    }
  }
  else if (currentStage === "retract") {
    if (ratio < config.resetRatio) {
      nextStage = "down"; 
    }
    else if (ratio > config.triggerRatio && currentCooldown === 0) {
      nextStage = "punch";
    }
  }

  return nextStage;
}

// --- åˆå§‹åŒ– ---
const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
pose.onResults(onResults);

// --- å•Ÿå‹•å‡½æ•¸ ---
window.startCamera = function() {
  // ç”¨æˆ¶äº’å‹•æ™‚å˜—è©¦æ’­æ”¾ä¸€æ¬¡éœéŸ³éŸ³æ•ˆï¼Œä»¥è§£é–ç€è¦½å™¨çš„éŸ³æ•ˆé™åˆ¶
  punchSoundLight.play().then(() => {
    punchSoundLight.pause();
    punchSoundLight.currentTime = 0;
  }).catch(e => console.log("Audio unlock failed", e));

  const camera = new Camera(videoElement, {
    onFrame: async () => { await pose.send({image: videoElement}); },
    width: 640, height: 480
  });
  camera.start();
  
  const btn = document.getElementById('start-btn');
  if (btn) {
    btn.style.display = 'none'; 
  }
  const rBtn = document.getElementById('reset-btn');
  if (rBtn) {
    rBtn.style.display = 'block';
  }
}
</script>
</body>
</html>
