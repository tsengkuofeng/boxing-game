<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V17 ç²¾æº–æ‰“æ“Šç‰ˆ (é€Ÿåº¦éæ¿¾)</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* å…¨è¢å¹•è¨­å®š */
    body { font-family: 'Segoe UI', sans-serif; background: #000; margin: 0; overflow: hidden; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 0; }
    video { display: none; }

    /* UI å±¤ */
    .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; }

    /* è¨ˆåˆ†æ¿ */
    .score-board { margin-top: 30px; padding: 15px 60px; border-radius: 20px; text-align: center; background: rgba(0, 0, 0, 0.6); border: 3px solid #555; transition: all 0.2s; }
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; margin-bottom: 5px; }
    #count { font-size: 100px; font-weight: 900; line-height: 1; color: #fff; }

    /* ç‰¹æ•ˆåˆ†ç´š */
    .score-board.tier-1 { border-color: #00d2ff; box-shadow: 0 0 20px #00d2ff; }
    .score-board.tier-2 { border-color: #ffd700; box-shadow: 0 0 30px #ffd700; animation: breath 0.5s infinite alternate; }
    .score-board.tier-3 { border-color: #ff4500; box-shadow: 0 0 40px #ff4500; animation: shake 0.3s infinite; }
    .score-board.tier-4 { border-color: #ff0000; box-shadow: 0 0 60px #ff0000; animation: shake-hard 0.2s infinite; }
    .hit-pop { animation: pop 0.1s ease-out; }

    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }
    @keyframes breath { 0% { transform: scale(1); } 100% { transform: scale(1.05); } }
    @keyframes shake { 0% { transform: rotate(-1deg); } 50% { transform: rotate(1deg); } 100% { transform: rotate(0deg); } }
    @keyframes shake-hard { 0% { transform: translate(-2px, 2px); } 50% { transform: translate(2px, -2px); } 100% { transform: translate(0, 0); } }

    /* é˜²ç¦¦èˆ‡æ•¸æ“šé¡¯ç¤º */
    .info-bar { display: flex; gap: 20px; margin-top: 10px; justify-content: center; }
    .guard-box { display: flex; align-items: center; gap: 5px; color: #777; font-weight: bold; font-size: 14px; }
    .guard-led { width: 10px; height: 10px; border-radius: 50%; background: #444; border: 1px solid #777; }
    .guard-box.active { color: #00ff00; }
    .guard-box.active .guard-led { background: #00ff00; box-shadow: 0 0 10px #00ff00; border-color: #fff; }

    /* æŒ‰éˆ• */
    #start-btn, #reset-btn { position: absolute; pointer-events: auto; cursor: pointer; border: none; font-weight: bold; border-radius: 50px; color: white; }
    #start-btn { top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 60px; font-size: 24px; background: #0984e3; box-shadow: 0 0 30px rgba(9, 132, 227, 0.8); z-index: 100; }
    #reset-btn { bottom: 30px; right: 30px; padding: 12px 25px; background: #d63031; display: none; z-index: 100; }
  </style>
</head>
<body>

<div class="video-container">
  <video id="input_video" playsinline></video>
  <canvas id="output_canvas"></canvas>
</div>

<div class="ui-layer">
  <div class="score-board" id="score-board">
    <div class="count-label">COMBO</div>
    <div id="count">0</div>
    <div class="info-bar">
      <div id="guard-left" class="guard-box"><div class="guard-led"></div> L-GUARD</div>
      <div id="guard-right" class="guard-box"><div class="guard-led"></div> R-GUARD</div>
    </div>
  </div>
</div>

<button id="start-btn" onclick="initGame()">ğŸ¥Š å•Ÿå‹• V17 ç²¾æº–ä¿®æ­£ç‰ˆ</button>
<button id="reset-btn" onclick="resetCount()">RESET</button>

<script>
// --- éŸ³æ•ˆ ---
const PUNCH_SOUND_URL = 'punch.mp3'; 
let audioContext, punchBuffer;
async function loadSound() {
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        const res = await fetch(PUNCH_SOUND_URL);
        const buf = await res.arrayBuffer();
        punchBuffer = await audioContext.decodeAudioData(buf);
    } catch(e) {}
}
function playSound() {
    if (!audioContext || !punchBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const src = audioContext.createBufferSource();
    src.buffer = punchBuffer;
    src.connect(audioContext.destination);
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    src.start(0);
}

// --- V17 é—œéµåƒæ•¸ ---
const CONFIG = {
    // 1. æ·±åº¦é–€æª» (é™ä½é›£åº¦)ï¼šæ‰‹è¦ä¼¸å¤šé•·æ‰ç®—ï¼Ÿ
    // åŸæœ¬ 0.35ï¼Œæ”¹ç‚º 0.28ï¼Œè®“ä½ ç¨å¾®å‡ºæ‹³å°±èƒ½è§¸ç™¼ï¼Œè§£æ±ºã€Œåµæ¸¬ä¸åˆ°ã€çš„å•é¡Œ
    triggerZ: 0.28,

    // 2. [æ–°å¢] é€Ÿåº¦é–€æª»ï¼šé˜²æ­¢æ…¢æ…¢èˆ‰æ‰‹è¢«èª¤åˆ¤
    // æ¯ä¸€å¹€ Z è»¸çš„è®ŠåŒ–é‡å¿…é ˆå¤§æ–¼æ­¤å€¼ï¼Œæ‰ç®—æ˜¯æœ‰ã€Œæ”»æ“Šæ„åœ–ã€
    minSpeed: 0.04, 

    // 3. é‡ç½®é–€æª»
    resetZ: 0.20,

    // 4. æ‰“æ“Šåœˆå¤§å° (é¼»å­å‘¨åœ)
    hitRadiusRatio: 0.7, 

    guardDistRatio: 0.65,
    cooldownFrames: 4
};

// ç‹€æ…‹è®Šæ•¸
let count = 0;
let leftState = 0, rightState = 0; // 0: Ready, 1: Punch, 2: Retract
let leftCooldown = 0, rightCooldown = 0;
let leftGuardGrace = 0, rightGuardGrace = 0;
let lastLeftZ = 0, lastRightZ = 0; // ç”¨æ–¼è¨ˆç®—é€Ÿåº¦
let floatTexts = [];

// DOM
const video = document.getElementById('input_video');
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const countEl = document.getElementById('count');
const board = document.getElementById('score-board');
const gl = document.getElementById('guard-left');
const gr = document.getElementById('guard-right');

// æµ®å‹•æ–‡å­— HIT
function spawnHit(x, y, isLeft) {
    if (floatTexts.length > 10) floatTexts.shift();
    floatTexts.push({ x, y, text: "HIT!", color: isLeft ? '#00d2ff' : '#ff9f43', life: 20, vy: -5 });
}

// æ ¸å¿ƒé‚è¼¯
function processHand(shoulder, wrist, nose, scale, state, cooldown, isOppGuarding, lastZ, label) {
    let newState = state;
    let hit = false;
    
    // è¨ˆç®—ç›®å‰çš„ Z ä¼¸å±•é‡ (Stroke)
    const currentZ = shoulder.z - wrist.z;
    
    // è¨ˆç®—é€Ÿåº¦ (é€™ä¸€å¹€çš„æ·±åº¦ - ä¸Šä¸€å¹€çš„æ·±åº¦)
    // å¦‚æœæ˜¯æ­£æ•¸ï¼Œä»£è¡¨æ­£åœ¨å¾€é¡é ­è¡
    const velocity = currentZ - lastZ;
    
    // è·é›¢åˆ¤å®š
    const distToNose = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
    const inHitZone = distToNose < (scale * CONFIG.hitRadiusRatio);

    if (state === 0) { // Ready
        // åˆ¤å®šæ¢ä»¶ï¼š
        // 1. æ·±åº¦å¤  (currentZ > threshold)
        // 2. é€Ÿåº¦å¤ å¿« (velocity > minSpeed) -> é€™æ˜¯è§£æ±ºã€Œèˆ‰æ‰‹èª¤åˆ¤ã€çš„é—œéµ
        // 3. åœ¨ç›®æ¨™åœˆå…§
        // 4. å°å´æ‰‹æœ‰é˜²ç¦¦ (é™¤éä½ æƒ³è¦å–®æ‰‹ç©ï¼Œå¯ç§»é™¤ isOppGuarding)
        
        if (currentZ > CONFIG.triggerZ && velocity > CONFIG.minSpeed && inHitZone && cooldown <= 0 && isOppGuarding) {
            newState = 1; // Punch!
            hit = true;
        }
    } 
    else if (state === 1) { 
        newState = 2; // é¦¬ä¸Šé€²å…¥å›æ”¶æª¢æŸ¥
    } 
    else if (state === 2) { // Retract
        if (currentZ < CONFIG.resetZ) newState = 0;
    }

    return { newState, hit, currentZ }; // å›å‚³ currentZ æ›´æ–° lastZ
}

function onResults(results) {
    // é–å®šè§£æåº¦
    if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }
    const cw = canvas.width, ch = canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, cw, ch);
    ctx.drawImage(results.image, 0, 0, cw, ch);

    if (results.poseLandmarks) {
        const lm = results.poseLandmarks;
        const nose = lm[0];
        const lS = lm[11], rS = lm[12];
        const lW = lm[15], rW = lm[16];
        const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

        if (nose && lS && rS && lW && rW) {
            const scale = Math.hypot(lS.x - rS.x, lS.y - rS.y) * 2.5;

            // --- 1. ç¹ªè£½ã€Œæœ‰æ•ˆæ“Šæ‰“å€åŸŸã€ (Debug åœˆåœˆ) ---
            // é€™æ˜¯ä½ è¦çš„ï¼šé¡¯ç¤ºç³»çµ±åˆ¤å®šçš„ç´…é»ç¯„åœ
            const hitR = scale * CONFIG.hitRadiusRatio;
            ctx.beginPath();
            ctx.lineWidth = 3;
            // å¦‚æœæœ‰äººå‡ºæ‹³ï¼Œåœˆåœˆè®Šäº®ç™½ï¼Œå¦å‰‡ç‚ºåŠé€æ˜ç´…
            const isPunching = (leftState === 1 || rightState === 1);
            ctx.strokeStyle = isPunching ? "rgba(255, 255, 255, 0.9)" : "rgba(255, 0, 0, 0.3)";
            ctx.fillStyle = isPunching ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 0, 0, 0.05)";
            ctx.arc(nose.x * cw, nose.y * ch, hitR * cw, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();
            
            // ç•«ä¸­å¿ƒé» (é¼»å­)
            ctx.beginPath(); ctx.fillStyle = "red"; ctx.arc(nose.x*cw, nose.y*ch, 5, 0, 2*Math.PI); ctx.fill();

            // --- 2. é˜²ç¦¦åˆ¤å®š ---
            const gDist = scale * CONFIG.guardDistRatio;
            if (Math.hypot(lW.x - chin.x, lW.y - chin.y) < gDist) leftGuardGrace = 5; else if (leftGuardGrace > 0) leftGuardGrace--;
            if (Math.hypot(rW.x - chin.x, rW.y - chin.y) < gDist) rightGuardGrace = 5; else if (rightGuardGrace > 0) rightGuardGrace--;
            
            const gL = leftGuardGrace > 0;
            const gR = rightGuardGrace > 0;
            
            if (gL) gl.classList.add('active'); else gl.classList.remove('active');
            if (gR) gr.classList.add('active'); else gr.classList.remove('active');

            // --- 3. è™•ç†å‡ºæ‹³ (å«é€Ÿåº¦åˆ¤å®š) ---
            // æ³¨æ„ï¼šç¬¬ä¸€æ¬¡åŸ·è¡Œ lastLeftZ ç‚º 0ï¼Œå¯èƒ½æœƒèª¤è§¸ï¼Œä½†ä¹‹å¾Œæœƒæ­£å¸¸
            if (lastLeftZ === 0) { lastLeftZ = lS.z - lW.z; lastRightZ = rS.z - rW.z; }

            const resL = processHand(lS, lW, nose, scale, leftState, leftCooldown, gR, lastLeftZ, 'L');
            const resR = processHand(rS, rW, nose, scale, rightState, rightCooldown, gL, lastRightZ, 'R');

            // æ›´æ–°ç‹€æ…‹èˆ‡æ•¸å€¼
            leftState = resL.newState; lastLeftZ = resL.currentZ;
            rightState = resR.newState; lastRightZ = resR.currentZ;

            if (resL.hit) { hitLogic(true, lW.x, lW.y); }
            if (resR.hit) { hitLogic(false, rW.x, rW.y); }

            if (leftCooldown > 0) leftCooldown--;
            if (rightCooldown > 0) rightCooldown--;
            
            // æ‰‹è…•å…‰é»
            drawDot(lW, gL); drawDot(rW, gR);
        }
    }

    // æ–‡å­—ç‰¹æ•ˆ
    drawFloatingTexts(cw, ch);
    ctx.restore();
}

function hitLogic(isLeft, x, y) {
    count++;
    countEl.innerText = count;
    countEl.classList.remove('hit-pop'); void countEl.offsetWidth; countEl.classList.add('hit-pop');
    
    if(isLeft) leftCooldown = CONFIG.cooldownFrames; else rightCooldown = CONFIG.cooldownFrames;
    playSound();
    spawnHit(x, y, isLeft);
    
    // UI Tier
    board.className = 'score-board';
    if(count >= 100) board.classList.add('tier-4');
    else if(count >= 70) board.classList.add('tier-3');
    else if(count >= 40) board.classList.add('tier-2');
    else if(count >= 20) board.classList.add('tier-1');
}

function drawDot(w, active) {
    ctx.beginPath();
    ctx.fillStyle = active ? "#00ff00" : "#d63031";
    ctx.arc(w.x * canvas.width, w.y * canvas.height, 10, 0, 2*Math.PI);
    ctx.fill();
}

function drawFloatingTexts(cw, ch) {
    ctx.scale(-1, 1);
    ctx.font = "900 60px Arial"; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
    for(let i=floatTexts.length-1; i>=0; i--){
        let t = floatTexts[i];
        let rx = -(cw - t.x*cw);
        ctx.fillStyle = t.color;
        ctx.strokeText(t.text, rx, t.y*ch); ctx.fillText(t.text, rx, t.y*ch);
        t.y += t.vy/ch; t.life--;
        if(t.life<=0) floatTexts.splice(i, 1);
    }
}

// å•Ÿå‹•
const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
pose.onResults(onResults);

async function initGame() {
    await loadSound();
    const camera = new Camera(video, { onFrame: async () => { await pose.send({image: video}); }, width: 1280, height: 720 });
    await camera.start();
    document.getElementById('start-btn').style.display = 'none';
    document.getElementById('reset-btn').style.display = 'block';
}
function resetCount() { count = 0; countEl.innerText = 0; board.className = 'score-board'; }
</script>
</body>
</html>
