<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V21 ç²¾æº–é˜²ç¦¦é–å®šç‰ˆ</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* åŸºç¤å…¨è¢å¹• */
    body { font-family: 'Segoe UI', monospace; background: #000; margin: 0; overflow: hidden; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 0; }
    video { display: none; }

    /* UI å±¤ */
    .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

    /* Debug å„€è¡¨æ¿ (å·¦å´) */
    .debug-panel {
        position: absolute; top: 20px; left: 20px;
        background: rgba(0, 0, 0, 0.8); border: 1px solid #555;
        padding: 15px; border-radius: 10px; text-align: left;
        color: #fff; font-size: 13px; line-height: 1.7; width: 200px;
    }
    .debug-header { border-bottom: 1px solid #555; margin-bottom: 5px; color: #aaa; font-size: 11px; letter-spacing: 1px; }
    .debug-row { display: flex; justify-content: space-between; }
    .val { font-weight: bold; font-family: monospace; }
    
    /* ç‹€æ…‹é¡è‰² */
    .pass { color: #00ff00; }    /* é€šé */
    .fail { color: #777; }       /* æœªé€šé (è®Šæš—ä»¥ä¾¿å°ˆæ³¨çœ‹ç¶ è‰²) */
    .locked { color: #ff3333; }  /* å¡ä½/å†·å» */

    /* è¨ˆåˆ†æ¿ (ä¸­å¤®) */
    .score-container { 
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center;
    }
    .score-board { 
        padding: 10px 50px; border-radius: 20px; text-align: center; 
        background: rgba(0, 0, 0, 0.6); border: 3px solid #555; transition: all 0.1s; 
    }
    #count { font-size: 110px; font-weight: 900; line-height: 1; color: #fff; }
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; }

    /* é˜²ç¦¦ç‹€æ…‹é¡¯ç¤º */
    .guard-status { margin-top: 10px; display: flex; gap: 15px; }
    .guard-item { display: flex; align-items: center; gap: 5px; color: #555; font-weight: bold; font-size: 12px; transition: color 0.2s; }
    .g-dot { width: 10px; height: 10px; border-radius: 50%; background: #333; border: 1px solid #555; }
    
    /* æ¿€æ´»ç‹€æ…‹ */
    .guard-item.active { color: #00ff00; }
    .guard-item.active .g-dot { background: #00ff00; box-shadow: 0 0 8px #00ff00; border-color: #fff; }

    /* æ‰“æ“Šç‰¹æ•ˆ */
    .hit-pop { animation: pop 0.1s ease-out; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }
    .score-board.tier-1 { border-color: #00d2ff; box-shadow: 0 0 20px #00d2ff; }
    .score-board.tier-2 { border-color: #ffd700; box-shadow: 0 0 30px #ffd700; }

    /* æŒ‰éˆ• */
    #start-btn, #reset-btn { position: absolute; pointer-events: auto; cursor: pointer; border: none; font-weight: bold; border-radius: 50px; color: white; }
    #start-btn { top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 60px; font-size: 24px; background: #0984e3; box-shadow: 0 0 30px rgba(9, 132, 227, 0.8); z-index: 100; }
    #reset-btn { bottom: 30px; right: 30px; padding: 12px 25px; background: #d63031; display: none; z-index: 100; }
  </style>
</head>
<body>

<div class="video-container">
  <video id="input_video" playsinline></video>
  <canvas id="output_canvas"></canvas>
</div>

<div class="ui-layer">
  <div class="debug-panel" id="debug-panel">
      <div class="debug-header">LEFT ARM DIAGNOSTIC</div>
      <div class="debug-row"><span>Depth (>0.22):</span> <span id="val-lz" class="val">0.00</span></div>
      <div class="debug-row"><span>Angle (>125Â°):</span> <span id="val-la" class="val">0Â°</span></div>
      <div class="debug-row"><span>Speed (>0.03):</span> <span id="val-ls" class="val">0.00</span></div>
      <div class="debug-row"><span>Opp.Guard:</span> <span id="val-lg" class="val">NO</span></div> <div class="debug-header" style="margin-top:15px;">RIGHT ARM DIAGNOSTIC</div>
      <div class="debug-row"><span>Depth (>0.22):</span> <span id="val-rz" class="val">0.00</span></div>
      <div class="debug-row"><span>Angle (>125Â°):</span> <span id="val-ra" class="val">0Â°</span></div>
      <div class="debug-row"><span>Speed (>0.03):</span> <span id="val-rs" class="val">0.00</span></div>
      <div class="debug-row"><span>Opp.Guard:</span> <span id="val-rg" class="val">NO</span></div>
  </div>

  <div class="score-container">
    <div class="score-board" id="score-board">
      <div class="count-label">COMBO</div>
      <div id="count">0</div>
    </div>
    <div class="guard-status">
        <div id="g-left" class="guard-item"><div class="g-dot"></div> LEFT GUARD</div>
        <div id="g-right" class="guard-item"><div class="g-dot"></div> RIGHT GUARD</div>
    </div>
  </div>
</div>

<button id="start-btn" onclick="initGame()">ğŸ¥Š å•Ÿå‹• V21 ç²¾æº–ç‰ˆ</button>
<button id="reset-btn" onclick="resetCount()">RESET</button>

<script>
// --- éŸ³æ•ˆ ---
const PUNCH_SOUND_URL = 'punch.mp3'; 
let audioContext, punchBuffer;
async function loadSound() {
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        const res = await fetch(PUNCH_SOUND_URL);
        const buf = await res.arrayBuffer();
        punchBuffer = await audioContext.decodeAudioData(buf);
    } catch(e) {}
}
function playSound() {
    if (!audioContext || !punchBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const src = audioContext.createBufferSource();
    src.buffer = punchBuffer;
    src.connect(audioContext.destination);
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    src.start(0);
}

// --- V21 åƒæ•¸ï¼šç²¾æº–èª¿æ ¡ ---
const CONFIG = {
    // 1. è§¸ç™¼é–€æª» (ä»‹æ–¼ V18 èˆ‡ V20 ä¹‹é–“)
    triggerZ: 0.22,      // 0.22: éæ¿¾èº«é«”æ™ƒå‹•ï¼Œä½†ä¸æœƒå¤ªé›£è§¸ç™¼
    minSpeed: 0.03,      // 0.03: è¼•æ‹³å¯éï¼Œæ…¢æ…¢æ¨æ‰‹ä¸é
    minArmAngle: 125,    // 125åº¦: è½‰èº«(90åº¦)ä¸æœƒè§¸ç™¼ï¼Œå‡ºæ‹³(>130)æœƒè§¸ç™¼

    // 2. é‡ç½®é–€æª» (å¯¬é¬†ï¼Œä¿æŒæµæš¢)
    resetZ: 0.25,        
    resetAngle: 100,     // æ‰‹è‚˜å½å› 100 åº¦å°±é‡ç½®

    // 3. éŠæˆ²æ€§
    hitRadiusRatio: 0.75, 
    guardDistRatio: 0.70, // é˜²ç¦¦åˆ¤å®šåœˆç¨å¾®åŠ å¤§ï¼Œæ¯”è¼ƒä¸æœƒå› ç‚ºå‡ºæ‹³èº«é«”æ‰­å‹•è€Œæ‰é˜²ç¦¦
    cooldownFrames: 2     // æ¥µçŸ­å†·å»
};

// ç‹€æ…‹
let count = 0;
let leftState = 0, rightState = 0;
let leftCooldown = 0, rightCooldown = 0;
let lastLeftZ = 0, lastRightZ = 0;
let floatTexts = [];

// DOM
const video = document.getElementById('input_video');
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const countEl = document.getElementById('count');
const board = document.getElementById('score-board');
const gl = document.getElementById('g-left');
const gr = document.getElementById('g-right');

// Debug Elements
const dbg = {
    lz: document.getElementById('val-lz'), la: document.getElementById('val-la'),
    ls: document.getElementById('val-ls'), lg: document.getElementById('val-lg'),
    rz: document.getElementById('val-rz'), ra: document.getElementById('val-ra'),
    rs: document.getElementById('val-rs'), rg: document.getElementById('val-rg')
};

function spawnHit(x, y, isLeft) {
    if (floatTexts.length > 10) floatTexts.shift();
    floatTexts.push({ x, y, text: "HIT!", color: isLeft ? '#00d2ff' : '#ff9f43', life: 20, vy: -5 });
}

function calculate3DAngle(a, b, c) {
    const v1 = { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
    const v2 = { x: c.x - b.x, y: c.y - b.y, z: c.z - b.z };
    const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
    const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);
    return Math.acos(dot / (mag1 * mag2)) * (180.0 / Math.PI);
}

function updateDebugPanel(isLeft, z, angle, speed, oppGuard, cooldown) {
    const p = isLeft ? 'l' : 'r';
    const elZ = dbg[p+'z'], elA = dbg[p+'a'], elS = dbg[p+'s'], elG = dbg[p+'g'];
    
    elZ.innerText = z.toFixed(2);
    elA.innerText = Math.round(angle) + "Â°";
    elS.innerText = speed.toFixed(3);
    elG.innerText = oppGuard ? "YES" : "NO";

    if (cooldown > 0) {
        elZ.className = elA.className = elS.className = elG.className = "val locked";
    } else {
        elZ.className = (z > CONFIG.triggerZ) ? "val pass" : "val fail";
        elA.className = (angle > CONFIG.minArmAngle) ? "val pass" : "val fail";
        elS.className = (speed > CONFIG.minSpeed) ? "val pass" : "val fail";
        elG.className = oppGuard ? "val pass" : "val fail"; // æ²’é˜²ç¦¦å°±è®Šæš—
    }
}

function processHand(shoulder, elbow, wrist, nose, scale, state, cooldown, lastZ, isOppGuarding, label) {
    let newState = state;
    let hit = false;
    
    const currentZ = shoulder.z - wrist.z;
    const velocity = currentZ - lastZ;
    const armAngle = calculate3DAngle(shoulder, elbow, wrist);
    const distToNose = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
    const inHitZone = distToNose < (scale * CONFIG.hitRadiusRatio);
    const isLeft = (label === 'L');

    // æ›´æ–° Debug é¢æ¿
    updateDebugPanel(isLeft, currentZ, armAngle, velocity, isOppGuarding, cooldown);

    if (state === 0) { // Ready
        // åš´æ ¼åˆ¤å®šæ¢ä»¶ï¼š
        // 1. æ·±åº¦å¤  (Z)
        // 2. é€Ÿåº¦å¤  (Speed)
        // 3. è§’åº¦å¤  (Angle) - é˜²æ­¢è½‰èº«
        // 4. å°å‘æ‰‹æœ‰é˜²ç¦¦ (OppGuard) - é˜²æ­¢äº‚æ®/é›™æ‰‹èª¤åˆ¤
        // 5. åœ¨æ‰“æ“Šåœˆå…§
        if (currentZ > CONFIG.triggerZ && 
            velocity > CONFIG.minSpeed && 
            armAngle > CONFIG.minArmAngle &&
            isOppGuarding && 
            inHitZone && 
            cooldown <= 0
           ) {
            newState = 1;
            hit = true;
        }
    } 
    else if (state === 1) { 
        newState = 2; 
    } 
    else if (state === 2) { 
        // å¯¬é¬†é‡ç½®
        if (currentZ < CONFIG.resetZ || armAngle < CONFIG.resetAngle) {
            newState = 0; 
        }
    }

    return { newState, hit, currentZ };
}

function onResults(results) {
    if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }
    const cw = canvas.width, ch = canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, cw, ch);
    ctx.drawImage(results.image, 0, 0, cw, ch);

    if (results.poseLandmarks) {
        const lm = results.poseLandmarks;
        const nose = lm[0];
        const lS = lm[11], lE = lm[13], lW = lm[15];
        const rS = lm[12], rE = lm[14], rW = lm[16];
        const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

        if (nose && lS && rS && lW && rW) {
            const scale = Math.hypot(lS.x - rS.x, lS.y - rS.y) * 2.5;

            // ç¹ªè£½éª¨æ¶
            ctx.lineWidth = 3; ctx.strokeStyle = "#00ff00"; ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(lS.x * cw, lS.y * ch); ctx.lineTo(lE.x * cw, lE.y * ch); ctx.lineTo(lW.x * cw, lW.y * ch);
            ctx.moveTo(rS.x * cw, rS.y * ch); ctx.lineTo(rE.x * cw, rE.y * ch); ctx.lineTo(rW.x * cw, rW.y * ch);
            ctx.stroke();

            // æ“Šæ‰“åœˆ
            const hitR = scale * CONFIG.hitRadiusRatio;
            const isPunching = (leftState === 1 || rightState === 1);
            ctx.beginPath();
            ctx.strokeStyle = isPunching ? "rgba(255, 255, 255, 0.8)" : "rgba(255, 0, 0, 0.3)";
            ctx.fillStyle = isPunching ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 0, 0, 0.05)";
            ctx.arc(nose.x * cw, nose.y * ch, hitR * cw, 0, 2 * Math.PI);
            ctx.stroke(); ctx.fill();

            // é˜²ç¦¦åµæ¸¬ (å…ˆè¨ˆç®—)
            const gDist = scale * CONFIG.guardDistRatio;
            const l_isGuarding = Math.hypot(lW.x - chin.x, lW.y - chin.y) < gDist;
            const r_isGuarding = Math.hypot(rW.x - chin.x, rW.y - chin.y) < gDist;

            // æ›´æ–° UI
            if (l_isGuarding) gl.classList.add('active'); else gl.classList.remove('active');
            if (r_isGuarding) gr.classList.add('active'); else gr.classList.remove('active');

            if (lastLeftZ === 0) { lastLeftZ = lS.z - lW.z; lastRightZ = rS.z - rW.z; }

            // æ ¸å¿ƒè™•ç†ï¼šå°‡ã€Œå°å‘æ‰‹çš„é˜²ç¦¦ç‹€æ…‹ã€å‚³å…¥
            // å·¦æ‰‹åˆ¤å®šæ™‚ï¼Œå‚³å…¥ r_isGuarding
            const resL = processHand(lS, lE, lW, nose, scale, leftState, leftCooldown, lastLeftZ, r_isGuarding, 'L');
            // å³æ‰‹åˆ¤å®šæ™‚ï¼Œå‚³å…¥ l_isGuarding
            const resR = processHand(rS, rE, rW, nose, scale, rightState, rightCooldown, lastRightZ, l_isGuarding, 'R');

            leftState = resL.newState; lastLeftZ = resL.currentZ;
            rightState = resR.newState; lastRightZ = resR.currentZ;

            if (resL.hit) hitLogic(true, lW.x, lW.y);
            if (resR.hit) hitLogic(false, rW.x, rW.y);

            if (leftCooldown > 0) leftCooldown--;
            if (rightCooldown > 0) rightCooldown--;
            
            drawDot(lW, l_isGuarding); drawDot(rW, r_isGuarding);
        }
    }
    
    drawFloatingTexts(cw, ch);
    ctx.restore();
}

function hitLogic(isLeft, x, y) {
    count++;
    countEl.innerText = count;
    countEl.classList.remove('hit-pop'); void countEl.offsetWidth; countEl.classList.add('hit-pop');
    if(isLeft) leftCooldown = CONFIG.cooldownFrames; else rightCooldown = CONFIG.cooldownFrames;
    playSound();
    spawnHit(x, y, isLeft);
    board.className = 'score-board';
    if(count >= 50) board.classList.add('tier-2');
    if(count >= 100) board.classList.add('tier-3');
}

function drawDot(w, active) {
    ctx.beginPath();
    ctx.fillStyle = active ? "#00ff00" : "#d63031";
    ctx.arc(w.x * canvas.width, w.y * canvas.height, 10, 0, 2*Math.PI);
    ctx.fill();
}

function drawFloatingTexts(cw, ch) {
    ctx.scale(-1, 1);
    ctx.font = "900 60px Arial"; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
    for(let i=floatTexts.length-1; i>=0; i--){
        let t = floatTexts[i];
        let rx = -(cw - t.x*cw);
        ctx.fillStyle = t.color;
        ctx.strokeText(t.text, rx, t.y*ch); ctx.fillText(t.text, rx, t.y*ch);
        t.y += t.vy/ch; t.life--;
        if(t.life<=0) floatTexts.splice(i, 1);
    }
}

const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
pose.onResults(onResults);

async function initGame() {
    await loadSound();
    const camera = new Camera(video, { onFrame: async () => { await pose.send({image: video}); }, width: 1280, height: 720 });
    await camera.start();
    document.getElementById('start-btn').style.display = 'none';
    document.getElementById('reset-btn').style.display = 'block';
}
function resetCount() { count = 0; countEl.innerText = 0; board.className = 'score-board'; }
</script>
</body>
</html>
