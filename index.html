<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>XMAS BOXING CHALLENGE V4</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">
<style>
/* =========================================
   【全域設定】
   ========================================= */
body { 
  font-family: 'Montserrat', sans-serif; 
  text-align: center; margin: 0; overflow: hidden; 
  color: #fff; background: #000;
}

/* 背景特效 (維持 V3 的高質感) */
.scene-background {
  position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
  z-index: -1; overflow: hidden;
  background: radial-gradient(circle at 50% 20%, #1a2a6c, #b21f1f00),
              linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
}
.moon {
  position: absolute; top: 40px; right: 40px; width: 100px; height: 100px;
  background: #fff; border-radius: 50%;
  box-shadow: 0 0 30px #fdfbf7, 0 0 80px rgba(255, 255, 255, 0.4);
  filter: blur(0.5px);
}
.snow-ground {
  position: absolute; bottom: 0; left: 0; width: 100%; height: 25%;
  background: linear-gradient(to bottom, #eef2f3, #8e9eab);
  border-radius: 100% 100% 0 0 / 30px 30px 0 0;
  box-shadow: 0 -10px 20px rgba(255,255,255,0.2);
}
.snowflake {
  position: absolute; top: -10px; background: white; border-radius: 50%; opacity: 0.8;
  animation: fall linear infinite;
  box-shadow: 0 0 5px rgba(255,255,255,0.8);
}
@keyframes fall {
  0% { top: -10%; transform: translateX(0); opacity: 0; }
  10% { opacity: 1; }
  100% { top: 105%; transform: translateX(20px); opacity: 0.3; }
}

/* =========================================
   【UI 分層結構】
   ========================================= */
.container { position: relative; width: 100vw; height: 100vh; }

/* 影像層 */
.video-container {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
}
video, canvas { 
  width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); 
}

/* --- 1. 登入首頁層 (Landing Page) --- */
#landing-layer {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  z-index: 200; /* 最上層 */
  display: flex; flex-direction: column; justify-content: center; align-items: center;
  background: rgba(0,0,0,0.4); /* 輕微變暗讓文字更清楚 */
  transition: opacity 0.5s ease;
}

.landing-title {
  font-size: 48px; font-weight: 900; color: #00d2ff;
  text-shadow: 0 0 20px rgba(0, 210, 255, 0.9);
  margin-bottom: 40px; letter-spacing: 3px; text-transform: uppercase;
  text-align: center; line-height: 1.2;
}

#start-btn { 
  padding: 25px 60px; font-size: 28px; font-weight: 800; font-family: 'Montserrat', sans-serif;
  color: #fff; 
  background: linear-gradient(135deg, #ef4444, #b91c1c);
  border: none; border-radius: 60px; cursor: pointer; 
  box-shadow: 0 0 40px rgba(239, 68, 68, 0.6);
  transition: all 0.3s ease; white-space: nowrap;
}
#start-btn:hover { transform: scale(1.1); box-shadow: 0 0 60px rgba(239, 68, 68, 0.9); }

/* --- 2. 遊戲進行層 (Game UI) --- */
#game-ui-layer {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  z-index: 100; pointer-events: none; /* 讓點擊穿透 */
  opacity: 0; transition: opacity 0.5s ease; /* 初始隱藏 */
}

.score-board { 
  position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
  background: rgba(15, 23, 42, 0.6); 
  backdrop-filter: blur(8px);
  padding: 10px 40px; 
  border-radius: 20px; 
  border: 1px solid rgba(255, 255, 255, 0.2); 
  box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
  text-align: center;
  transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

#count { 
  font-size: 80px; font-weight: 900; color: #fff; line-height: 1; 
  background: -webkit-linear-gradient(#fff, #cbd5e1);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 0 10px rgba(255,255,255,0.5));
}
.count-label { font-size: 14px; color: #94a3b8; letter-spacing: 3px; font-weight: 700; margin-bottom: 5px; }
#status { margin-top: 5px; font-size: 18px; font-weight: 700; color: #38bdf8; text-shadow: 0 0 5px rgba(56,189,248,0.5); }

#reset-btn {
  position: absolute; bottom: 30px; right: 30px; pointer-events: auto;
  background: rgba(255, 255, 255, 0.15); color: #fff; 
  border: 1px solid rgba(255,255,255,0.3); padding: 12px 30px; 
  font-size: 16px; font-weight: 700; border-radius: 30px; 
  cursor: pointer; backdrop-filter: blur(5px);
  transition: background 0.3s;
}
#reset-btn:hover { background: rgba(255, 255, 255, 0.3); }

/* =========================================
   【RWD 響應式調整】
   ========================================= */

/* 手機版 (小螢幕) */
@media (max-width: 768px) {
  .landing-title { font-size: 32px; width: 90%; }
  #start-btn { font-size: 20px; padding: 15px 40px; }
  .score-board { padding: 10px 30px; top: 20px; }
  #count { font-size: 60px; }
}

/* 筆電/桌機版 (大螢幕 - 放大計分板) */
@media (min-width: 1024px) {
  .score-board {
    top: 50px;
    /* 直接放大 1.3 倍，讓它在電腦上看更清楚 */
    transform: translateX(-50%) scale(1.3);
    padding: 20px 60px;
  }
  /* 當 scoreboard 有 pop 動畫時，要疊加 scale */
  .score-board.pop { transform: translateX(-50%) scale(1.4) !important; }
  
  .landing-title { font-size: 70px; max-width: 800px; }
  #start-btn { font-size: 36px; padding: 30px 80px; }
}

</style>
</head>
<body>

<div class="scene-background">
  <div class="night-sky"><div class="moon"></div></div>
  <div class="snowflake" style="left: 10%; animation-delay: 0s; width: 8px;"></div>
  <div class="snowflake" style="left: 30%; animation-delay: 2s; width: 5px;"></div>
  <div class="snowflake" style="left: 50%; animation-delay: 4s; width: 10px;"></div>
  <div class="snowflake" style="left: 70%; animation-delay: 1s; width: 6px;"></div>
  <div class="snowflake" style="left: 90%; animation-delay: 3s; width: 9px;"></div>
  <div class="snow-ground"></div>
</div>

<div class="container">
  <div class="video-container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
  </div>

  <div id="landing-layer">
    <div class="landing-title">XMAS<br>BOXING CHALLENGE</div>
    <button id="start-btn" onclick="startCamera()">我的拳頭準備好了！</button>
  </div>

  <div id="game-ui-layer">
    <div class="score-board">
      <div class="count-label">TOTAL HITS</div>
      <div id="count">0</div>
      <div id="status">GO!</div>
    </div>
    <button id="reset-btn" onclick="resetCount()">↺ 重置 (RESET)</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
// --- 音效設定 ---
const punchAudioBase = new Audio('punch.mp3');
punchAudioBase.load();

function playHitSound(type) {
    let clone = punchAudioBase.cloneNode();
    clone.volume = 0.9;
    if (type === 'heavy') clone.playbackRate = 0.9; 
    else clone.playbackRate = 1.2; 
    clone.play().catch(e => {});
}

// --- V4 核心參數 (高速連打優化) ---
const FRONT_PUNCH_CONFIG = {
  // 靈敏度：
  triggerRatio: 0.42, 
  
  // 防誤判 (手肘角度)：
  // 為了高速連打，稍微放寬一點點角度要求，避免快拳因為沒"完全"伸直被吃掉
  minPunchAngle: 105, 
  
  // 縮手判定 (Reset Ratio)：
  // [重要優化] 從 0.35 提升到 0.38。
  // 意義：手稍微縮回來一點點，系統就認定你可以打下一拳了。這能大幅提升連打速度。
  resetRatio: 0.38,
  
  // 冷卻時間 (Frames)：
  // [重要優化] 從 3 降為 2。
  // 只要電腦跑得動，允許每秒更密集的判定。
  cooldownFrames: 2, 
  
  elevationTolerance: 0.5 
};

// 狀態變數
let count = 0;
let leftStage = "down"; 
let rightStage = "down";
let leftCooldown = 0;
let rightCooldown = 0;
let floatingTexts = []; 

// UI 參考
const landingLayer = document.getElementById('landing-layer');
const gameUiLayer = document.getElementById('game-ui-layer');
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');
const countElement = document.getElementById('count');
const scoreBoard = document.querySelector('.score-board'); 
const statusElement = document.getElementById('status');

// --- 幾何計算 ---
function calculateDistance(a, b) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

function calculateAngle(a, b, c) {
    const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
    let angle = Math.abs(radians * 180.0 / Math.PI);
    if (angle > 180.0) angle = 360 - angle;
    return angle;
}

// --- 視覺繪圖 ---
function drawVisualText(ctx, text, visualX, visualY, color) {
  ctx.save();
  const internalX = ctx.canvas.width - visualX;
  ctx.translate(internalX, visualY);
  ctx.scale(-1, 1); 
  ctx.font = `900 45px 'Montserrat', sans-serif`; // 字體加大
  ctx.fillStyle = color;
  ctx.shadowColor = color;
  ctx.shadowBlur = 10;
  ctx.strokeStyle = "white";
  ctx.lineWidth = 1;
  ctx.strokeText(text, 0, 0);
  ctx.fillText(text, 0, 0); 
  ctx.restore();
}

function spawnFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 20, offsetY: 0, opacity: 1 });
}

// 繪製骨架 (細綠線) 與 拳頭狀態 (紅/綠圓點)
function drawSkeletonAndGuard(ctx, lm, shoulderWidth) {
    // 定義要畫的連線
    const connections = [
        [11, 13], [13, 15], // 左臂
        [12, 14], [14, 16], // 右臂
        [11, 12]            // 肩膀連線
    ];

    ctx.save();
    
    // 1. 畫細綠線骨架
    ctx.lineWidth = 2; // 細線
    ctx.strokeStyle = '#00ff00'; // 綠色
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 5;

    connections.forEach(([i, j]) => {
        const p1 = lm[i];
        const p2 = lm[j];
        if(p1 && p2 && p1.visibility > 0.5 && p2.visibility > 0.5) {
            ctx.beginPath();
            ctx.moveTo(p1.x * ctx.canvas.width, p1.y * ctx.canvas.height);
            ctx.lineTo(p2.x * ctx.canvas.width, p2.y * ctx.canvas.height);
            ctx.stroke();
        }
    });

    // 2. 畫拳頭狀態 (Guard Detection)
    // 簡單判定：如果手腕距離鼻子夠近，視為防禦 (Green)，否則垂下 (Red)
    const nose = lm[0];
    const leftWrist = lm[15];
    const rightWrist = lm[16];
    
    // 防禦判定的距離門檻 (約肩膀寬度的 0.8 倍)
    const guardThreshold = shoulderWidth * 0.8; 

    // 繪製圓點函數
    function drawHandPoint(wrist, isGuard) {
        if (!wrist || wrist.visibility < 0.5) return;
        const x = wrist.x * ctx.canvas.width;
        const y = wrist.y * ctx.canvas.height;
        
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, 2 * Math.PI); // 半徑 8 的圓點
        ctx.fillStyle = isGuard ? '#00ff00' : '#ff3333'; // 綠 or 紅
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    if (nose && leftWrist) {
        const distL = calculateDistance(nose, leftWrist);
        drawHandPoint(leftWrist, distL < guardThreshold);
    }
    if (nose && rightWrist) {
        const distR = calculateDistance(nose, rightWrist);
        drawHandPoint(rightWrist, distR < guardThreshold);
    }

    ctx.restore();
}

window.resetCount = function() {
  count = 0; 
  countElement.innerText = count; 
  floatingTexts = []; 
  leftCooldown = 0; rightCooldown = 0;
  leftStage = "down"; rightStage = "down";
  statusElement.innerText = "RESET OK"; 
  statusElement.style.color = "#38bdf8";
}

// --- 核心偵測 ---
function onResults(results) {
  canvasElement.width = videoElement.videoWidth;
  canvasElement.height = videoElement.videoHeight;
  const cw = canvasElement.width;
  const ch = canvasElement.height;

  canvasCtx.save();
  canvasCtx.clearRect(0, 0, cw, ch);
  canvasCtx.drawImage(results.image, 0, 0, cw, ch);

  // 浮動文字動畫
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    let ft = floatingTexts[i];
    ft.life--; ft.offsetY -= 5; ft.opacity -= 0.05;
    
    canvasCtx.globalAlpha = Math.max(0, ft.opacity);
    drawVisualText(canvasCtx, ft.text, cw - ft.x, ft.y + ft.offsetY, ft.color);
    canvasCtx.globalAlpha = 1.0;
    
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }

  if (leftCooldown > 0) leftCooldown--;
  if (rightCooldown > 0) rightCooldown--;

  if (results.poseLandmarks) {
    const lm = results.poseLandmarks;
    const leftShoulder = lm[11];
    const rightShoulder = lm[12];
    
    if (leftShoulder && rightShoulder) {
        const shoulderWidth = calculateDistance(leftShoulder, rightShoulder);

        // 1. 繪製骨架與防禦狀態 (視覺反饋)
        drawSkeletonAndGuard(canvasCtx, lm, shoulderWidth);

        // 2. 拳擊判定 (邏輯計算)
        const leftElbow = lm[13];
        const rightElbow = lm[14];
        const leftWrist = lm[15];
        const rightWrist = lm[16];

        // 左手
        if (leftWrist && leftElbow && leftWrist.visibility > 0.5) {
            leftStage = processHandV4(
                leftShoulder, leftElbow, leftWrist, 
                shoulderWidth, leftStage, "L", leftCooldown
            );
        }
      
        // 右手
        if (rightWrist && rightElbow && rightWrist.visibility > 0.5) {
            rightStage = processHandV4(
                rightShoulder, rightElbow, rightWrist, 
                shoulderWidth, rightStage, "R", rightCooldown
            );
        }
    }
  }
  canvasCtx.restore();
}

// V4 判定邏輯：優化速度
function processHandV4(shoulder, elbow, wrist, scale, currentStage, label, cooldown) {
  const dist = calculateDistance(shoulder, wrist);
  let ratio = dist / scale;
  
  // 右手補償
  if (label === "R") ratio *= 1.1; 

  // 角度與高度檢查
  const armAngle = calculateAngle(shoulder, elbow, wrist);
  const isArmStraight = armAngle > FRONT_PUNCH_CONFIG.minPunchAngle;
  const isHighEnough = wrist.y < (elbow.y + FRONT_PUNCH_CONFIG.elevationTolerance);

  let nextStage = currentStage;

  if (currentStage === "down") {
    // 出拳觸發
    if (ratio > FRONT_PUNCH_CONFIG.triggerRatio && isArmStraight && isHighEnough && cooldown === 0) {
      nextStage = "punch";
    }
  }
  else if (currentStage === "punch") {
    // 擊中
    count++;
    countElement.innerText = count;
    
    // UI 動畫 (支援大螢幕)
    scoreBoard.classList.remove('pop');
    void scoreBoard.offsetWidth; // trigger reflow
    scoreBoard.classList.add('pop');
    setTimeout(() => scoreBoard.classList.remove('pop'), 100);

    if (label === "L") playHitSound('light'); 
    else playHitSound('heavy'); 

    if (label === "L") leftCooldown = FRONT_PUNCH_CONFIG.cooldownFrames;
    else rightCooldown = FRONT_PUNCH_CONFIG.cooldownFrames;

    const hitX = wrist.x * canvasElement.width;
    const hitY = wrist.y * canvasElement.height;
    const color = label === "L" ? "#00d2ff" : "#ff9900"; 
    spawnFloatingText(hitX, hitY, label === "L" ? "JAB!" : "CROSS!", color);
    
    statusElement.innerText = label === "L" ? "LEFT HIT!" : "RIGHT HIT!";
    statusElement.style.color = color;

    nextStage = "retract";
  }
  else if (currentStage === "retract") {
    // 收拳優化：只要稍微縮回來就重置
    if (ratio < FRONT_PUNCH_CONFIG.resetRatio) {
      nextStage = "down"; 
    }
  }

  return nextStage;
}

// --- 初始化 ---
const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({ 
    modelComplexity: 1, 
    smoothLandmarks: true, 
    minDetectionConfidence: 0.5, 
    minTrackingConfidence: 0.5 
});
pose.onResults(onResults);

window.startCamera = function() {
  // 解鎖音效
  punchAudioBase.play().then(() => {
    punchAudioBase.pause();
    punchAudioBase.currentTime = 0;
  }).catch(e => console.log("Audio unlock failed"));

  // 1. 啟動相機
  const camera = new Camera(videoElement, {
    onFrame: async () => { await pose.send({image: videoElement}); },
    width: 640, height: 480
  });
  camera.start();
  
  // 2. UI 切換：隱藏首頁，顯示遊戲介面
  landingLayer.style.opacity = 0;
  setTimeout(() => {
    landingLayer.style.display = 'none';
    gameUiLayer.style.opacity = 1;
  }, 500); // 等待淡出動畫結束
}
</script>
</body>
</html>
