<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è–èª•æäºº (V15 HDæ·±åº¦ç‰¹æ•ˆç‰ˆ)</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* --- åŸºç¤è¨­å®š --- */
    body { 
      font-family: 'Segoe UI', sans-serif; 
      background: #000; margin: 0; overflow: hidden; user-select: none;
    }
    .container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
    
    /* ç¢ºä¿ç•«è³ªæ¸…æ™°çš„é—œéµï¼šCanvas ä¸ç”¨ CSS ç¡¬æ‹‰ï¼Œè€Œæ˜¯ä¿æŒæ¯”ä¾‹ */
    video { display: none; }
    canvas { 
        position: absolute; 
        max-width: 100%; max-height: 100%; 
        object-fit: contain; 
        transform: scaleX(-1); /* é¡åƒ */
    }
    
    .scene-bg { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; background: radial-gradient(circle, #1a1a1a 0%, #000 100%); }

    /* --- è¨ˆåˆ†æ¿ç‰¹æ•ˆ (Tier System) --- */
    .score-board { 
      position: absolute; top: 30px; left: 50%; transform: translateX(-50%); z-index: 10; 
      padding: 15px 60px; border-radius: 20px; 
      text-align: center; transition: all 0.2s ease-out;
      background: rgba(0, 0, 0, 0.7); 
      border: 3px solid #555;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; text-transform: uppercase; margin-bottom: 5px; }
    #count { font-size: 100px; font-weight: 900; line-height: 1; color: #fff; text-shadow: 0 5px 10px rgba(0,0,0,0.5); }

    /* ç‰¹æ•ˆåˆ†ç´š */
    /* LV1: 30+ (è—è‰²æ°£å ´) */
    .score-board.tier-1 { border-color: #00d2ff; box-shadow: 0 0 20px #00d2ff; background: rgba(0, 30, 60, 0.8); }
    .tier-1 #count { color: #e0f7fa; text-shadow: 0 0 20px #00d2ff; }

    /* LV2: 50+ (é‡‘é»ƒè‰²) */
    .score-board.tier-2 { border-color: #ffd700; box-shadow: 0 0 30px #ffd700; background: rgba(60, 50, 0, 0.8); animation: breath 0.5s infinite alternate; }
    .tier-2 #count { color: #fffde7; text-shadow: 0 0 25px #ffd700; }

    /* LV3: 70+ (ç‡ƒç‡’æ™ƒå‹•) */
    .score-board.tier-3 { border-color: #ff4500; box-shadow: 0 0 40px #ff4500; background: rgba(60, 10, 0, 0.8); animation: shake-mild 0.3s infinite; }
    .tier-3 #count { color: #ffccbc; text-shadow: 0 0 30px #ff4500; }

    /* LV4: 100+ (ç´«è‰²é›»æ¼¿) */
    .score-board.tier-4 { border-color: #d63031; background: rgba(50,0,0,0.9); box-shadow: 0 0 60px #ff0000; animation: shake-hard 0.2s infinite; }
    .tier-4 #count { color: #ffadad; text-shadow: 0 0 40px #ff0000, 0 0 10px #fff; }

    /* LV5: 150+ (æ•…éšœç¥åŸŸ) */
    .score-board.tier-5 { border: 5px solid #fff; background: #000; box-shadow: 0 0 80px #fff, 0 0 100px #ff00ff; animation: glitch-anim 0.1s infinite; }

    /* --- å‹•ç•« Keyframes --- */
    @keyframes breath { 0% { transform: translateX(-50%) scale(1); } 100% { transform: translateX(-50%) scale(1.05); } }
    @keyframes shake-mild { 0% { transform: translateX(-51%) rotate(-1deg); } 50% { transform: translateX(-49%) rotate(1deg); } 100% { transform: translateX(-50%) rotate(0deg); } }
    @keyframes shake-hard { 0% { transform: translate(-52%, 2px); } 25% { transform: translate(-48%, -2px); } 50% { transform: translate(-51%, -1px); } 75% { transform: translate(-49%, 1px); } 100% { transform: translate(-50%, 0); } }
    @keyframes glitch-anim { 0% { clip-path: inset(10% 0 80% 0); transform: translateX(-51%); } 50% { clip-path: inset(30% 0 10% 0); transform: translateX(-49%); } 100% { clip-path: inset(0 0 0 0); } }
    .hit-pop { animation: pop-scale 0.1s ease-out; }
    @keyframes pop-scale { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }

    /* --- é˜²ç¦¦ç‹€æ…‹æ¢ --- */
    .status-container { 
        display: flex; justify-content: center; gap: 20px; 
        margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 10px;
    }
    .guard-box {
        display: flex; align-items: center; gap: 8px; font-size: 14px; color: #777; font-weight: bold;
    }
    .guard-led { width: 12px; height: 12px; border-radius: 50%; background: #333; border: 2px solid #555; box-shadow: 0 0 5px #000; transition: all 0.1s; }
    .guard-box.active .guard-led { background: #00ff00; border-color: #fff; box-shadow: 0 0 10px #00ff00; }
    .guard-box.active { color: #00ff00; text-shadow: 0 0 5px rgba(0,255,0,0.5); }

    /* æŒ‰éˆ• */
    #start-btn, #reset-btn { position: absolute; z-index: 100; cursor: pointer; border: none; font-weight: bold; border-radius: 50px; color: white; transition: transform 0.1s;}
    #start-btn:active, #reset-btn:active { transform: scale(0.95); }
    #start-btn { top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 60px; font-size: 24px; background: linear-gradient(135deg, #0984e3, #74b9ff); box-shadow: 0 0 30px rgba(9, 132, 227, 0.8); }
    #reset-btn { bottom: 30px; right: 30px; padding: 12px 25px; background: #d63031; display: none; box-shadow: 0 0 15px rgba(214, 48, 49, 0.5); }
  </style>
</head>

<body>
  <div class="scene-bg"></div>

  <div class="container">
    <div class="score-board" id="score-board">
      <div class="count-label">COMBO HITS</div>
      <div id="count">0</div>
      
      <div class="status-container">
          <div id="guard-left" class="guard-box"><div class="guard-led"></div> LEFT</div>
          <div id="guard-right" class="guard-box"><div class="guard-led"></div> RIGHT</div>
      </div>
    </div>

    <div class="video-container">
      <video id="input_video" playsinline></video>
      <canvas id="output_canvas"></canvas>
    </div>

    <button id="start-btn" onclick="initGame()">ğŸ¥Š å•Ÿå‹• V15 é«˜ç•«è³ªç‰ˆ</button>
    <button id="reset-btn" onclick="resetCount()">é‡ç½® (RESET)</button>
  </div>

  <script>
    // --- 0. éŸ³æ•ˆæ¨¡çµ„ ---
    const PUNCH_SOUND_URL = 'punch.mp3'; 
    let audioContext = null, punchBuffer = null;
    async function loadSound() {
        try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            const res = await fetch(PUNCH_SOUND_URL);
            const buf = await res.arrayBuffer();
            punchBuffer = await audioContext.decodeAudioData(buf);
        } catch(e) { console.log("éŸ³æ•ˆåŠ è¼‰å¤±æ•—ï¼Œè«‹ç¢ºèª punch.mp3 å­˜åœ¨"); }
    }
    function playPunchSound() {
        if (!audioContext || !punchBuffer) return;
        if (audioContext.state === 'suspended') audioContext.resume();
        const src = audioContext.createBufferSource();
        src.buffer = punchBuffer;
        src.connect(audioContext.destination);
        src.playbackRate.value = 0.95 + Math.random() * 0.1; // è¼•å¾®éŸ³èª¿è®ŠåŒ–
        src.start(0);
    }

    // --- 1. æ ¸å¿ƒåƒæ•¸ (V13 Zè»¸é‚è¼¯ + V14 å¿«é€Ÿåˆ¤å®š) ---
    const CONFIG = {
        // [Zè»¸æ·±åº¦] æ•¸å€¼è¶Šå¤§ä»£è¡¨æ‰‹ä¼¸å¾—è¶Šé•· (ç›¸å°æ–¼è‚©è†€)
        // ç‚ºäº†è®“æ­£é¢ç›´æ‹³å®¹æ˜“è§¸ç™¼ï¼Œè¨­ç‚º 0.35 å·¦å³
        punchZThreshold: 0.35, 
        
        // [é‡ç½®æ·±åº¦] åªè¦æ‰‹ç¨å¾®æ”¶å› (å°æ–¼ 0.25)ï¼Œå°±å…è¨±ä¸‹ä¸€æ¬¡å‡ºæ‹³
        resetZThreshold: 0.25,

        // [æ‰“æ“Šç›®æ¨™] å¿…é ˆåœ¨é¼»å­å‘¨åœå¤šå¤§ç¯„åœå…§æ‰ç®—æœ‰æ•ˆ (Body Hit ä¸ç®—)
        hitRadiusRatio: 0.85, 

        // é˜²ç¦¦è·é›¢èˆ‡ç·©è¡
        guardDistRatio: 0.65, 
        cooldownFrames: 3 // ç¨çŸ­çš„å†·å»ï¼Œæ”¯æ´å¿«æ‹³
    };

    // --- 2. è®Šæ•¸åˆå§‹åŒ– ---
    let count = 0;
    let leftStage = "ready", rightStage = "ready";
    let leftCooldown = 0, rightCooldown = 0;
    let leftGuardGrace = 0, rightGuardGrace = 0;
    let floatTexts = []; // å­˜æ”¾ "HIT!"

    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { alpha: false }); // alpha: false æå‡æ•ˆèƒ½
    const countElement = document.getElementById('count');
    const scoreBoard = document.getElementById('score-board');
    const guardLeftUI = document.getElementById('guard-left');
    const guardRightUI = document.getElementById('guard-right');

    // --- 3. è¦–è¦ºèˆ‡é‚è¼¯å‡½å¼ ---

    // æµ®å‹•æ–‡å­— ("HIT!")
    function spawnHitText(x, y, isLeft) {
        if (floatTexts.length > 15) floatTexts.shift();
        floatTexts.push({
            x, y, 
            text: "HIT!", // æ”¹ç‚ºé¡¯ç¤º HIT
            color: isLeft ? '#00d2ff' : '#ff9f43',
            life: 20, 
            vy: -4 // å¾€ä¸Šé£„
        });
    }

    // æ›´æ–°è¨ˆåˆ†æ¿ç‰¹æ•ˆ
    function updateScoreBoardFX() {
        scoreBoard.className = 'score-board'; // é‡ç½®
        if (count >= 150) scoreBoard.classList.add('tier-5');
        else if (count >= 100) scoreBoard.classList.add('tier-4');
        else if (count >= 70) scoreBoard.classList.add('tier-3');
        else if (count >= 50) scoreBoard.classList.add('tier-2');
        else if (count >= 30) scoreBoard.classList.add('tier-1');

        countElement.classList.remove('hit-pop');
        void countElement.offsetWidth; // Trigger reflow
        countElement.classList.add('hit-pop');
    }

    // æ ¸å¿ƒåˆ¤å®šé‚è¼¯ (Zè»¸ + ç›®æ¨™åœˆ)
    function processHand(shoulder, wrist, nose, scale, stage, cooldown, isOppositeGuarding, label) {
        let nextStage = stage;
        let isHit = false;

        // 1. Zè»¸æ·±åº¦ (è‚©è†€Z - æ‰‹è…•Z)ã€‚æ­£å€¼ä»£è¡¨æ‰‹å¾€é¡é ­ä¼¸ã€‚
        const zDepth = shoulder.z - wrist.z;
        
        // 2. 2D å¹³é¢è·é›¢ (æ˜¯å¦æ‰“åœ¨è‡‰éƒ¨ç¯„åœ)
        const distToNose = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
        const hitZone = scale * CONFIG.hitRadiusRatio;
        const inHitZone = distToNose < hitZone;

        if (stage === "ready") {
            // è§¸ç™¼æ¢ä»¶ï¼šæ‰‹ä¼¸é•· + æ‰“åœ¨åœˆå…§ + å°å´æ‰‹é˜²ç¦¦ + ç„¡å†·å»
            if (zDepth > CONFIG.punchZThreshold && inHitZone && cooldown <= 0 && isOppositeGuarding) {
                nextStage = "punch";
                isHit = true;
            }
        } 
        else if (stage === "punch") {
            // å·²è§¸ç™¼ï¼Œæº–å‚™å›æ”¶
            nextStage = "retract";
        } 
        else if (stage === "retract") {
            // å›æ”¶æ¢ä»¶ï¼šæ‰‹ç¨å¾®ç¸®å›ä¾†å³å¯ (ä¸éœ€è¦ç¸®åˆ°åº•)
            if (zDepth < CONFIG.resetZThreshold) {
                nextStage = "ready";
            }
        }

        return { nextStage, isHit, zDepth }; // å›å‚³ zDepth ç”¨æ–¼ Debug æˆ–ç¹ªåœ–
    }

    // --- 4. ä¸»å¾ªç’° ---
    function onResults(results) {
        // [ç•«è³ªå„ªåŒ–] æ¯ä¸€å¹€éƒ½æª¢æŸ¥ä¸¦è¨­å®š Canvas å°ºå¯¸ç­‰æ–¼ Video åŸå§‹å°ºå¯¸
        if (videoElement.videoWidth > 0 && (canvasElement.width !== videoElement.videoWidth)) {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
        }
        
        const cw = canvasElement.width;
        const ch = canvasElement.height;

        // æ¸…ç©ºèˆ‡ç¹ªè£½æ”å½±æ©Ÿç•«é¢
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, cw, ch);
        canvasCtx.drawImage(results.image, 0, 0, cw, ch);

        if (results.poseLandmarks) {
            const lm = results.poseLandmarks;
            const nose = lm[0];
            const leftS = lm[11], rightS = lm[12];
            const leftW = lm[15], rightW = lm[16];
            
            // ä¸‹å·´ä¼°ç®—é» (å˜´è§’çš„å¹³å‡)
            const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

            if (nose && leftS && rightS && leftW && rightW) {
                // èº«é«”æ¯”ä¾‹å°º
                const shoulderWidth = Math.hypot(leftS.x - rightS.x, leftS.y - rightS.y);
                const scale = shoulderWidth * 2.5;

                // --- A. é˜²ç¦¦åµæ¸¬ ---
                const guardDist = scale * CONFIG.guardDistRatio;
                const distL = Math.hypot(leftW.x - chin.x, leftW.y - chin.y);
                const distR = Math.hypot(rightW.x - chin.x, rightW.y - chin.y);

                // é˜²ç¦¦å¯¬å®¹åº¦ (é¿å…é–ƒçˆ)
                if (distL < guardDist) leftGuardGrace = 5; else if (leftGuardGrace > 0) leftGuardGrace--;
                if (distR < guardDist) rightGuardGrace = 5; else if (rightGuardGrace > 0) rightGuardGrace--;

                const isGuardL = leftGuardGrace > 0;
                const isGuardR = rightGuardGrace > 0;

                // æ›´æ–°é˜²ç¦¦ UI
                if (isGuardL) guardLeftUI.classList.add('active'); else guardLeftUI.classList.remove('active');
                if (isGuardR) guardRightUI.classList.add('active'); else guardRightUI.classList.remove('active');

                // --- B. ç¹ªè£½ç›®æ¨™åœˆ (Target) ---
                // æ ¹æ“šæ˜¯å¦æœ‰äººæ­£åœ¨å‡ºæ‹³æ”¹è®Šé¡è‰²
                const anyPunch = (leftStage === "punch" || rightStage === "punch" || leftStage === "retract" || rightStage === "retract");
                
                canvasCtx.beginPath();
                canvasCtx.lineWidth = 4;
                if (anyPunch) {
                    canvasCtx.strokeStyle = "rgba(255, 255, 255, 0.8)"; // æ‰“æ“Šä¸­è®Šç™½
                    canvasCtx.shadowBlur = 20; canvasCtx.shadowColor = "white";
                } else {
                    canvasCtx.strokeStyle = "rgba(255, 50, 50, 0.4)"; // å¹³å¸¸æ˜¯æ·¡ç´…è‰²
                    canvasCtx.shadowBlur = 0;
                }
                canvasCtx.arc(nose.x * cw, nose.y * ch, scale * CONFIG.hitRadiusRatio * cw, 0, 2 * Math.PI);
                canvasCtx.stroke();
                canvasCtx.shadowBlur = 0; // Reset

                // --- C. å‡ºæ‹³åˆ¤å®š ---
                const resL = processHand(leftS, leftW, nose, scale, leftStage, leftCooldown, isGuardR, 'L');
                const resR = processHand(rightS, rightW, nose, scale, rightStage, rightCooldown, isGuardL, 'R');

                leftStage = resL.nextStage;
                rightStage = resR.nextStage;

                // è™•ç†å‘½ä¸­
                if (resL.isHit) {
                    count++;
                    leftCooldown = CONFIG.cooldownFrames;
                    playPunchSound();
                    updateScoreBoardFX();
                    spawnHitText(leftW.x, leftW.y, true);
                }
                if (resR.isHit) {
                    count++;
                    rightCooldown = CONFIG.cooldownFrames;
                    playPunchSound();
                    updateScoreBoardFX();
                    spawnHitText(rightW.x, rightW.y, false);
                }

                countElement.innerText = count;

                // å†·å»éæ¸›
                if (leftCooldown > 0) leftCooldown--;
                if (rightCooldown > 0) rightCooldown--;

                // ç¹ªè£½æ‰‹è…•é» (è¦–è¦ºè¼”åŠ©)
                function drawHandPoint(wrist, isGuarding) {
                    canvasCtx.beginPath();
                    canvasCtx.fillStyle = isGuarding ? "#00ff00" : "#ff3333";
                    canvasCtx.arc(wrist.x * cw, wrist.y * ch, 8, 0, 2 * Math.PI);
                    canvasCtx.fill();
                }
                drawHandPoint(leftW, isGuardL);
                drawHandPoint(rightW, isGuardR);
            }
        }

        // --- D. ç¹ªè£½æµ®å‹•æ–‡å­— (HIT!) ---
        ctx = canvasCtx;
        ctx.save();
        ctx.scale(-1, 1); // æ–‡å­—é¡åƒä¿®æ­£
        ctx.font = "italic 900 50px Arial";
        ctx.lineWidth = 2;
        ctx.strokeStyle = "white";
        
        for (let i = floatTexts.length - 1; i >= 0; i--) {
            let t = floatTexts[i];
            const rx = -(cw - (t.x * cw)); // åè½‰ X
            const ry = (t.y * ch);
            
            ctx.fillStyle = t.color;
            ctx.strokeText(t.text, rx, ry);
            ctx.fillText(t.text, rx, ry);
            
            t.y += t.vy / ch; // å¾€ä¸Šé£„
            t.life--;
            if (t.life <= 0) floatTexts.splice(i, 1);
        }
        ctx.restore();
        ctx.restore();
    }

    // --- 5. åˆå§‹åŒ– ---
    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({
        modelComplexity: 1, // 1 ç‚ºå¹³è¡¡ï¼Œ0 ç‚ºæ¥µé€Ÿï¼Œ2 ç‚ºé«˜ç²¾ç¢º(è¼ƒæ…¢)
        smoothLandmarks: true,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    pose.onResults(onResults);

    async function initGame() {
        await loadSound();
        const camera = new Camera(videoElement, {
            onFrame: async () => { await pose.send({image: videoElement}); },
            width: 1280, // è¨­å®šæ”åƒé ­è«‹æ±‚è§£æåº¦ (HD)
            height: 720
        });
        await camera.start();
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('reset-btn').style.display = 'block';
    }

    window.resetCount = function() {
        count = 0;
        countElement.innerText = 0;
        updateScoreBoardFX();
    }
  </script>
</body>
</html>
