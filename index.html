<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V18 è§’åº¦é–å®š+éª¨æ¶ç‰ˆ</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* åŸºç¤å…¨è¢å¹•è¨­å®š */
    body { font-family: 'Segoe UI', sans-serif; background: #000; margin: 0; overflow: hidden; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 0; }
    video { display: none; }

    /* UI å±¤ */
    .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; }

    /* è¨ˆåˆ†æ¿ */
    .score-board { margin-top: 30px; padding: 15px 60px; border-radius: 20px; text-align: center; background: rgba(0, 0, 0, 0.6); border: 3px solid #555; transition: all 0.2s; }
    #count { font-size: 100px; font-weight: 900; line-height: 1; color: #fff; }
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; margin-bottom: 5px; }

    /* ç‰¹æ•ˆ */
    .score-board.tier-1 { border-color: #00d2ff; box-shadow: 0 0 20px #00d2ff; }
    .score-board.tier-2 { border-color: #ffd700; box-shadow: 0 0 30px #ffd700; animation: breath 0.5s infinite alternate; }
    .score-board.tier-3 { border-color: #ff4500; box-shadow: 0 0 40px #ff4500; animation: shake 0.3s infinite; }
    .hit-pop { animation: pop 0.1s ease-out; }

    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }
    @keyframes breath { 0% { transform: scale(1); } 100% { transform: scale(1.05); } }
    @keyframes shake { 0% { transform: rotate(-1deg); } 50% { transform: rotate(1deg); } 100% { transform: rotate(0deg); } }

    /* é˜²ç¦¦UI */
    .info-bar { display: flex; gap: 20px; margin-top: 10px; justify-content: center; }
    .guard-box { display: flex; align-items: center; gap: 5px; color: #777; font-weight: bold; font-size: 14px; }
    .guard-led { width: 10px; height: 10px; border-radius: 50%; background: #444; border: 1px solid #777; }
    .guard-box.active { color: #00ff00; }
    .guard-box.active .guard-led { background: #00ff00; box-shadow: 0 0 10px #00ff00; border-color: #fff; }

    /* æŒ‰éˆ• */
    #start-btn, #reset-btn { position: absolute; pointer-events: auto; cursor: pointer; border: none; font-weight: bold; border-radius: 50px; color: white; }
    #start-btn { top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 60px; font-size: 24px; background: #0984e3; box-shadow: 0 0 30px rgba(9, 132, 227, 0.8); z-index: 100; }
    #reset-btn { bottom: 30px; right: 30px; padding: 12px 25px; background: #d63031; display: none; z-index: 100; }
    
    /* æ•¸æ“šé¡¯ç¤º (Debug) */
    .debug-info { position: absolute; bottom: 30px; left: 30px; color: #00ff00; font-family: monospace; font-size: 16px; text-align: left; text-shadow: 1px 1px 0 #000; }
  </style>
</head>
<body>

<div class="video-container">
  <video id="input_video" playsinline></video>
  <canvas id="output_canvas"></canvas>
</div>

<div class="ui-layer">
  <div class="score-board" id="score-board">
    <div class="count-label">COMBO</div>
    <div id="count">0</div>
    <div class="info-bar">
      <div id="guard-left" class="guard-box"><div class="guard-led"></div> L-GUARD</div>
      <div id="guard-right" class="guard-box"><div class="guard-led"></div> R-GUARD</div>
    </div>
  </div>
  <div class="debug-info" id="debug-text">Angle Data</div>
</div>

<button id="start-btn" onclick="initGame()">ğŸ¥Š å•Ÿå‹• V18 éª¨æ¶è§’åº¦ç‰ˆ</button>
<button id="reset-btn" onclick="resetCount()">RESET</button>

<script>
// --- éŸ³æ•ˆ ---
const PUNCH_SOUND_URL = 'punch.mp3'; 
let audioContext, punchBuffer;
async function loadSound() {
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        const res = await fetch(PUNCH_SOUND_URL);
        const buf = await res.arrayBuffer();
        punchBuffer = await audioContext.decodeAudioData(buf);
    } catch(e) {}
}
function playSound() {
    if (!audioContext || !punchBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const src = audioContext.createBufferSource();
    src.buffer = punchBuffer;
    src.connect(audioContext.destination);
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    src.start(0);
}

// --- V18 æ ¸å¿ƒåƒæ•¸ ---
const CONFIG = {
    triggerZ: 0.28,
    minSpeed: 0.04,
    resetZ: 0.20,
    hitRadiusRatio: 0.7, 
    
    // [æ–°å¢] æ‰‹è‡‚ä¼¸ç›´è§’åº¦é–€æª» (åº¦)
    // 180åº¦æ˜¯å…¨ç›´ã€‚è¨­ 140åº¦ å¯ä»¥å®¹è¨±å¿«é€Ÿå‡ºæ‹³æ²’å®Œå…¨æ‰“ç›´ï¼Œä½†èƒ½éæ¿¾æ‰ 90åº¦çš„è½‰èº«
    minArmAngle: 140, 

    guardDistRatio: 0.65,
    cooldownFrames: 4
};

// ç‹€æ…‹è®Šæ•¸
let count = 0;
let leftState = 0, rightState = 0;
let leftCooldown = 0, rightCooldown = 0;
let leftGuardGrace = 0, rightGuardGrace = 0;
let lastLeftZ = 0, lastRightZ = 0;
let floatTexts = [];
let debugLeftAngle = 0, debugRightAngle = 0;

// DOM
const video = document.getElementById('input_video');
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const countEl = document.getElementById('count');
const board = document.getElementById('score-board');
const gl = document.getElementById('guard-left');
const gr = document.getElementById('guard-right');
const debugEl = document.getElementById('debug-text');

function spawnHit(x, y, isLeft) {
    if (floatTexts.length > 10) floatTexts.shift();
    floatTexts.push({ x, y, text: "HIT!", color: isLeft ? '#00d2ff' : '#ff9f43', life: 20, vy: -5 });
}

// --- æ–°å¢ï¼šè¨ˆç®— 3D è§’åº¦å‡½å¼ ---
function calculate3DAngle(a, b, c) {
    // b æ˜¯é ‚é» (æ‰‹è‚˜)
    // å‘é‡ BA (è‚˜åˆ°è‚©)
    const v1 = { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
    // å‘é‡ BC (è‚˜åˆ°è…•)
    const v2 = { x: c.x - b.x, y: c.y - b.y, z: c.z - b.z };

    // å…§ç© (Dot Product)
    const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    
    // å‘é‡é•·åº¦ (Magnitude)
    const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
    const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);

    // é¤˜å¼¦å®šç†æ±‚è§’åº¦
    const angleRad = Math.acos(dot / (mag1 * mag2));
    const angleDeg = angleRad * (180.0 / Math.PI);
    
    return angleDeg;
}

function processHand(shoulder, elbow, wrist, nose, scale, state, cooldown, isOppGuarding, lastZ) {
    let newState = state;
    let hit = false;
    
    // 1. Z è»¸è·é›¢
    const currentZ = shoulder.z - wrist.z;
    // 2. é€Ÿåº¦
    const velocity = currentZ - lastZ;
    // 3. [æ–°å¢] 3D è§’åº¦
    const armAngle = calculate3DAngle(shoulder, elbow, wrist);

    // è·é›¢åˆ¤å®š
    const distToNose = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
    const inHitZone = distToNose < (scale * CONFIG.hitRadiusRatio);

    if (state === 0) { // Ready
        // åˆ¤å®šï¼šæ·±åº¦ + é€Ÿåº¦ + åœ¨åœˆå…§ + [æ–°å¢] æ‰‹è‡‚æ‰“ç›´
        if (currentZ > CONFIG.triggerZ && 
            velocity > CONFIG.minSpeed && 
            inHitZone && 
            cooldown <= 0 && 
            isOppGuarding &&
            armAngle > CONFIG.minArmAngle // <--- è½‰é«”éæ¿¾é—œéµ
           ) {
            newState = 1;
            hit = true;
        }
    } 
    else if (state === 1) { 
        newState = 2; 
    } 
    else if (state === 2) { 
        if (currentZ < CONFIG.resetZ) newState = 0;
    }

    return { newState, hit, currentZ, armAngle };
}

function onResults(results) {
    if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }
    const cw = canvas.width, ch = canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, cw, ch);
    ctx.drawImage(results.image, 0, 0, cw, ch);

    if (results.poseLandmarks) {
        const lm = results.poseLandmarks;
        const nose = lm[0];
        // ç²å–è‚©è†€ã€æ‰‹è‚˜ã€æ‰‹è…•
        const lS = lm[11], lE = lm[13], lW = lm[15];
        const rS = lm[12], rE = lm[14], rW = lm[16];
        const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

        if (nose && lS && rS && lW && rW) {
            const scale = Math.hypot(lS.x - rS.x, lS.y - rS.y) * 2.5;

            // --- 0. [æ–°å¢] ç¹ªè£½ç¶ è‰²éª¨æ¶ ---
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#00ff00"; // äº®ç¶ è‰²
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.beginPath();
            // å·¦æ‰‹
            ctx.moveTo(lS.x * cw, lS.y * ch);
            ctx.lineTo(lE.x * cw, lE.y * ch);
            ctx.lineTo(lW.x * cw, lW.y * ch);
            // å³æ‰‹
            ctx.moveTo(rS.x * cw, rS.y * ch);
            ctx.lineTo(rE.x * cw, rE.y * ch);
            ctx.lineTo(rW.x * cw, rW.y * ch);
            // è‚©è†€é€£ç·š
            ctx.moveTo(lS.x * cw, lS.y * ch);
            ctx.lineTo(rS.x * cw, rS.y * ch);
            ctx.stroke();

            // --- 1. æ“Šæ‰“åœˆ ---
            const hitR = scale * CONFIG.hitRadiusRatio;
            ctx.beginPath();
            const isPunching = (leftState === 1 || rightState === 1);
            ctx.strokeStyle = isPunching ? "rgba(255, 255, 255, 0.9)" : "rgba(255, 0, 0, 0.3)";
            ctx.fillStyle = isPunching ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 0, 0, 0.05)";
            ctx.arc(nose.x * cw, nose.y * ch, hitR * cw, 0, 2 * Math.PI);
            ctx.stroke(); ctx.fill();

            // --- 2. é˜²ç¦¦ ---
            const gDist = scale * CONFIG.guardDistRatio;
            if (Math.hypot(lW.x - chin.x, lW.y - chin.y) < gDist) leftGuardGrace = 5; else if (leftGuardGrace > 0) leftGuardGrace--;
            if (Math.hypot(rW.x - chin.x, rW.y - chin.y) < gDist) rightGuardGrace = 5; else if (rightGuardGrace > 0) rightGuardGrace--;
            const gL = leftGuardGrace > 0, gR = rightGuardGrace > 0;
            if (gL) gl.classList.add('active'); else gl.classList.remove('active');
            if (gR) gr.classList.add('active'); else gr.classList.remove('active');

            // --- 3. å‡ºæ‹³èˆ‡è§’åº¦è¨ˆç®— ---
            if (lastLeftZ === 0) { lastLeftZ = lS.z - lW.z; lastRightZ = rS.z - rW.z; }

            const resL = processHand(lS, lE, lW, nose, scale, leftState, leftCooldown, gR, lastLeftZ);
            const resR = processHand(rS, rE, rW, nose, scale, rightState, rightCooldown, gL, lastRightZ);

            leftState = resL.newState; lastLeftZ = resL.currentZ; debugLeftAngle = resL.armAngle;
            rightState = resR.newState; lastRightZ = resR.currentZ; debugRightAngle = resR.armAngle;

            if (resL.hit) hitLogic(true, lW.x, lW.y);
            if (resR.hit) hitLogic(false, rW.x, rW.y);

            if (leftCooldown > 0) leftCooldown--;
            if (rightCooldown > 0) rightCooldown--;
            
            drawDot(lW, gL); drawDot(rW, gR);
        }
    }
    
    // é¡¯ç¤ºå³æ™‚è§’åº¦ (Debug)
    debugEl.innerText = `L-Angle: ${Math.round(debugLeftAngle)}Â° | R-Angle: ${Math.round(debugRightAngle)}Â°`;

    drawFloatingTexts(cw, ch);
    ctx.restore();
}

function hitLogic(isLeft, x, y) {
    count++;
    countEl.innerText = count;
    countEl.classList.remove('hit-pop'); void countEl.offsetWidth; countEl.classList.add('hit-pop');
    if(isLeft) leftCooldown = CONFIG.cooldownFrames; else rightCooldown = CONFIG.cooldownFrames;
    playSound();
    spawnHit(x, y, isLeft);
    board.className = 'score-board';
    if(count >= 100) board.classList.add('tier-3');
    else if(count >= 40) board.classList.add('tier-2');
    else if(count >= 20) board.classList.add('tier-1');
}

function drawDot(w, active) {
    ctx.beginPath();
    ctx.fillStyle = active ? "#00ff00" : "#d63031";
    ctx.arc(w.x * canvas.width, w.y * canvas.height, 10, 0, 2*Math.PI);
    ctx.fill();
}

function drawFloatingTexts(cw, ch) {
    ctx.scale(-1, 1);
    ctx.font = "900 60px Arial"; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
    for(let i=floatTexts.length-1; i>=0; i--){
        let t = floatTexts[i];
        let rx = -(cw - t.x*cw);
        ctx.fillStyle = t.color;
        ctx.strokeText(t.text, rx, t.y*ch); ctx.fillText(t.text, rx, t.y*ch);
        t.y += t.vy/ch; t.life--;
        if(t.life<=0) floatTexts.splice(i, 1);
    }
}

const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
pose.onResults(onResults);

async function initGame() {
    await loadSound();
    const camera = new Camera(video, { onFrame: async () => { await pose.send({image: video}); }, width: 1280, height: 720 });
    await camera.start();
    document.getElementById('start-btn').style.display = 'none';
    document.getElementById('reset-btn').style.display = 'block';
}
function resetCount() { count = 0; countEl.innerText = 0; board.className = 'score-board'; }
</script>
</body>
</html>
