<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V22 聖誕校正版</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* 全局設定 */
    body { font-family: 'Segoe UI', monospace; margin: 0; overflow: hidden; background: #000; color: white; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; opacity: 0; transition: opacity 1s; }
    video { display: none; }

    /* ==================== */
    /* Phase 1: 聖誕夜空   */
    /* ==================== */
    #scene-intro {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
        background: linear-gradient(to bottom, #000011, #0a0a2a);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: opacity 1s;
    }

    /* 月亮 */
    .moon {
        position: absolute; top: 10%; right: 15%;
        width: 100px; height: 100px; background: #fff; border-radius: 50%;
        box-shadow: 0 0 40px #fff, 0 0 80px #ffffcc;
        animation: glow 3s infinite alternate;
    }
    @keyframes glow { from { box-shadow: 0 0 40px #fff; } to { box-shadow: 0 0 60px #fff, 0 0 100px #ffffcc; } }

    /* 雪花 */
    .snowflake {
        position: absolute; top: -10px; color: #fff; font-size: 1em; opacity: 0.8;
        animation: fall linear infinite;
    }
    @keyframes fall { to { transform: translateY(110vh); } }

    /* 標題與按鈕 */
    .intro-box { z-index: 10; text-align: center; }
    h1 { font-size: 60px; text-shadow: 0 0 20px #00d2ff; margin-bottom: 20px; }
    p { font-size: 18px; color: #ccc; margin-bottom: 40px; }
    
    .btn-main {
        padding: 15px 50px; font-size: 24px; border: none; border-radius: 50px;
        background: #e17055; color: white; cursor: pointer; font-weight: bold;
        box-shadow: 0 0 20px rgba(225, 112, 85, 0.6); transition: transform 0.2s;
    }
    .btn-main:hover { transform: scale(1.1); background: #fab1a0; }

    /* ==================== */
    /* Phase 2: 校正畫面   */
    /* ==================== */
    #scene-calibration {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 90;
        background: rgba(0,0,0,0.85); display: none;
        flex-direction: column; align-items: center; justify-content: center;
        text-align: center;
    }
    .calib-step { font-size: 36px; margin-bottom: 20px; color: #00d2ff; font-weight: bold; }
    .calib-instr { font-size: 20px; color: #ddd; margin-bottom: 40px; max-width: 600px; line-height: 1.5; }
    .calib-data { font-family: monospace; font-size: 24px; color: #fab1a0; margin-bottom: 30px; border: 1px solid #555; padding: 10px 30px; border-radius: 10px; }
    
    /* ==================== */
    /* Phase 3: 遊戲介面   */
    /* ==================== */
    #scene-game { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; display: none; }

    /* Debug 儀表板 */
    .debug-panel {
        position: absolute; top: 20px; left: 20px;
        background: rgba(0, 0, 0, 0.7); border: 1px solid #555;
        padding: 15px; border-radius: 10px; text-align: left;
        color: #fff; font-size: 13px; width: 220px; pointer-events: auto;
    }
    .debug-header { border-bottom: 1px solid #555; margin-bottom: 5px; color: #aaa; font-size: 11px; }
    .debug-row { display: flex; justify-content: space-between; margin-bottom: 3px; }
    .val { font-weight: bold; font-family: monospace; }
    .pass { color: #00ff00; } .fail { color: #777; } .locked { color: #ff3333; }

    /* 計分板 */
    .score-container { 
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center;
    }
    .score-board { 
        padding: 10px 50px; border-radius: 20px; text-align: center; 
        background: rgba(0, 0, 0, 0.6); border: 3px solid #555; 
    }
    #count { font-size: 110px; font-weight: 900; line-height: 1; color: #fff; }
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; }

    /* 防禦燈 */
    .guard-status { margin-top: 10px; display: flex; gap: 15px; }
    .guard-item { display: flex; align-items: center; gap: 5px; color: #555; font-weight: bold; font-size: 12px; }
    .guard-item.active { color: #00ff00; }
    .g-dot { width: 10px; height: 10px; border-radius: 50%; background: #333; border: 1px solid #555; }
    .guard-item.active .g-dot { background: #00ff00; box-shadow: 0 0 8px #00ff00; }

    /* 打擊特效 */
    .hit-pop { animation: pop 0.1s ease-out; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }
    .score-board.tier-1 { border-color: #00d2ff; box-shadow: 0 0 20px #00d2ff; }
    .score-board.tier-2 { border-color: #ffd700; box-shadow: 0 0 30px #ffd700; }

    /* 浮動文字 */
    .float-text { position: absolute; font-weight: 900; font-size: 40px; color: white; pointer-events: none; }
  </style>
</head>
<body>

<video id="input_video" playsinline></video>
<canvas id="output_canvas"></canvas>

<div id="scene-intro">
    <div class="moon"></div>
    <div id="snow-container"></div>
    <div class="intro-box">
        <h1>XMAS BOXING</h1>
        <p>V22 動態校正版 - 讓 AI 適應你的直拳</p>
        <button class="btn-main" onclick="startCalibrationFlow()">我準備好了!</button>
    </div>
</div>

<div id="scene-calibration">
    <div id="calib-step-text" class="calib-step">步驟 1/2</div>
    <div id="calib-instr-text" class="calib-instr">
        請對著鏡頭打出最標準的<b>左直拳</b>並定住不動。<br>
        系統將會偵測你的極限角度。
    </div>
    <div class="calib-data">
        目前角度: <span id="calib-live-angle">0</span>°
    </div>
    <button id="calib-btn" class="btn-main" onclick="runCalibrationStep()">開始偵測 (3秒)</button>
</div>

<div id="scene-game" class="ui-layer">
    <div class="debug-panel">
        <div class="debug-header">LEFT ARM (Target: ><span id="limit-la">0</span>°)</div>
        <div class="debug-row"><span>Depth:</span> <span id="val-lz" class="val">0.00</span></div>
        <div class="debug-row"><span>Angle:</span> <span id="val-la" class="val">0°</span></div>
        <div class="debug-row"><span>Speed:</span> <span id="val-ls" class="val">0.00</span></div>
        <div class="debug-row"><span>Opp.Guard:</span> <span id="val-lg" class="val">NO</span></div> 
        
        <div class="debug-header" style="margin-top:10px;">RIGHT ARM (Target: ><span id="limit-ra">0</span>°)</div>
        <div class="debug-row"><span>Depth:</span> <span id="val-rz" class="val">0.00</span></div>
        <div class="debug-row"><span>Angle:</span> <span id="val-ra" class="val">0°</span></div>
        <div class="debug-row"><span>Speed:</span> <span id="val-rs" class="val">0.00</span></div>
        <div class="debug-row"><span>Opp.Guard:</span> <span id="val-rg" class="val">NO</span></div>

        <div style="margin-top:10px; border-top:1px solid #555; padding-top:5px; font-size:10px; color:#aaa;">
            Calibrated Data used.
        </div>
    </div>

    <div class="score-container">
        <div class="score-board" id="score-board">
            <div class="count-label">COMBO</div>
            <div id="count">0</div>
        </div>
        <div class="guard-status">
            <div id="g-left" class="guard-item"><div class="g-dot"></div> L-GUARD</div>
            <div id="g-right" class="guard-item"><div class="g-dot"></div> R-GUARD</div>
        </div>
    </div>
</div>

<script>
// --- 0. 聖誕雪花生成 ---
function createSnow() {
    const container = document.getElementById('snow-container');
    for (let i = 0; i < 50; i++) {
        const d = document.createElement('div');
        d.className = 'snowflake';
        d.innerHTML = '❄';
        d.style.left = Math.random() * 100 + 'vw';
        d.style.animationDuration = (Math.random() * 3 + 2) + 's';
        d.style.fontSize = (Math.random() * 10 + 10) + 'px';
        container.appendChild(d);
    }
}
createSnow();

// --- 1. 全局變數 ---
let mode = 'INTRO'; // INTRO, CALIBRATING, GAME
let count = 0;
let leftState = 0, rightState = 0;
let leftCooldown = 0, rightCooldown = 0;
let floatTexts = [];
let lastLeftZ = 0, lastRightZ = 0;

// 校正數據
let calibration = {
    step: 0, // 0:Left, 1:Right, 2:Done
    maxLeftAngle: 0,
    maxRightAngle: 0,
    isMeasuring: false
};

// 最終使用的遊戲參數 (會被校正覆蓋)
let GAME_CONFIG = {
    triggerZ: 0.20,     // 基礎深度
    minSpeed: 0.03,
    
    // 這些會動態改變
    leftTriggerAngle: 125,
    rightTriggerAngle: 125,

    resetZ: 0.25,
    resetAngle: 100,
    hitRadiusRatio: 0.75,
    guardDistRatio: 0.70,
    cooldownFrames: 2
};

// DOM
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const video = document.getElementById('input_video');
const countEl = document.getElementById('count');
const board = document.getElementById('score-board');
const gl = document.getElementById('g-left');
const gr = document.getElementById('g-right');

// 音效
const PUNCH_SOUND_URL = 'punch.mp3'; 
let audioContext, punchBuffer;
async function loadSound() {
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        const res = await fetch(PUNCH_SOUND_URL);
        const buf = await res.arrayBuffer();
        punchBuffer = await audioContext.decodeAudioData(buf);
    } catch(e) {}
}
function playSound() {
    if (!audioContext || !punchBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const src = audioContext.createBufferSource();
    src.buffer = punchBuffer;
    src.connect(audioContext.destination);
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    src.start(0);
}

// --- 2. 流程控制 ---

async function startCalibrationFlow() {
    await loadSound();
    // 切換 UI
    document.getElementById('scene-intro').style.opacity = 0;
    setTimeout(() => { document.getElementById('scene-intro').style.display = 'none'; }, 1000);
    document.getElementById('scene-calibration').style.display = 'flex';
    
    // 啟動相機
    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    pose.onResults(onResults);
    
    const camera = new Camera(video, { onFrame: async () => { await pose.send({image: video}); }, width: 1280, height: 720 });
    await camera.start();
    
    mode = 'CALIBRATING';
    // 顯示 Canvas
    canvas.style.opacity = 0.3; // 校正時背景暗一點
}

function runCalibrationStep() {
    const btn = document.getElementById('calib-btn');
    const stepText = document.getElementById('calib-step-text');
    const instrText = document.getElementById('calib-instr-text');
    
    calibration.isMeasuring = true;
    let timeLeft = 3;
    
    btn.disabled = true;
    
    const timer = setInterval(() => {
        btn.innerText = `偵測中... ${timeLeft}`;
        timeLeft--;
        if (timeLeft < 0) {
            clearInterval(timer);
            calibration.isMeasuring = false;
            
            if (calibration.step === 0) {
                // 完成左手，準備右手
                playSound();
                calibration.step = 1;
                stepText.innerText = "步驟 2/2";
                instrText.innerHTML = "數據已記錄！<br>現在請打出最標準的<b>右直拳</b>並定住。";
                btn.innerText = "開始偵測 (3秒)";
                btn.disabled = false;
            } else {
                // 完成右手，進入遊戲
                playSound();
                finishCalibration();
            }
        }
    }, 1000);
}

function finishCalibration() {
    // 計算遊戲參數：取最大角度 - 15度 作為門檻
    // 如果偵測失敗(數據異常)，則使用預設 120
    GAME_CONFIG.leftTriggerAngle = Math.max(100, calibration.maxLeftAngle - 15);
    GAME_CONFIG.rightTriggerAngle = Math.max(100, calibration.maxRightAngle - 15);
    
    console.log("Calibration Result:", GAME_CONFIG.leftTriggerAngle, GAME_CONFIG.rightTriggerAngle);

    // 更新 UI
    document.getElementById('scene-calibration').style.display = 'none';
    document.getElementById('scene-game').style.display = 'block';
    canvas.style.opacity = 1;
    
    // 更新 Debug 面板上的目標值
    document.getElementById('limit-la').innerText = Math.round(GAME_CONFIG.leftTriggerAngle);
    document.getElementById('limit-ra').innerText = Math.round(GAME_CONFIG.rightTriggerAngle);
    
    mode = 'GAME';
}

// --- 3. 視覺與運算 ---

function calculate3DAngle(a, b, c) {
    const v1 = { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
    const v2 = { x: c.x - b.x, y: c.y - b.y, z: c.z - b.z };
    const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
    const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);
    return Math.acos(dot / (mag1 * mag2)) * (180.0 / Math.PI);
}

// 遊戲邏輯 (包含 V21 的防禦鎖)
function processHand(shoulder, elbow, wrist, nose, scale, state, cooldown, lastZ, isOppGuarding, label) {
    let newState = state;
    let hit = false;
    
    const currentZ = shoulder.z - wrist.z;
    const velocity = currentZ - lastZ;
    const armAngle = calculate3DAngle(shoulder, elbow, wrist);
    const distToNose = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
    const inHitZone = distToNose < (scale * GAME_CONFIG.hitRadiusRatio);
    const isLeft = (label === 'L');
    
    // 依據校正結果決定門檻
    const angleThreshold = isLeft ? GAME_CONFIG.leftTriggerAngle : GAME_CONFIG.rightTriggerAngle;

    // Debug Update
    const prefix = isLeft ? 'l' : 'r';
    const elZ = document.getElementById(`val-${prefix}z`);
    const elA = document.getElementById(`val-${prefix}a`);
    const elS = document.getElementById(`val-${prefix}s`);
    const elG = document.getElementById(`val-${prefix}g`);
    
    if (elZ) {
        elZ.innerText = currentZ.toFixed(2);
        elA.innerText = Math.round(armAngle) + "°";
        elS.innerText = velocity.toFixed(3);
        elG.innerText = isOppGuarding ? "YES" : "NO";

        if (cooldown > 0) {
            elZ.className = elA.className = elS.className = elG.className = "val locked";
        } else {
            elZ.className = (currentZ > GAME_CONFIG.triggerZ) ? "val pass" : "val fail";
            elA.className = (armAngle > angleThreshold) ? "val pass" : "val fail";
            elS.className = (velocity > GAME_CONFIG.minSpeed) ? "val pass" : "val fail";
            elG.className = isOppGuarding ? "val pass" : "val fail";
        }
    }

    if (state === 0) { // Ready
        if (currentZ > GAME_CONFIG.triggerZ && 
            velocity > GAME_CONFIG.minSpeed && 
            armAngle > angleThreshold && // 使用校正後的門檻
            isOppGuarding && 
            inHitZone && 
            cooldown <= 0
           ) {
            newState = 1;
            hit = true;
        }
    } else if (state === 1) { 
        newState = 2; 
    } else if (state === 2) { 
        if (currentZ < GAME_CONFIG.resetZ || armAngle < GAME_CONFIG.resetAngle) {
            newState = 0; 
        }
    }
    return { newState, hit, currentZ };
}

function onResults(results) {
    // 調整畫布尺寸
    if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }
    const cw = canvas.width, ch = canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, cw, ch);
    
    // 繪製影像 (在 Calibration 時稍微暗一點)
    ctx.globalAlpha = (mode === 'CALIBRATING') ? 0.5 : 1.0;
    ctx.drawImage(results.image, 0, 0, cw, ch);
    ctx.globalAlpha = 1.0;

    if (!results.poseLandmarks) { ctx.restore(); return; }
    
    const lm = results.poseLandmarks;
    const nose = lm[0];
    const lS = lm[11], lE = lm[13], lW = lm[15];
    const rS = lm[12], rE = lm[14], rW = lm[16];
    const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

    if (!nose || !lS || !rS) { ctx.restore(); return; }
    const scale = Math.hypot(lS.x - rS.x, lS.y - rS.y) * 2.5;

    // 計算當前角度
    const lAng = calculate3DAngle(lS, lE, lW);
    const rAng = calculate3DAngle(rS, rE, rW);

    // ============ 模式分岐 ============
    
    if (mode === 'CALIBRATING') {
        // 顯示骨架
        drawSkeleton(lm, cw, ch);
        
        // 顯示當前偵測數值
        const displayAngle = (calibration.step === 0) ? lAng : rAng;
        document.getElementById('calib-live-angle').innerText = Math.round(displayAngle);

        if (calibration.isMeasuring) {
            if (calibration.step === 0) {
                if (lAng > calibration.maxLeftAngle) calibration.maxLeftAngle = lAng;
            } else {
                if (rAng > calibration.maxRightAngle) calibration.maxRightAngle = rAng;
            }
        }
    } 
    else if (mode === 'GAME') {
        // 繪製骨架
        drawSkeleton(lm, cw, ch);
        
        // 打擊圈
        const hitR = scale * GAME_CONFIG.hitRadiusRatio;
        const isPunching = (leftState === 1 || rightState === 1);
        ctx.beginPath();
        ctx.strokeStyle = isPunching ? "rgba(255, 255, 255, 0.8)" : "rgba(255, 0, 0, 0.3)";
        ctx.fillStyle = isPunching ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 0, 0, 0.05)";
        ctx.arc(nose.x * cw, nose.y * ch, hitR * cw, 0, 2 * Math.PI);
        ctx.stroke(); ctx.fill();

        // 防禦判定
        const gDist = scale * GAME_CONFIG.guardDistRatio;
        const l_isGuarding = Math.hypot(lW.x - chin.x, lW.y - chin.y) < gDist;
        const r_isGuarding = Math.hypot(rW.x - chin.x, rW.y - chin.y) < gDist;

        if (l_isGuarding) gl.classList.add('active'); else gl.classList.remove('active');
        if (r_isGuarding) gr.classList.add('active'); else gr.classList.remove('active');

        if (lastLeftZ === 0) { lastLeftZ = lS.z - lW.z; lastRightZ = rS.z - rW.z; }

        // 核心邏輯
        const resL = processHand(lS, lE, lW, nose, scale, leftState, leftCooldown, lastLeftZ, r_isGuarding, 'L');
        const resR = processHand(rS, rE, rW, nose, scale, rightState, rightCooldown, lastRightZ, l_isGuarding, 'R');

        leftState = resL.newState; lastLeftZ = resL.currentZ;
        rightState = resR.newState; lastRightZ = resR.currentZ;

        if (resL.hit) hitLogic(true, lW.x, lW.y);
        if (resR.hit) hitLogic(false, rW.x, rW.y);

        if (leftCooldown > 0) leftCooldown--;
        if (rightCooldown > 0) rightCooldown--;
        
        drawDot(lW, l_isGuarding, cw, ch); 
        drawDot(rW, r_isGuarding, cw, ch);
        drawFloatingTexts(cw, ch);
    }

    ctx.restore();
}

function drawSkeleton(lm, cw, ch) {
    ctx.lineWidth = 3; ctx.strokeStyle = "#00ff00"; ctx.lineCap = "round";
    const pts = [11,13,15, 12,14,16, 11,12]; // 簡化骨架
    ctx.beginPath();
    ctx.moveTo(lm[11].x*cw, lm[11].y*ch); ctx.lineTo(lm[13].x*cw, lm[13].y*ch); ctx.lineTo(lm[15].x*cw, lm[15].y*ch);
    ctx.moveTo(lm[12].x*cw, lm[12].y*ch); ctx.lineTo(lm[14].x*cw, lm[14].y*ch); ctx.lineTo(lm[16].x*cw, lm[16].y*ch);
    ctx.moveTo(lm[11].x*cw, lm[11].y*ch); ctx.lineTo(lm[12].x*cw, lm[12].y*ch);
    ctx.stroke();
}

function drawDot(w, active, cw, ch) {
    ctx.beginPath();
    ctx.fillStyle = active ? "#00ff00" : "#d63031";
    ctx.arc(w.x * cw, w.y * ch, 10, 0, 2*Math.PI);
    ctx.fill();
}

function hitLogic(isLeft, x, y) {
    count++;
    countEl.innerText = count;
    countEl.classList.remove('hit-pop'); void countEl.offsetWidth; countEl.classList.add('hit-pop');
    if(isLeft) leftCooldown = GAME_CONFIG.cooldownFrames; else rightCooldown = GAME_CONFIG.cooldownFrames;
    playSound();
    
    // 浮動文字
    if (floatTexts.length > 10) floatTexts.shift();
    floatTexts.push({ x, y, text: "HIT!", color: isLeft ? '#00d2ff' : '#ff9f43', life: 20, vy: -5 });

    board.className = 'score-board';
    if(count >= 50) board.classList.add('tier-2');
    if(count >= 100) board.classList.add('tier-3');
}

function drawFloatingTexts(cw, ch) {
    ctx.scale(-1, 1);
    ctx.font = "900 60px Arial"; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
    for(let i=floatTexts.length-1; i>=0; i--){
        let t = floatTexts[i];
        let rx = -(cw - t.x*cw);
        ctx.fillStyle = t.color;
        ctx.strokeText(t.text, rx, t.y*ch); ctx.fillText(t.text, rx, t.y*ch);
        t.y += t.vy/ch; t.life--;
        if(t.life<=0) floatTexts.splice(i, 1);
    }
}
</script>
</body>
</html>
