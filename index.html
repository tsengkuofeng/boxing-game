<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>XMAS BOXING CHALLENGE - 101跨年 & 教學版</title>
<meta name="description" content="免下載 APP！開啟網頁即可透過鏡頭練習拳擊。支援校正引導、自動錄影與精彩回顧。">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">

<style>
/* =========================================
   【CSS 樣式表】
   ========================================= */
body { 
  font-family: 'Montserrat', sans-serif; 
  text-align: center; margin: 0; overflow: hidden; 
  color: #fff; background: #000;
  overscroll-behavior: none; user-select: none; -webkit-user-select: none;
}
.scene-layer {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
  display: none; flex-direction: column; justify-content: center; align-items: center;
  background: #000; z-index: 10;
}

/* --- Loading --- */
#loading-layer { display: flex; z-index: 100; background: #000; }
.spinner { width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #0f0; border-radius: 50%; animation: spin 1s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

/* --- Landing (Menu) --- */
#landing-layer { 
  background: radial-gradient(circle, #1a1a1a 0%, #000 90%); 
  z-index: 20;
}
h1 { 
  font-size: 3rem; margin: 0 0 10px 0; color: #0f0; text-transform: uppercase; letter-spacing: 2px;
  text-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
}
.subtitle { font-size: 1.2rem; color: #aaa; margin-bottom: 30px; letter-spacing: 1px; }

/* 模式選擇容器 */
.mode-container {
  display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; width: 90%; max-width: 800px;
}
.mode-box {
  border: 2px solid #333; border-radius: 10px; padding: 20px; width: 140px; cursor: pointer;
  background: rgba(255,255,255,0.05); transition: all 0.3s; position: relative; overflow: hidden;
}
.mode-box:hover, .mode-box.selected { border-color: #0f0; background: rgba(0, 255, 0, 0.1); transform: translateY(-5px); }
.mode-box h3 { margin: 0 0 10px 0; color: #fff; font-size: 1.2rem; }
.mode-box p { font-size: 0.8rem; color: #bbb; margin: 0; }

/* 跨年模式特別樣式 */
.mode-box.newyear { border-color: #fbbf24; }
.mode-box.newyear h3 { color: #fbbf24; }
.mode-box.newyear:hover, .mode-box.newyear.selected { 
  border-color: #fbbf24; background: rgba(251, 191, 36, 0.15); 
  box-shadow: 0 0 15px rgba(251, 191, 36, 0.4);
}

/* 教學按鈕 */
.tutorial-btn {
  margin-top: 20px; padding: 10px 30px; border: 1px solid #fff; border-radius: 30px;
  background: transparent; color: #fff; font-size: 1rem; cursor: pointer;
  transition: all 0.3s; display: flex; align-items: center; gap: 8px;
}
.tutorial-btn:hover { background: #fff; color: #000; }

/* 開始按鈕 */
.start-btn {
  margin-top: 30px; padding: 15px 50px; font-size: 1.5rem; font-weight: bold;
  background: #0f0; color: #000; border: none; border-radius: 50px; cursor: pointer;
  box-shadow: 0 0 15px #0f0; transition: transform 0.2s;
  display: none; /* 選了模式才顯示 */
}
.start-btn:active { transform: scale(0.95); }

/* --- Tutorial Overlay (教學視窗) --- */
#tutorial-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.95); z-index: 999; display: none;
  flex-direction: column; align-items: center; justify-content: center;
}
.tutorial-card {
  width: 90%; max-width: 500px; background: #111; border: 1px solid #333;
  border-radius: 15px; padding: 20px; position: relative;
  text-align: center; box-shadow: 0 0 30px rgba(0,255,0,0.1);
}
.tutorial-close {
  position: absolute; top: 10px; right: 15px; font-size: 24px; color: #666; cursor: pointer;
}
.tutorial-slide { display: none; animation: fadeIn 0.3s; }
.tutorial-slide.active { display: block; }
/* 圖片佔位符樣式 */
.tutorial-img-placeholder {
  width: 100%; aspect-ratio: 1/1; background: #222; border-radius: 10px;
  display: flex; align-items: center; justify-content: center;
  color: #555; border: 2px dashed #444; margin-bottom: 15px;
  overflow: hidden;
}
.tutorial-img-placeholder img { width: 100%; height: 100%; object-fit: cover; }

.tutorial-nav { display: flex; justify-content: space-between; margin-top: 20px; }
.nav-btn { background: #333; color: #fff; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; }
.nav-btn:hover { background: #555; }
.step-dots { display: flex; gap: 5px; justify-content: center; margin-top: 15px; }
.dot { width: 8px; height: 8px; background: #444; border-radius: 50%; }
.dot.active { background: #0f0; }

/* --- 跨年特效層 --- */
#newyear-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 4; pointer-events: none; display: none;
}
#fireworks_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
.tower-container {
    position: absolute; bottom: -50px; left: 50%; transform: translateX(-50%);
    width: 200px; height: 60%; opacity: 0.8; transition: transform 0.1s;
    filter: drop-shadow(0 0 20px rgba(0, 210, 255, 0.5));
}
/* 大樓被打到的震動特效 */
.tower-hit {
    animation: towerShake 0.1s infinite;
    filter: drop-shadow(0 0 30px rgba(255, 255, 255, 0.9)) brightness(1.5);
}
@keyframes towerShake {
    0% { transform: translateX(-50%) rotate(0deg); }
    25% { transform: translateX(-52%) rotate(-2deg); }
    75% { transform: translateX(-48%) rotate(2deg); }
    100% { transform: translateX(-50%) rotate(0deg); }
}
#newyear-msg {
    position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%) scale(0);
    font-size: 50px; font-weight: 900; color: #fbbf24; text-align: center;
    text-shadow: 0 0 30px #ff0000; width: 100%; z-index: 20;
    transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
#newyear-msg.show { transform: translate(-50%, -50%) scale(1); }


/* --- Wizard (Calibration) --- */
#wizard-container {
  position: absolute; bottom: 0; left: 0; width: 100%; height: 35%;
  background: linear-gradient(to top, #000 80%, transparent);
  z-index: 30; padding: 20px; box-sizing: border-box;
  display: none; flex-direction: column; align-items: center; justify-content: flex-end;
}
.wizard-step { display: none; width: 100%; max-width: 500px; text-align: center; padding-bottom: 20px; }
.wizard-step.active { display: block; animation: slideUp 0.5s; }
.instruction-text { font-size: 1.2rem; color: #0f0; margin-bottom: 10px; font-weight: bold; }
.sub-text { font-size: 0.9rem; color: #ccc; margin-bottom: 20px; }
.btn-next {
  background: #fff; color: #000; padding: 12px 30px; border: none; border-radius: 25px;
  font-weight: bold; font-size: 1rem; cursor: pointer; box-shadow: 0 0 10px rgba(255,255,255,0.5);
}

/* --- Game HUD --- */
#game-hud { 
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
  z-index: 20; pointer-events: none; display: none;
}
.score-board {
  position: absolute; top: 20px; left: 20px; text-align: left;
}
.score-label { font-size: 1rem; color: #0f0; text-transform: uppercase; }
.score-val { font-size: 3.5rem; font-weight: 900; line-height: 1; text-shadow: 0 0 10px #0f0; }

.timer-board {
  position: absolute; top: 20px; right: 20px; text-align: right;
}
.timer-val { font-size: 3rem; font-weight: 900; color: #fff; }
.health-bar-container {
  position: absolute; top: 80px; right: 20px; width: 150px; height: 10px;
  background: #333; border: 1px solid #555; border-radius: 5px; overflow: hidden; display: none; 
}
.health-fill { width: 100%; height: 100%; background: #0f0; transition: width 0.2s, background 0.2s; }

/* 提示文字 */
#center-msg {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  font-size: 4rem; font-weight: 900; color: #fff; 
  text-shadow: 0 0 20px rgba(255,255,255,0.8); opacity: 0; transition: opacity 0.2s;
}

/* 錄影顯示 */
#rec-indicator {
  position: absolute; bottom: 20px; right: 20px; color: #f00; font-weight: bold; 
  display: flex; align-items: center; gap: 5px; opacity: 0;
}
.rec-dot { width: 10px; height: 10px; background: #f00; border-radius: 50%; animation: blink 1s infinite; }

/* --- Result Layer --- */
#result-layer { background: rgba(0,0,0,0.9); z-index: 50; }
.result-box { width: 90%; max-width: 400px; padding: 20px; border: 1px solid #333; border-radius: 10px; background: #111; }
.result-title { font-size: 2rem; color: #0f0; margin-bottom: 20px; }
.stat-row { display: flex; justify-content: space-between; margin: 10px 0; border-bottom: 1px solid #333; padding-bottom: 5px; }
.action-btns { display: flex; gap: 10px; justify-content: center; margin-top: 20px; flex-wrap: wrap; }
.btn-action { padding: 10px 20px; border: 1px solid #fff; background: transparent; color: #fff; border-radius: 5px; cursor: pointer; }
.btn-action.primary { background: #0f0; color: #000; border: none; }

/* Canvas */
canvas { position: absolute; top: 0; left: 0; transform: scaleX(-1); } /* 鏡像顯示 */
#output_canvas { z-index: 2; } /* 關鍵點繪製層 */
#video_canvas { z-index: 1; background: #000; } /* 影像層 */

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
@keyframes blink { 50% { opacity: 0; } }

/* RWD */
@media (min-width: 768px) {
  h1 { font-size: 4rem; }
  .mode-container { gap: 30px; }
  .mode-box { width: 180px; padding: 30px; }
  .start-btn { font-size: 2rem; padding: 20px 80px; }
}
</style>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loading-layer" class="scene-layer" style="display: flex;">
  <div class="spinner"></div>
  <p style="margin-top:20px; color:#666;">LOADING AI MODEL...</p>
</div>

<div id="landing-layer" class="scene-layer">
  <h1>Boxing AI</h1>
  <div class="subtitle">WEB CAMERA BOXING TRAINER</div>
  
  <div class="mode-container">
    <div class="mode-box" onclick="selectMode('speed', this)">
      <h3>SPEED</h3>
      <p>30秒快拳挑戰</p>
    </div>
    <div class="mode-box" onclick="selectMode('sparring', this)">
      <h3>SPARRING</h3>
      <p>節奏閃避對練</p>
    </div>
    <div class="mode-box newyear" onclick="selectMode('newyear', this)">
      <h3>101 挑戰</h3>
      <p>跨年煙火模式</p>
    </div>
  </div>

  <button class="tutorial-btn" onclick="openTutorial()">
    <span>?</span> 教學導引 / TUTORIAL
  </button>

  <button id="start-btn" class="start-btn" onclick="confirmStart()">START</button>
</div>

<div id="tutorial-overlay">
  <div class="tutorial-card">
    <div class="tutorial-close" onclick="closeTutorial()">×</div>
    
    <div class="tutorial-slide active" data-step="0">
        <h3>基本架式 (Stance)</h3>
        <div class="tutorial-img-placeholder">
            <span>[ 請插入架式圖片 ]<br>1:1 正方形</span>
        </div>
        <p style="font-size:0.9rem; color:#ccc; text-align:left;">
            1. 左腳在前 (12點鐘)，右腳在後 (2點鐘)。<br>
            2. 手肘收緊貼肋骨，雙手護住下巴。<br>
            3. 身體側面站立，減少被擊中面積。
        </p>
    </div>

    <div class="tutorial-slide" data-step="1">
        <h3>刺拳 (Jab)</h3>
        <div class="tutorial-img-placeholder">
            <span>[ 請插入 JAB 圖片 ]</span>
        </div>
        <p style="font-size:0.9rem; color:#ccc; text-align:left;">
            1. 前手 (左手) 快速直線伸出。<br>
            2. 拳頭旋轉，最後一刻拳眼朝上。<br>
            3. 這是最快的拳，用來測距與干擾。
        </p>
    </div>

    <div class="tutorial-slide" data-step="2">
        <h3>直拳 (Cross)</h3>
        <div class="tutorial-img-placeholder">
            <span>[ 請插入 CROSS 圖片 ]</span>
        </div>
        <p style="font-size:0.9rem; color:#ccc; text-align:left;">
            1. 後手 (右手) 重拳出擊。<br>
            2. <strong>轉動後腳與腰部</strong>是力量來源。<br>
            3. 左手要記得拉回護臉。
        </p>
    </div>

    <div class="tutorial-slide" data-step="3">
        <h3>左閃避 (Left Slip)</h3>
        <div class="tutorial-img-placeholder">
            <span>[ 請插入 左閃 圖片 ]</span>
        </div>
        <p style="font-size:0.9rem; color:#ccc; text-align:left;">
            1. 頭部向左前方移動。<br>
            2. 像是把左肩去碰左膝蓋。<br>
            3. 躲避對手的右手直拳。
        </p>
    </div>

    <div class="tutorial-slide" data-step="4">
        <h3>右閃避 (Right Slip)</h3>
        <div class="tutorial-img-placeholder">
            <span>[ 請插入 右閃 圖片 ]</span>
        </div>
        <p style="font-size:0.9rem; color:#ccc; text-align:left;">
            1. 頭部向右前方移動。<br>
            2. 稍微轉腰，將重心壓在右腳。<br>
            3. 躲避對手的左手刺拳。
        </p>
    </div>

    <div class="tutorial-slide" data-step="5">
        <h3>下潛 (Duck / Weave)</h3>
        <div class="tutorial-img-placeholder">
            <span>[ 請插入 下潛 圖片 ]</span>
        </div>
        <p style="font-size:0.9rem; color:#ccc; text-align:left;">
            1. 利用膝蓋彎曲下蹲，不要只彎腰。<br>
            2. 畫一個 "U" 字型移動。<br>
            3. 躲避對手的左右鉤拳。
        </p>
    </div>

    <div class="step-dots">
        <div class="dot active"></div><div class="dot"></div><div class="dot"></div>
        <div class="dot"></div><div class="dot"></div><div class="dot"></div>
    </div>

    <div class="tutorial-nav">
        <button class="nav-btn" onclick="changeSlide(-1)">Prev</button>
        <button class="nav-btn" onclick="changeSlide(1)">Next</button>
    </div>
  </div>
</div>

<div id="wizard-container">
  <div id="step-1" class="wizard-step">
    <div class="instruction-text">STEP 1: 站位確認</div>
    <div class="sub-text">請站在距離鏡頭約 1.5 ~ 2 公尺處，確保全身入鏡。</div>
    <button class="btn-next" onclick="showStep(2)">下一步</button>
  </div>
  <div id="step-2" class="wizard-step">
    <div class="instruction-text">STEP 2: 設定防守高度</div>
    <div class="sub-text">請擺出你的拳擊架式 (手護臉)，然後按設定。</div>
    <button class="btn-next" onclick="calibrateHeight()">設定防守線</button>
  </div>
  <div id="step-3" class="wizard-step">
    <div class="instruction-text">READY!</div>
    <div class="sub-text">校正完成，準備開始。</div>
    <button class="btn-next" onclick="startSparringGame()">開始戰鬥</button>
  </div>
</div>

<div id="game-hud">
  <div class="score-board">
    <div class="score-label">HITS</div>
    <div id="score-val" class="score-val">0</div>
  </div>
  <div class="timer-board">
    <div id="timer-val" class="timer-val">30</div>
  </div>
  <div id="health-bar-container" class="health-bar-container">
    <div id="health-fill" class="health-fill"></div>
  </div>

  <div id="center-msg">FIGHT!</div>
  
  <div id="rec-indicator">
    <div class="rec-dot"></div> REC
  </div>
</div>

<div id="newyear-layer">
    <canvas id="fireworks_canvas"></canvas>
    <div id="taipei-101" class="tower-container">
        <svg viewBox="0 0 100 400" preserveAspectRatio="xMidYMax">
            <path d="M30,400 L30,100 L40,80 L40,60 L48,40 L48,0 L52,0 L52,40 L60,60 L60,80 L70,100 L70,400 Z" fill="#0c4a6e" stroke="#00d2ff" stroke-width="2"/>
            <line x1="30" y1="150" x2="70" y2="150" stroke="#00d2ff" stroke-width="2"/>
            <line x1="30" y1="200" x2="70" y2="200" stroke="#00d2ff" stroke-width="2"/>
            <line x1="30" y1="250" x2="70" y2="250" stroke="#00d2ff" stroke-width="2"/>
            <line x1="30" y1="300" x2="70" y2="300" stroke="#00d2ff" stroke-width="2"/>
            <line x1="30" y1="350" x2="70" y2="350" stroke="#00d2ff" stroke-width="2"/>
        </svg>
    </div>
    <div id="newyear-msg">HAPPY NEW YEAR!</div>
</div>

<div id="result-layer" class="scene-layer">
  <div class="result-box">
    <div class="result-title">GAME OVER</div>
    <div class="stat-row"><span>Total Hits</span><span id="res-hits">0</span></div>
    <div class="stat-row"><span>Avg Speed</span><span id="res-speed">0.0 p/s</span></div>
    <div class="stat-row"><span>Calories</span><span id="res-cal">0 kcal</span></div>
    
    <div class="action-btns">
      <button class="btn-action" onclick="downloadPDF()">下載證書 PDF</button>
      <button class="btn-action primary" onclick="resetGame()">PLAY AGAIN</button>
      <button class="btn-action" onclick="downloadVideo()" id="dl-video-btn" style="display:none;">下載錄影</button>
    </div>
  </div>
</div>

<canvas id="output_canvas"></canvas>
<canvas id="video_canvas"></canvas>

<canvas id="recording_canvas" style="display:none;"></canvas>

<script>
/**
 * 核心邏輯
 */

// 1. DOM Elements
const videoCanvas = document.getElementById('video_canvas');
const videoCtx = videoCanvas.getContext('2d');
const outputCanvas = document.getElementById('output_canvas');
const canvasCtx = outputCanvas.getContext('2d');

const landingLayer = document.getElementById('landing-layer');
const loadingLayer = document.getElementById('loading-layer');
const gameHud = document.getElementById('game-hud');
const resultLayer = document.getElementById('result-layer');
const wizardContainer = document.getElementById('wizard-container');
const startBtn = document.getElementById('start-btn');
const centerMsg = document.getElementById('center-msg');
const healthBar = document.getElementById('health-bar-container');
const healthFill = document.getElementById('health-fill');

const scoreEl = document.getElementById('score-val');
const timerEl = document.getElementById('timer-val');
const resHits = document.getElementById('res-hits');
const resSpeed = document.getElementById('res-speed');
const resCal = document.getElementById('res-cal');
const dlVideoBtn = document.getElementById('dl-video-btn');

// New Year Elements
const newyearLayer = document.getElementById('newyear-layer');
const towerEl = document.getElementById('taipei-101');
const newyearMsg = document.getElementById('newyear-msg');

// Video Element for MediaPipe
const videoElement = document.createElement('video');
videoElement.style.display = "none";
document.body.appendChild(videoElement);

// Game State
let gameState = 'LOADING'; // LOADING, MENU, WIZARD, PLAYING, PAUSED, RESULT
let selectedMode = null;   // 'speed', 'sparring', 'newyear'
let count = 0;
let timeLeft = 30;
let gameTimer = null;
let startTime = 0;
let lastPunchTime = 0;

// Recording
let mediaRecorder;
let recordedChunks = [];
let isRecording = false;
const recordingCanvasElement = document.getElementById('recording_canvas');
const recordingCanvasCtx = recordingCanvasElement.getContext('2d');

// Sparring Logic
let duckYThreshold = 0.4; // Default
let playerHealth = 100;
let activeAttackType = null; // 'JAB', 'HOOK', null
let attackTimer = null;
let attackInterval = 2000;

// Audio Context
let audioCtx = null;
let bgmOscillators = [];
let xmasAudio = new Audio('https://actions.google.com/sounds/v1/science_fiction/scifi_loop.ogg'); // Placeholder BGM
xmasAudio.loop = true; 

// Tutorial Logic
let currentSlideIndex = 0;
const slides = document.querySelectorAll('.tutorial-slide');
const dots = document.querySelectorAll('.dot');

function openTutorial() {
    document.getElementById('tutorial-overlay').style.display = 'flex';
    currentSlideIndex = 0;
    updateSlides();
}
function closeTutorial() {
    document.getElementById('tutorial-overlay').style.display = 'none';
}
function changeSlide(n) {
    currentSlideIndex += n;
    if(currentSlideIndex < 0) currentSlideIndex = slides.length - 1;
    if(currentSlideIndex >= slides.length) currentSlideIndex = 0;
    updateSlides();
}
function updateSlides() {
    slides.forEach((s, i) => {
        s.classList.remove('active');
        if(i === currentSlideIndex) s.classList.add('active');
    });
    dots.forEach((d, i) => {
        d.classList.remove('active');
        if(i === currentSlideIndex) d.classList.add('active');
    });
}


// Init
window.onload = function() {
  initPose();
  initAudio();
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
};

function resizeCanvas() {
  outputCanvas.width = window.innerWidth;
  outputCanvas.height = window.innerHeight;
  videoCanvas.width = window.innerWidth;
  videoCanvas.height = window.innerHeight;
}

function initAudio() {
  try {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
  } catch(e) { console.log('Web Audio API not supported'); }
}

function playSound(type) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  osc.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  if (type === 'punch') {
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
    gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
  } else if (type === 'dodge') {
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, audioCtx.currentTime);
    osc.frequency.linearRampToValueAtTime(900, audioCtx.currentTime + 0.1);
    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
    osc.start(); osc.stop(audioCtx.currentTime + 0.2);
  } else if (type === 'hit') { // Player get hit
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(100, audioCtx.currentTime);
    osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
    gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
    osc.start(); osc.stop(audioCtx.currentTime + 0.3);
  }
}

// Mode Selection
function selectMode(mode, element) {
  selectedMode = mode;
  document.querySelectorAll('.mode-box').forEach(el => {
    el.classList.remove('selected');
  });
  element.classList.add('selected');

  startBtn.style.display = 'block';
  
  // UI Reset
  newyearLayer.style.display = 'none';
  wizardContainer.style.display = 'none';

  if (mode === 'speed') {
    startBtn.innerText = "快拳挑戰 START";
  } else if (mode === 'sparring') {
    startBtn.innerText = "對練校正 START";
    // Sparring needs wizard, handle in confirmStart
  } else if (mode === 'newyear') {
    startBtn.innerText = "挑戰 101 START";
    newyearLayer.style.display = 'block';
  }
}

function confirmStart() {
  if (selectedMode === 'sparring') {
    // Go to Wizard
    landingLayer.style.display = 'none';
    gameState = 'WIZARD';
    wizardContainer.style.display = 'flex';
    showStep(1);
    startCamera();
  } else {
    // Speed or New Year -> Direct Start
    landingLayer.style.display = 'none';
    startCamera();
    startGame();
  }
}

// Wizard Logic
function showStep(n) {
  document.querySelectorAll('.wizard-step').forEach(s => s.classList.remove('active'));
  document.getElementById(`step-${n}`).classList.add('active');
}

let lockedDuckY = null;
function calibrateHeight() {
  // 簡單取當前鼻子高度做基準
  if (lastNoseY) {
    lockedDuckY = lastNoseY + 0.1; // 鼻子再低一點當界線
    showStep(3);
  } else {
    alert("偵測不到人臉，請調整位置");
  }
}

function startSparringGame() {
  wizardContainer.style.display = 'none';
  startGame();
}

// Camera & Pose
function initPose() {
  const pose = new Pose({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
  }});
  pose.setOptions({
    modelComplexity: 1,
    smoothLandmarks: true,
    enableSegmentation: false,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  pose.onResults(onResults);

  window.pose = pose;
  
  const camera = new Camera(videoElement, {
    onFrame: async () => {
      await pose.send({image: videoElement});
    },
    width: 640,
    height: 480
  });
  window.camera = camera;
}

function startCamera() {
  window.camera.start(); 
}

// Game Loop Control
function startGame() {
  gameState = 'PLAYING';
  count = 0;
  scoreEl.innerText = count;
  gameHud.style.display = 'block';
  playerHealth = 100;
  
  // Reset New Year stuff
  newyearMsg.classList.remove('show');
  particles = [];
  
  if (selectedMode === 'sparring') {
    healthBar.style.display = 'block';
    healthFill.style.width = '100%';
    timerEl.style.display = 'none'; // No timer in survival
    startSparringLoop();
  } else if (selectedMode === 'newyear') {
    healthBar.style.display = 'none';
    timerEl.innerText = "101"; // Target
    // No timer countdown, just count up
  } else {
    // Speed mode
    healthBar.style.display = 'none';
    timeLeft = 30;
    timerEl.innerText = timeLeft;
    timerEl.style.display = 'block';
    startTimer();
  }
  
  startRecording();
  
  // Audio
  xmasAudio.play();
  
  showCenterMsg("READY?");
  setTimeout(() => showCenterMsg("GO!"), 1000);
}

function startTimer() {
  gameTimer = setInterval(() => {
    timeLeft--;
    timerEl.innerText = timeLeft;
    if (timeLeft <= 0) {
      endGame();
    }
  }, 1000);
}

// Sparring Enemy Loop
function startSparringLoop() {
  // Random attacks
  const loop = () => {
    if (gameState !== 'PLAYING') return;
    
    // Random delay 1.5 ~ 3s
    const delay = 1500 + Math.random() * 1500;
    
    activeAttackType = Math.random() > 0.5 ? 'JAB' : 'HOOK'; // Simplified types
    // UI Warning
    showCenterMsg(activeAttackType === 'JAB' ? "DODGE SIDE!" : "DUCK!");
    
    // Check hit after 0.8s
    setTimeout(() => {
      if (gameState !== 'PLAYING') return;
      checkPlayerDodge(activeAttackType);
      activeAttackType = null;
      loop(); // Next attack
    }, 800);
  };
  setTimeout(loop, 2000);
}

function checkPlayerDodge(type) {
  // Simple Logic:
  // Hook -> needs to be below threshold
  // Jab -> needs to be Left or Right (Head X movement)
  
  let hit = false;
  if (!lastNoseY || !lastNoseX) return;
  
  if (type === 'HOOK') {
     // Check Y
     if (lockedDuckY && lastNoseY < lockedDuckY) {
         hit = true; // Still standing high
     }
  } else if (type === 'JAB') {
     // Check X (Center is roughly 0.5)
     if (lastNoseX > 0.4 && lastNoseX < 0.6) {
         hit = true; // Still in center
     }
  }
  
  if (hit) {
    playerHealth -= 20;
    healthFill.style.width = playerHealth + '%';
    playSound('hit');
    showCenterMsg("HIT!");
    videoCanvas.style.filter = "sepia(1) hue-rotate(-50deg) saturate(5)"; // Red flash
    setTimeout(() => videoCanvas.style.filter = "none", 200);
    
    if (playerHealth <= 0) endGame();
  } else {
    playSound('dodge');
    // Bonus points for dodge?
  }
}

function endGame() {
  gameState = 'RESULT';
  clearInterval(gameTimer);
  stopRecording();
  
  gameHud.style.display = 'none';
  resultLayer.style.display = 'flex';
  
  resHits.innerText = count;
  let duration = 30; // approx
  if (selectedMode === 'speed') duration = 30;
  
  resSpeed.innerText = (count / duration).toFixed(1) + " p/s";
  resCal.innerText = (count * 0.5).toFixed(1) + " kcal";
  
  xmasAudio.pause();
  xmasAudio.currentTime = 0;
}

function resetGame() {
  resultLayer.style.display = 'none';
  landingLayer.style.display = 'flex';
  loadingLayer.style.display = 'none';
  
  // Clear canvas
  canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
}

// Recording Functions
function startRecording() {
  recordedChunks = [];
  const stream = recordingCanvasElement.captureStream(30);
  mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
  mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
  mediaRecorder.start();
  isRecording = true;
  document.getElementById('rec-indicator').style.opacity = 1;
}
function stopRecording(keepData = true) {
  if (isRecording && mediaRecorder) {
    mediaRecorder.stop();
    isRecording = false;
    document.getElementById('rec-indicator').style.opacity = 0;
    if (keepData) {
       setTimeout(() => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          dlVideoBtn.onclick = () => {
             const a = document.createElement('a'); a.href = url; a.download = 'boxing_highlight.webm'; a.click();
          };
          dlVideoBtn.style.display = 'block';
       }, 500);
    }
  }
}
function downloadVideo() { /* handled in stopRecording */ }
function downloadPDF() {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  doc.text("Boxing Challenge Certificate", 10, 10);
  doc.text(`Total Hits: ${count}`, 10, 30);
  doc.text(`Date: ${new Date().toLocaleDateString()}`, 10, 40);
  doc.save("boxing-result.pdf");
}

function showCenterMsg(text) {
  centerMsg.innerText = text;
  centerMsg.style.opacity = 1;
  centerMsg.style.transform = "translate(-50%, -50%) scale(1.5)";
  setTimeout(() => {
    centerMsg.style.opacity = 0;
    centerMsg.style.transform = "translate(-50%, -50%) scale(1)";
  }, 800);
}

// ============================================
//   MediaPipe & Game Logic
// ============================================

let lastNoseX = 0.5;
let lastNoseY = 0.5;
let leftWrist = null;
let rightWrist = null;
let leftState = 'RETRACT'; // RETRACT, EXTEND
let rightState = 'RETRACT';

function onResults(results) {
  // Draw Video
  videoCtx.save();
  videoCtx.translate(videoCanvas.width, 0);
  videoCtx.scale(-1, 1);
  videoCtx.drawImage(results.image, 0, 0, videoCanvas.width, videoCanvas.height);
  videoCtx.restore();
  
  // Game Logic
  if (gameState === 'PLAYING' || gameState === 'WIZARD') {
    canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
    
    if (results.poseLandmarks) {
      // Draw Skeleton
      drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
      drawLandmarks(canvasCtx, results.poseLandmarks, {color: '#FF0000', lineWidth: 1});
      
      const landmarks = results.poseLandmarks;
      lastNoseX = landmarks[0].x;
      lastNoseY = landmarks[0].y;
      
      processHand(landmarks[15], 'left');  // Left Wrist
      processHand(landmarks[16], 'right'); // Right Wrist
      
      // New Year Fireworks Update
      if (selectedMode === 'newyear' && gameState === 'RESULT') {
         // loopFireworks is called separately, but we need to ensure canvas is clear/drawing
      }
    }
  }
  
  // Recording Canvas Update
  if (isRecording) {
      // Draw Video + HUD onto recording canvas
      recordingCanvasElement.width = videoCanvas.width;
      recordingCanvasElement.height = videoCanvas.height;
      recordingCanvasCtx.drawImage(videoCanvas, 0, 0);
      // Draw Skeleton overlay
      recordingCanvasCtx.drawImage(outputCanvas, 0, 0);
      // Draw 101 Tower if mode is newyear
      if (selectedMode === 'newyear') {
         // This is hard to draw DOM onto canvas, simple workaround: draw text
         recordingCanvasCtx.font = "30px Arial";
         recordingCanvasCtx.fillStyle = "gold";
         recordingCanvasCtx.fillText("101 CHALLENGE", 50, 50);
      }
  }
}

function processHand(wrist, side) {
  // Simple Punch Detection based on velocity or extension (Z-depth or X-extension)
  // Simplified for this demo: Check if wrist is far from shoulder? 
  // For webcams without depth, we often use acceleration or simply 'reach'.
  
  // Using a state machine: Retracted -> Extended -> Retracted
  // Trigger punch on Extended
  
  // Assume camera width mapped 0-1.
  // Punch = wrist moving fast or reaching specific zone?
  // Let's use a simplified "Pass the line" logic.
  
  // In a real app, calculate velocity. Here: random simulation of detection for robustness
  // We use a threshold relative to nose or shoulder.
  
  // Let's assume user punches forward -> wrist gets larger (Z) or moves side.
  // Implementing a basic velocity check:
  
  // (Detect Logic Placeholder - assuming correct punch for demo)
  // Let's just track if wrist Y is high enough and moves forward
  
  // *** 簡易判定：手腕超過肩膀一定距離 ***
  // 這裡為了體驗順暢，我們假設判定成功 (你需要根據真實手感調整閾值)
  
  // Pseudo-logic:
  // If wrist.y < nose.y (punch high) and wrist.visibility > 0.5
  
  if (wrist.visibility > 0.5) {
     // Check extension status...
     // Since we don't have previous frames stored easily here, let's use a "Zone"
     // If wrist is very close to edge of screen (extended)
     
     // 為了讓此代碼立刻可用，我們加入一個簡易觸發：
     // 當手腕 X 座標改變很大時觸發
     
     let state = (side === 'left') ? leftState : rightState;
     let isPunch = false;
     
     // Detect extension
     if (state === 'RETRACT') {
        // If hand moves far from center (0.5)
        if (Math.abs(wrist.x - 0.5) > 0.3) {
            state = 'EXTEND';
            isPunch = true;
        }
     } else {
        // Must return to center
        if (Math.abs(wrist.x - 0.5) < 0.2) {
            state = 'RETRACT';
        }
     }
     
     if (side === 'left') leftState = state;
     else rightState = state;
     
     if (isPunch) {
         count++;
         scoreEl.innerText = count;
         playSound('punch');
         
         // 101 Mode Logic
         if (selectedMode === 'newyear') {
             triggerTowerShake();
             if (count >= 101) {
                 triggerNewYearCelebration();
             }
         }
     }
  }
}

// 101 Logic
function triggerTowerShake() {
    towerEl.classList.remove('tower-hit');
    void towerEl.offsetWidth;
    towerEl.classList.add('tower-hit');
}

// Fireworks
let particles = [];
let fireworkLoopId = null;

function triggerNewYearCelebration() {
    if (gameState === 'RESULT') return;
    gameState = 'RESULT';
    stopRecording(true);
    
    newyearMsg.classList.add('show');
    
    // Play win sound
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.5);
    osc.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + 1);
    
    loopFireworks();
}

function loopFireworks() {
    const ctx = document.getElementById('fireworks_canvas').getContext('2d');
    const fwCanvas = document.getElementById('fireworks_canvas');
    fwCanvas.width = window.innerWidth;
    fwCanvas.height = window.innerHeight;
    
    ctx.clearRect(0, 0, fwCanvas.width, fwCanvas.height);
    
    // Launch random
    if (Math.random() < 0.1) {
        createParticles(Math.random() * fwCanvas.width, Math.random() * fwCanvas.height / 2);
    }
    
    // Update
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1; 
        p.alpha -= 0.02;
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${p.hue}, 100%, 50%, ${p.alpha})`;
        ctx.fill();
        
        if (p.alpha <= 0) particles.splice(i, 1);
    }
    
    fireworkLoopId = requestAnimationFrame(loopFireworks);
}

function createParticles(x, y) {
    for (let i = 0; i < 30; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            alpha: 1,
            hue: Math.random() * 360
        });
    }
}

</script>
</body>
</html>
