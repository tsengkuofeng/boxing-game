<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V23 聖誕防禦記憶版</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* 全局設定 */
    body { font-family: 'Segoe UI', monospace; margin: 0; overflow: hidden; background: #000; color: white; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; opacity: 0; transition: opacity 1s; }
    video { display: none; }

    /* ==================== */
    /* Phase 1: 聖誕夜空   */
    /* ==================== */
    #scene-intro {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
        background: linear-gradient(to bottom, #000011, #0a0a2a);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: opacity 1s;
    }

    /* 月亮 */
    .moon {
        position: absolute; top: 10%; right: 15%;
        width: 100px; height: 100px; background: #fff; border-radius: 50%;
        box-shadow: 0 0 40px #fff, 0 0 80px #ffffcc;
        animation: glow 3s infinite alternate;
    }
    @keyframes glow { from { box-shadow: 0 0 40px #fff; } to { box-shadow: 0 0 60px #fff, 0 0 100px #ffffcc; } }

    /* 雪花 */
    .snowflake {
        position: absolute; top: -10px; color: #fff; font-size: 1em; opacity: 0.8;
        animation: fall linear infinite;
    }
    @keyframes fall { to { transform: translateY(110vh); } }

    /* 標題與按鈕 */
    .intro-box { z-index: 10; text-align: center; }
    h1 { font-size: 60px; text-shadow: 0 0 20px #00d2ff; margin-bottom: 20px; }
    p { font-size: 18px; color: #ccc; margin-bottom: 40px; }
    
    .btn-main {
        padding: 15px 50px; font-size: 24px; border: none; border-radius: 50px;
        background: #e17055; color: white; cursor: pointer; font-weight: bold;
        box-shadow: 0 0 20px rgba(225, 112, 85, 0.6); transition: transform 0.2s;
    }
    .btn-main:hover { transform: scale(1.1); background: #fab1a0; }

    /* ==================== */
    /* Phase 2: 校正畫面   */
    /* ==================== */
    #scene-calibration {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 90;
        background: rgba(0,0,0,0.85); display: none;
        flex-direction: column; align-items: center; justify-content: center;
        text-align: center;
    }
    .calib-step { font-size: 36px; margin-bottom: 20px; color: #00d2ff; font-weight: bold; }
    .calib-instr { font-size: 20px; color: #ddd; margin-bottom: 40px; max-width: 600px; line-height: 1.5; }
    .calib-data { font-family: monospace; font-size: 20px; color: #fab1a0; margin-bottom: 30px; border: 1px solid #555; padding: 15px; border-radius: 10px; background: rgba(0,0,0,0.5); }
    
    /* ==================== */
    /* Phase 3: 遊戲介面   */
    /* ==================== */
    #scene-game { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; display: none; }

    /* Debug 儀表板 */
    .debug-panel {
        position: absolute; top: 20px; left: 20px;
        background: rgba(0, 0, 0, 0.8); border: 1px solid #666;
        padding: 15px; border-radius: 10px; text-align: left;
        color: #fff; font-size: 12px; width: 240px; pointer-events: auto;
    }
    .debug-header { border-bottom: 1px solid #555; margin-bottom: 5px; color: #aaa; font-size: 11px; display:flex; justify-content:space-between;}
    .debug-row { display: flex; justify-content: space-between; margin-bottom: 3px; }
    .val { font-weight: bold; font-family: monospace; }
    .pass { color: #00ff00; } 
    .fail { color: #ff5555; } /* 失敗改為亮紅 */
    .locked { color: #888; }
    .status-reason { font-size: 10px; text-align: right; color: #fab1a0; height: 14px; margin-bottom: 5px;}

    /* 計分板 */
    .score-container { 
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center;
    }
    .score-board { 
        padding: 10px 50px; border-radius: 20px; text-align: center; 
        background: rgba(0, 0, 0, 0.6); border: 3px solid #555; 
    }
    #count { font-size: 110px; font-weight: 900; line-height: 1; color: #fff; }
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; }

    /* 防禦燈 */
    .guard-status { margin-top: 10px; display: flex; gap: 15px; }
    .guard-item { display: flex; align-items: center; gap: 5px; color: #555; font-weight: bold; font-size: 12px; }
    .guard-item.active { color: #00ff00; }
    .g-dot { width: 10px; height: 10px; border-radius: 50%; background: #333; border: 1px solid #555; }
    .guard-item.active .g-dot { background: #00ff00; box-shadow: 0 0 8px #00ff00; }

    /* 打擊特效 */
    .hit-pop { animation: pop 0.1s ease-out; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }
    .score-board.tier-1 { border-color: #00d2ff; box-shadow: 0 0 20px #00d2ff; }
    .score-board.tier-2 { border-color: #ffd700; box-shadow: 0 0 30px #ffd700; }
    .score-board.tier-3 { border-color: #ff4500; box-shadow: 0 0 40px #ff4500; }
</style>
</head>
<body>

<video id="input_video" playsinline></video>
<canvas id="output_canvas"></canvas>

<div id="scene-intro">
    <div class="moon"></div>
    <div id="snow-container"></div>
    <div class="intro-box">
        <h1>XMAS BOXING</h1>
        <p>V23 防禦記憶版 - 嚴謹判定、寬容時機</p>
        <button class="btn-main" onclick="startCalibrationFlow()">我準備好了!</button>
    </div>
</div>

<div id="scene-calibration">
    <div id="calib-step-text" class="calib-step">步驟 1/2</div>
    <div id="calib-instr-text" class="calib-instr">
        請對著鏡頭打出最標準的<b>左直拳</b>並定住不動。<br>
        系統將會偵測你的極限角度與深度。
    </div>
    <div class="calib-data">
        Angle: <span id="calib-live-angle">0</span>° <br>
        Z-Depth: <span id="calib-live-z">0.00</span>
    </div>
    <button id="calib-btn" class="btn-main" onclick="runCalibrationStep()">開始偵測 (3秒)</button>
</div>

<div id="scene-game" class="ui-layer">
    <div class="debug-panel">
        <div class="debug-header">LEFT ARM <span>Target: ><span id="limit-la">0</span>° / ><span id="limit-lz">0</span></span></div>
        <div class="debug-row"><span>Depth:</span> <span id="val-lz" class="val">0.00</span></div>
        <div class="debug-row"><span>Angle:</span> <span id="val-la" class="val">0°</span></div>
        <div class="debug-row"><span>Guard(Mem):</span> <span id="val-lg" class="val">NO</span></div>
        <div class="status-reason" id="reason-l">WAITING...</div>
        
        <div class="debug-header" style="margin-top:10px;">RIGHT ARM <span>Target: ><span id="limit-ra">0</span>° / ><span id="limit-rz">0</span></span></div>
        <div class="debug-row"><span>Depth:</span> <span id="val-rz" class="val">0.00</span></div>
        <div class="debug-row"><span>Angle:</span> <span id="val-ra" class="val">0°</span></div>
        <div class="debug-row"><span>Guard(Mem):</span> <span id="val-rg" class="val">NO</span></div>
        <div class="status-reason" id="reason-r">WAITING...</div>
    </div>

    <div class="score-container">
        <div class="score-board" id="score-board">
            <div class="count-label">COMBO</div>
            <div id="count">0</div>
        </div>
        <div class="guard-status">
            <div id="g-left" class="guard-item"><div class="g-dot"></div> L-GUARD</div>
            <div id="g-right" class="guard-item"><div class="g-dot"></div> R-GUARD</div>
        </div>
    </div>
</div>

<script>
// --- 0. 聖誕雪花 ---
function createSnow() {
    const container = document.getElementById('snow-container');
    for (let i = 0; i < 50; i++) {
        const d = document.createElement('div');
        d.className = 'snowflake';
        d.innerHTML = '❄';
        d.style.left = Math.random() * 100 + 'vw';
        d.style.animationDuration = (Math.random() * 3 + 2) + 's';
        d.style.fontSize = (Math.random() * 10 + 10) + 'px';
        container.appendChild(d);
    }
}
createSnow();

// --- 1. 全局變數 ---
let mode = 'INTRO';
let count = 0;
let leftState = 0, rightState = 0;
let leftCooldown = 0, rightCooldown = 0;
let floatTexts = [];
let lastLeftZ = 0, lastRightZ = 0;

// 防禦記憶 (關鍵修改)
let leftGuardTime = 0;
let rightGuardTime = 0;
const GUARD_MEMORY_MS = 300; // 防禦狀態可以維持 300ms (緩衝期)

// 校正數據
let calibration = {
    step: 0, 
    maxLeftAngle: 0, maxRightAngle: 0,
    maxLeftZ: 0, maxRightZ: 0,
    isMeasuring: false
};

// 遊戲參數
let GAME_CONFIG = {
    triggerZ_L: 0.20, // 分開儲存左右手的深度
    triggerZ_R: 0.20,
    minSpeed: 0.03,
    
    triggerAngle_L: 125,
    triggerAngle_R: 125,

    resetZ: 0.25,
    resetAngle: 90, // 重置寬鬆一點
    hitRadiusRatio: 0.75,
    guardDistRatio: 0.80, // 加大防禦偵測圈 (讓防禦更容易判定)
    cooldownFrames: 2
};

// DOM
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const video = document.getElementById('input_video');
const countEl = document.getElementById('count');
const board = document.getElementById('score-board');
const gl = document.getElementById('g-left');
const gr = document.getElementById('g-right');

// 音效
const PUNCH_SOUND_URL = 'punch.mp3'; 
let audioContext, punchBuffer;
async function loadSound() {
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        const res = await fetch(PUNCH_SOUND_URL);
        const buf = await res.arrayBuffer();
        punchBuffer = await audioContext.decodeAudioData(buf);
    } catch(e) {}
}
function playSound() {
    if (!audioContext || !punchBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const src = audioContext.createBufferSource();
    src.buffer = punchBuffer;
    src.connect(audioContext.destination);
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    src.start(0);
}

// --- 2. 流程與校正 ---

async function startCalibrationFlow() {
    await loadSound();
    document.getElementById('scene-intro').style.opacity = 0;
    setTimeout(() => { document.getElementById('scene-intro').style.display = 'none'; }, 1000);
    document.getElementById('scene-calibration').style.display = 'flex';
    
    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    pose.onResults(onResults);
    
    const camera = new Camera(video, { onFrame: async () => { await pose.send({image: video}); }, width: 1280, height: 720 });
    await camera.start();
    mode = 'CALIBRATING';
    canvas.style.opacity = 0.3;
}

function runCalibrationStep() {
    const btn = document.getElementById('calib-btn');
    calibration.isMeasuring = true;
    let timeLeft = 3;
    btn.disabled = true;
    
    const timer = setInterval(() => {
        btn.innerText = `偵測中... ${timeLeft}`;
        timeLeft--;
        if (timeLeft < 0) {
            clearInterval(timer);
            calibration.isMeasuring = false;
            
            if (calibration.step === 0) {
                playSound();
                calibration.step = 1;
                document.getElementById('calib-step-text').innerText = "步驟 2/2";
                document.getElementById('calib-instr-text').innerHTML = "左手已紀錄。<br>現在請打出最標準的<b>右直拳</b>並定住。";
                btn.innerText = "開始偵測 (3秒)";
                btn.disabled = false;
            } else {
                playSound();
                finishCalibration();
            }
        }
    }, 1000);
}

function finishCalibration() {
    // === V23 核心：智慧門檻設定 ===
    // 1. 角度：取校正值的 85% 或 減 25度，且 強制上限為 135度 (避免太難)
    // 2. 深度：取校正值的 70% (避免太遠打不到)

    GAME_CONFIG.triggerAngle_L = Math.min(Math.max(100, calibration.maxLeftAngle - 25), 135);
    GAME_CONFIG.triggerAngle_R = Math.min(Math.max(100, calibration.maxRightAngle - 25), 135);

    // 深度的最低底線是 0.15，最高不超過校正值
    GAME_CONFIG.triggerZ_L = Math.max(0.15, calibration.maxLeftZ * 0.7);
    GAME_CONFIG.triggerZ_R = Math.max(0.15, calibration.maxRightZ * 0.7);
    
    console.log("Calib Config:", GAME_CONFIG);

    document.getElementById('scene-calibration').style.display = 'none';
    document.getElementById('scene-game').style.display = 'block';
    canvas.style.opacity = 1;
    
    // 更新 UI 顯示目標值
    document.getElementById('limit-la').innerText = Math.round(GAME_CONFIG.triggerAngle_L);
    document.getElementById('limit-lz').innerText = GAME_CONFIG.triggerZ_L.toFixed(2);
    document.getElementById('limit-ra').innerText = Math.round(GAME_CONFIG.triggerAngle_R);
    document.getElementById('limit-rz').innerText = GAME_CONFIG.triggerZ_R.toFixed(2);
    
    mode = 'GAME';
}

function calculate3DAngle(a, b, c) {
    const v1 = { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
    const v2 = { x: c.x - b.x, y: c.y - b.y, z: c.z - b.z };
    const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
    const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);
    return Math.acos(dot / (mag1 * mag2)) * (180.0 / Math.PI);
}

// 判斷邏輯
function processHand(shoulder, elbow, wrist, nose, scale, state, cooldown, lastZ, oppGuardLastTime, label) {
    let newState = state;
    let hit = false;
    
    const currentZ = shoulder.z - wrist.z;
    const velocity = currentZ - lastZ;
    const armAngle = calculate3DAngle(shoulder, elbow, wrist);
    const distToNose = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
    const inHitZone = distToNose < (scale * GAME_CONFIG.hitRadiusRatio);
    const isLeft = (label === 'L');
    
    const trigAngle = isLeft ? GAME_CONFIG.triggerAngle_L : GAME_CONFIG.triggerAngle_R;
    const trigZ = isLeft ? GAME_CONFIG.triggerZ_L : GAME_CONFIG.triggerZ_R;

    // 檢查防禦記憶 (如果現在時間 - 上次防禦時間 < 300ms，就算有防禦)
    const now = Date.now();
    const isGuarded = (now - oppGuardLastTime) < GUARD_MEMORY_MS;

    // Debug Update
    const prefix = isLeft ? 'l' : 'r';
    const elZ = document.getElementById(`val-${prefix}z`);
    const elA = document.getElementById(`val-${prefix}a`);
    const elG = document.getElementById(`val-${prefix}g`);
    const elReason = document.getElementById(`reason-${prefix}`);

    let reason = "";

    if (state === 0) { // Ready
        // 判定條件
        const passZ = currentZ > trigZ;
        const passAngle = armAngle > trigAngle;
        const passSpeed = velocity > GAME_CONFIG.minSpeed;
        const passGuard = isGuarded;
        const passZone = inHitZone;

        if (passZ && passAngle && passSpeed && passGuard && passZone && cooldown <= 0) {
            newState = 1;
            hit = true;
            reason = "HIT!";
        } else {
            // 診斷失敗原因 (優先順序)
            if (passZone && passSpeed) {
                if (!passGuard) reason = "FAIL: NO GUARD";
                else if (!passAngle) reason = "FAIL: ANGLE TOO LOW";
                else if (!passZ) reason = "FAIL: NOT DEEP ENOUGH";
            } else {
                reason = "READY";
            }
        }

        // UI 顏色更新
        if (elZ) {
            elZ.innerText = currentZ.toFixed(2);
            elA.innerText = Math.round(armAngle) + "°";
            elG.innerText = isGuarded ? "YES" : "NO";
            elReason.innerText = reason;
            
            elZ.className = passZ ? "val pass" : "val fail";
            elA.className = passAngle ? "val pass" : "val fail";
            elG.className = passGuard ? "val pass" : "val fail";
            
            if (hit) elReason.style.color = "#00ff00";
            else if (reason.startsWith("FAIL")) elReason.style.color = "#ff5555";
            else elReason.style.color = "#aaa";
        }
    } 
    else if (state === 1) { newState = 2; } 
    else if (state === 2) { 
        if (currentZ < GAME_CONFIG.resetZ || armAngle < GAME_CONFIG.resetAngle) {
            newState = 0; 
        }
        if(elReason) elReason.innerText = "RETRACTING";
    }

    return { newState, hit, currentZ };
}

function onResults(results) {
    if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }
    const cw = canvas.width, ch = canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, cw, ch);
    ctx.globalAlpha = (mode === 'CALIBRATING') ? 0.5 : 1.0;
    ctx.drawImage(results.image, 0, 0, cw, ch);
    ctx.globalAlpha = 1.0;

    if (!results.poseLandmarks) { ctx.restore(); return; }
    
    const lm = results.poseLandmarks;
    const nose = lm[0];
    const lS = lm[11], lE = lm[13], lW = lm[15];
    const rS = lm[12], rE = lm[14], rW = lm[16];
    const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

    if (!nose || !lS || !rS) { ctx.restore(); return; }
    const scale = Math.hypot(lS.x - rS.x, lS.y - rS.y) * 2.5;
    
    const lAng = calculate3DAngle(lS, lE, lW);
    const rAng = calculate3DAngle(rS, rE, rW);
    const lZ = lS.z - lW.z;
    const rZ = rS.z - rW.z;

    // === 校正模式 ===
    if (mode === 'CALIBRATING') {
        drawSkeleton(lm, cw, ch);
        const isLeft = (calibration.step === 0);
        document.getElementById('calib-live-angle').innerText = Math.round(isLeft ? lAng : rAng);
        document.getElementById('calib-live-z').innerText = (isLeft ? lZ : rZ).toFixed(2);

        if (calibration.isMeasuring) {
            if (isLeft) {
                if (lAng > calibration.maxLeftAngle) calibration.maxLeftAngle = lAng;
                if (lZ > calibration.maxLeftZ) calibration.maxLeftZ = lZ;
            } else {
                if (rAng > calibration.maxRightAngle) calibration.maxRightAngle = rAng;
                if (rZ > calibration.maxRightZ) calibration.maxRightZ = rZ;
            }
        }
    } 
    // === 遊戲模式 ===
    else if (mode === 'GAME') {
        drawSkeleton(lm, cw, ch);
        
        const hitR = scale * GAME_CONFIG.hitRadiusRatio;
        const isPunching = (leftState === 1 || rightState === 1);
        ctx.beginPath();
        ctx.strokeStyle = isPunching ? "rgba(255, 255, 255, 0.8)" : "rgba(255, 0, 0, 0.3)";
        ctx.fillStyle = isPunching ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 0, 0, 0.05)";
        ctx.arc(nose.x * cw, nose.y * ch, hitR * cw, 0, 2 * Math.PI);
        ctx.stroke(); ctx.fill();

        // 判定防禦 (更新 Timestamp)
        const gDist = scale * GAME_CONFIG.guardDistRatio;
        const now = Date.now();
        if (Math.hypot(lW.x - chin.x, lW.y - chin.y) < gDist) leftGuardTime = now;
        if (Math.hypot(rW.x - chin.x, rW.y - chin.y) < gDist) rightGuardTime = now;

        // UI 顯示是否在防禦中 (包含記憶時間)
        const l_active = (now - leftGuardTime) < GUARD_MEMORY_MS;
        const r_active = (now - rightGuardTime) < GUARD_MEMORY_MS;
        
        if (l_active) gl.classList.add('active'); else gl.classList.remove('active');
        if (r_active) gr.classList.add('active'); else gr.classList.remove('active');

        if (lastLeftZ === 0) { lastLeftZ = lZ; lastRightZ = rZ; }

        // 左手出拳時，檢查右手防禦時間 (rightGuardTime)
        const resL = processHand(lS, lE, lW, nose, scale, leftState, leftCooldown, lastLeftZ, rightGuardTime, 'L');
        // 右手出拳時，檢查左手防禦時間 (leftGuardTime)
        const resR = processHand(rS, rE, rW, nose, scale, rightState, rightCooldown, lastRightZ, leftGuardTime, 'R');

        leftState = resL.newState; lastLeftZ = resL.currentZ;
        rightState = resR.newState; lastRightZ = resR.currentZ;

        if (resL.hit) hitLogic(true, lW.x, lW.y);
        if (resR.hit) hitLogic(false, rW.x, rW.y);

        if (leftCooldown > 0) leftCooldown--;
        if (rightCooldown > 0) rightCooldown--;
        
        drawDot(lW, l_active, cw, ch); 
        drawDot(rW, r_active, cw, ch);
        drawFloatingTexts(cw, ch);
    }
    ctx.restore();
}

function drawSkeleton(lm, cw, ch) {
    ctx.lineWidth = 3; ctx.strokeStyle = "#00ff00"; ctx.lineCap = "round";
    const pts = [11,13,15, 12,14,16]; 
    ctx.beginPath();
    ctx.moveTo(lm[11].x*cw, lm[11].y*ch); ctx.lineTo(lm[13].x*cw, lm[13].y*ch); ctx.lineTo(lm[15].x*cw, lm[15].y*ch);
    ctx.moveTo(lm[12].x*cw, lm[12].y*ch); ctx.lineTo(lm[14].x*cw, lm[14].y*ch); ctx.lineTo(lm[16].x*cw, lm[16].y*ch);
    ctx.stroke();
}

function drawDot(w, active, cw, ch) {
    ctx.beginPath();
    ctx.fillStyle = active ? "#00ff00" : "#d63031";
    ctx.arc(w.x * cw, w.y * ch, 10, 0, 2*Math.PI);
    ctx.fill();
}

function hitLogic(isLeft, x, y) {
    count++;
    countEl.innerText = count;
    countEl.classList.remove('hit-pop'); void countEl.offsetWidth; countEl.classList.add('hit-pop');
    if(isLeft) leftCooldown = GAME_CONFIG.cooldownFrames; else rightCooldown = GAME_CONFIG.cooldownFrames;
    playSound();
    
    if (floatTexts.length > 10) floatTexts.shift();
    floatTexts.push({ x, y, text: "HIT!", color: isLeft ? '#00d2ff' : '#ff9f43', life: 20, vy: -5 });

    board.className = 'score-board';
    if(count >= 50) board.classList.add('tier-2');
    if(count >= 100) board.classList.add('tier-3');
}

function drawFloatingTexts(cw, ch) {
    ctx.scale(-1, 1);
    ctx.font = "900 60px Arial"; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
    for(let i=floatTexts.length-1; i>=0; i--){
        let t = floatTexts[i];
        let rx = -(cw - t.x*cw);
        ctx.fillStyle = t.color;
        ctx.strokeText(t.text, rx, t.y*ch); ctx.fillText(t.text, rx, t.y*ch);
        t.y += t.vy/ch; t.life--;
        if(t.life<=0) floatTexts.splice(i, 1);
    }
}
</script>
</body>
</html>
