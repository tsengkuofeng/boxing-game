<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V25 æš´æ¼²æ‹³é ­ç‰ˆ</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* å…¨å±€è¨­å®š */
    body { font-family: 'Segoe UI', monospace; margin: 0; overflow: hidden; background: #000; color: white; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; opacity: 0; transition: opacity 1s; }
    video { display: none; }

    /* ==================== */
    /* Phase 1: è–èª•å¤œç©º   */
    /* ==================== */
    #scene-intro {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
        background: linear-gradient(to bottom, #000011, #0a0a2a);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: opacity 1s;
    }
    .moon {
        position: absolute; top: 10%; right: 15%;
        width: 100px; height: 100px; background: #fff; border-radius: 50%;
        box-shadow: 0 0 40px #fff, 0 0 80px #ffffcc;
        animation: glow 3s infinite alternate;
    }
    @keyframes glow { from { box-shadow: 0 0 40px #fff; } to { box-shadow: 0 0 60px #fff, 0 0 100px #ffffcc; } }
    .snowflake {
        position: absolute; top: -10px; color: #fff; font-size: 1em; opacity: 0.8;
        animation: fall linear infinite;
    }
    @keyframes fall { to { transform: translateY(110vh); } }
    
    .intro-box { z-index: 10; text-align: center; }
    h1 { font-size: 60px; text-shadow: 0 0 20px #00d2ff; margin-bottom: 20px; }
    p { font-size: 18px; color: #ccc; margin-bottom: 40px; }
    
    .btn-main {
        padding: 15px 50px; font-size: 24px; border: none; border-radius: 50px;
        background: #e17055; color: white; cursor: pointer; font-weight: bold;
        box-shadow: 0 0 20px rgba(225, 112, 85, 0.6); transition: transform 0.2s;
    }
    .btn-main:hover { transform: scale(1.1); background: #fab1a0; }

    /* ==================== */
    /* Phase 2: æ ¡æ­£ç•«é¢   */
    /* ==================== */
    #scene-calibration {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 90;
        background: rgba(0,0,0,0.85); display: none;
        flex-direction: column; align-items: center; justify-content: center;
        text-align: center;
    }
    .calib-step { font-size: 36px; margin-bottom: 20px; color: #00d2ff; font-weight: bold; }
    .calib-instr { font-size: 20px; color: #ddd; margin-bottom: 40px; max-width: 600px; line-height: 1.5; }
    .calib-data { font-family: monospace; font-size: 24px; color: #fab1a0; margin-bottom: 30px; border: 1px solid #555; padding: 15px; border-radius: 10px; background: rgba(0,0,0,0.5); }

    /* ==================== */
    /* Phase 3: éŠæˆ²ä»‹é¢   */
    /* ==================== */
    #scene-game { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; display: none; }

    /* Debug å„€è¡¨æ¿ */
    .debug-panel {
        position: absolute; top: 20px; left: 20px;
        background: rgba(0, 0, 0, 0.6); border: 1px solid #444;
        padding: 15px; border-radius: 10px; text-align: left;
        color: #fff; font-size: 12px; width: 230px; pointer-events: auto;
    }
    .debug-header { border-bottom: 1px solid #555; margin-bottom: 5px; color: #aaa; font-size: 11px; }
    .debug-row { display: flex; justify-content: space-between; margin-bottom: 3px; }
    .val { font-weight: bold; font-family: monospace; }
    .pass { color: #00ff00; } .fail { color: #555; } /* fail æ”¹æš—è‰²ï¼Œä¸æ¶çœ¼ */
    .locked { color: #ff5555; }

    /* è¨ˆåˆ†æ¿ */
    .score-container { 
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center;
    }
    .score-board { 
        padding: 10px 50px; border-radius: 20px; text-align: center; 
        background: rgba(0, 0, 0, 0.6); border: 3px solid #555; 
        transition: transform 0.1s;
    }
    #count { font-size: 110px; font-weight: 900; line-height: 1; color: #fff; }
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; }
    
    /* æµ®å‹•æ–‡å­— */
    .float-text { position: absolute; font-weight: 900; font-size: 40px; color: white; pointer-events: none; }

    /* ç›¾ç‰Œç‹€æ…‹ */
    #shield-status {
        margin-top: 10px; font-size: 16px; font-weight: bold; color: #555; text-shadow: 0 0 5px black;
        transition: color 0.3s, text-shadow 0.3s;
    }
    #shield-status.active { color: #ffd700; text-shadow: 0 0 15px #ffd700; }

</style>
</head>
<body>

<video id="input_video" playsinline></video>
<canvas id="output_canvas"></canvas>

<div id="scene-intro">
    <div class="moon"></div>
    <div id="snow-container"></div>
    <div class="intro-box">
        <h1>XMAS BOXING</h1>
        <p>V25 æš´æ¼²æ‹³é ­ç‰ˆ - è¦–è¦ºè¡æ“Šåˆ¤å®š</p>
        <button class="btn-main" onclick="startCalibrationFlow()">æˆ‘æº–å‚™å¥½äº†!</button>
    </div>
</div>

<div id="scene-calibration">
    <div id="calib-step-text" class="calib-step">æ­¥é©Ÿ 1/2</div>
    <div id="calib-instr-text" class="calib-instr">
        <b>é˜²ç¦¦æ ¡æ­£ï¼š</b><br>
        è«‹å°‡é›™æ‰‹æ¡æ‹³ï¼Œæ”¾åœ¨è‡‰é °å…©å´é˜²ç¦¦ï¼Œä¿æŒä¸å‹•ã€‚
    </div>
    <div class="calib-data">
        Fist Size (Guard): <span id="calib-live-val">0.00</span>
    </div>
    <button id="calib-btn" class="btn-main" onclick="runCalibrationStep()">é–‹å§‹ç´€éŒ„ (3ç§’)</button>
</div>

<div id="scene-game">
    <div class="debug-panel">
        <div class="debug-header">LEFT FIST <span>(Guard: <span id="g-l-val">0</span> / Hit: ><span id="h-l-val">0</span>)</span></div>
        <div class="debug-row"><span>Size Scale:</span> <span id="val-l-scale" class="val">0.00</span></div>
        <div class="debug-row"><span>Is Punching:</span> <span id="val-l-punch" class="val">NO</span></div>
        
        <div class="debug-header" style="margin-top:10px;">RIGHT FIST <span>(Guard: <span id="g-r-val">0</span> / Hit: ><span id="h-r-val">0</span>)</span></div>
        <div class="debug-row"><span>Size Scale:</span> <span id="val-r-scale" class="val">0.00</span></div>
        <div class="debug-row"><span>Is Punching:</span> <span id="val-r-punch" class="val">NO</span></div>

        <div style="margin-top:10px; border-top:1px solid #555; padding-top:5px; color:#aaa;">
            Other Hand Guard: <span id="val-guard-ok" class="val">NO</span>
        </div>
    </div>

    <div class="score-container">
        <div class="score-board" id="score-board">
            <div class="count-label">COMBO</div>
            <div id="count">0</div>
        </div>
        <div id="shield-status">ğŸ›¡ï¸ SHIELD ACTIVE ğŸ›¡ï¸</div>
    </div>
</div>

<script>
// --- 0. é›ªèŠ± ---
function createSnow() {
    const container = document.getElementById('snow-container');
    for (let i = 0; i < 50; i++) {
        const d = document.createElement('div');
        d.className = 'snowflake';
        d.innerHTML = 'â„';
        d.style.left = Math.random() * 100 + 'vw';
        d.style.animationDuration = (Math.random() * 3 + 2) + 's';
        d.style.fontSize = (Math.random() * 10 + 10) + 'px';
        container.appendChild(d);
    }
}
createSnow();

// --- 1. è®Šæ•¸ ---
let mode = 'INTRO';
let count = 0;
let leftState = 0, rightState = 0; // 0:Ready, 1:Punch
let leftCooldown = 0, rightCooldown = 0;
let floatTexts = [];
let shieldAlpha = 0;

// æ ¡æ­£æ•¸æ“š
let calibration = {
    step: 0, // 0:Guard, 1:Punch, 2:Done
    guardScaleL: 0, guardScaleR: 0, // é˜²ç¦¦æ™‚çš„å¤§å°
    punchScaleL: 0, punchScaleR: 0, // å‡ºæ‹³æ™‚çš„å¤§å°
    isMeasuring: false
};

// éŠæˆ²é–€æª» (å‹•æ…‹è¨ˆç®—)
let GAME_CONFIG = {
    thresholdL: 0.0, // è¶…éæ­¤å€¼ç®— Punch
    thresholdR: 0.0,
    resetL: 0.0,     // ä½æ–¼æ­¤å€¼ç®— Reset
    resetR: 0.0,
    cooldownFrames: 5,
    guardTolerance: 1.2 // é˜²ç¦¦æ‰‹å¤§å°å®¹è¨±å€ç‡ (é˜²ç¦¦æ‰‹ä¸èƒ½è®Šå¤ªå¤§)
};

// DOM
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const video = document.getElementById('input_video');
const countEl = document.getElementById('count');
const board = document.getElementById('score-board');
const shieldStatus = document.getElementById('shield-status');

// éŸ³æ•ˆ
const PUNCH_SOUND_URL = 'punch.mp3'; 
let audioContext, punchBuffer;
async function loadSound() {
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        const res = await fetch(PUNCH_SOUND_URL);
        const buf = await res.arrayBuffer();
        punchBuffer = await audioContext.decodeAudioData(buf);
    } catch(e) {}
}
function playSound() {
    if (!audioContext || !punchBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const src = audioContext.createBufferSource();
    src.buffer = punchBuffer;
    src.connect(audioContext.destination);
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    src.start(0);
}

// --- 2. æ ¸å¿ƒç®—æ³•ï¼šæ‹³é ­é€è¦–ä¿‚æ•¸ ---
// é€™è£¡æˆ‘å€‘ä¸çœ‹è§’åº¦ï¼Œåªçœ‹ "æ‰‹çœ‹èµ·ä¾†æœ‰å¤šå¤§"
// Scale = (æ‰‹è…•åˆ°é£ŸæŒ‡è·é›¢) / (è‚©å¯¬)
function getFistScale(wrist, index, shoulderWidth) {
    // è¨ˆç®— 2D è·é›¢ (åªçœ‹ X, Y) -> å› ç‚ºé€è¦–æ•ˆæœä¸»è¦åæ˜ åœ¨ 2D æŠ•å½±å¤§å°
    const dist = Math.hypot(wrist.x - index.x, wrist.y - index.y);
    if (shoulderWidth === 0) return 0;
    return dist / shoulderWidth;
}

// --- 3. æµç¨‹æ§åˆ¶ ---

async function startCalibrationFlow() {
    await loadSound();
    document.getElementById('scene-intro').style.opacity = 0;
    setTimeout(() => { document.getElementById('scene-intro').style.display = 'none'; }, 1000);
    document.getElementById('scene-calibration').style.display = 'flex';
    
    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    pose.onResults(onResults);
    
    const camera = new Camera(video, { onFrame: async () => { await pose.send({image: video}); }, width: 1280, height: 720 });
    await camera.start();
    mode = 'CALIBRATING';
}

function runCalibrationStep() {
    const btn = document.getElementById('calib-btn');
    calibration.isMeasuring = true;
    let timeLeft = 3;
    btn.disabled = true;
    
    const timer = setInterval(() => {
        btn.innerText = `ç´€éŒ„ä¸­... ${timeLeft}`;
        timeLeft--;
        if (timeLeft < 0) {
            clearInterval(timer);
            calibration.isMeasuring = false;
            
            if (calibration.step === 0) {
                // å®Œæˆé˜²ç¦¦æ ¡æ­£
                playSound();
                calibration.step = 1;
                document.getElementById('calib-step-text').innerText = "æ­¥é©Ÿ 2/2";
                document.getElementById('calib-instr-text').innerHTML = "<b>æ”»æ“Šæ ¡æ­£ï¼š</b><br>è«‹å‘é¡é ­æ‰“å‡º<b>é›™æ‰‹ç›´æ‹³</b>(å®šæ ¼)ï¼Œè®“æ‹³é ­çœ‹èµ·ä¾†æœ€å¤§ã€‚";
                btn.innerText = "é–‹å§‹ç´€éŒ„ (3ç§’)";
                btn.disabled = false;
            } else {
                // å®Œæˆæ”»æ“Šæ ¡æ­£
                playSound();
                finishCalibration();
            }
        }
    }, 1000);
}

function finishCalibration() {
    // è¨ˆç®—é–€æª»
    // Threshold = é˜²ç¦¦å¤§å° + (æ”»æ“Šå¤§å° - é˜²ç¦¦å¤§å°) * 0.4 
    // ä¸éœ€è¦å®Œå…¨é”åˆ°æœ€å¤§å€¼ï¼Œåªè¦æœ‰æ˜é¡¯è®Šå¤§(è¶…é40%è¡Œç¨‹)å°±ç®—
    const rangeL = calibration.punchScaleL - calibration.guardScaleL;
    const rangeR = calibration.punchScaleR - calibration.guardScaleR;
    
    // è¨­å®šæ”»æ“Šé–€æª» (é™ä½ä¸€é»é›£åº¦)
    GAME_CONFIG.thresholdL = calibration.guardScaleL + (rangeL * 0.4);
    GAME_CONFIG.thresholdR = calibration.guardScaleR + (rangeR * 0.4);
    
    // è¨­å®šé‡ç½®é–€æª» (ç¨å¾®é«˜æ–¼é˜²ç¦¦å€¼)
    GAME_CONFIG.resetL = calibration.guardScaleL + (rangeL * 0.15);
    GAME_CONFIG.resetR = calibration.guardScaleR + (rangeR * 0.15);
    
    console.log("Config:", GAME_CONFIG);

    document.getElementById('scene-calibration').style.display = 'none';
    document.getElementById('scene-game').style.display = 'block';
    canvas.style.opacity = 1;
    
    // Debug é¡¯ç¤º
    document.getElementById('g-l-val').innerText = calibration.guardScaleL.toFixed(2);
    document.getElementById('h-l-val').innerText = GAME_CONFIG.thresholdL.toFixed(2);
    document.getElementById('g-r-val').innerText = calibration.guardScaleR.toFixed(2);
    document.getElementById('h-r-val').innerText = GAME_CONFIG.thresholdR.toFixed(2);
    
    mode = 'GAME';
}

// --- 4. éŠæˆ²é‚è¼¯ ---

function processHand(scale, state, cooldown, threshold, resetVal, isOtherHandGuarding, label) {
    let newState = state;
    let hit = false;
    
    const isLeft = (label === 'L');
    const elScale = document.getElementById(`val-${isLeft?'l':'r'}-scale`);
    const elPunch = document.getElementById(`val-${isLeft?'l':'r'}-punch`);
    
    // Debug Display
    if(elScale) {
        elScale.innerText = scale.toFixed(3);
        // å¦‚æœ Scale è¶…éé–€æª»ï¼Œæ•¸å­—è®Šç¶ 
        elScale.className = (scale > threshold) ? "val pass" : "val fail";
    }

    if (state === 0) { // Ready
        // æ¢ä»¶ï¼šæ‹³é ­è®Šå¤§ + å¦ä¸€æ‰‹æœ‰é˜²ç¦¦
        if (scale > threshold && isOtherHandGuarding && cooldown <= 0) {
            newState = 1;
            hit = true;
        }
    } 
    else if (state === 1) { newState = 2; } 
    else if (state === 2) { 
        // æ‹³é ­è®Šå°å›æ­¸
        if (scale < resetVal) {
            newState = 0; 
        }
    }
    
    if(elPunch) {
        if(state === 1) { elPunch.innerText = "HIT!"; elPunch.className = "val pass"; }
        else if(state === 2) { elPunch.innerText = "RETRACT"; elPunch.className = "val locked"; }
        else { elPunch.innerText = "READY"; elPunch.className = "val fail"; }
    }

    return { newState, hit };
}

function onResults(results) {
    if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }
    const cw = canvas.width, ch = canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, cw, ch);
    ctx.globalAlpha = (mode === 'CALIBRATING') ? 0.5 : 1.0;
    ctx.drawImage(results.image, 0, 0, cw, ch);
    ctx.globalAlpha = 1.0;

    if (!results.poseLandmarks) { ctx.restore(); return; }
    
    const lm = results.poseLandmarks;
    const nose = lm[0];
    const lS = lm[11], rS = lm[12];
    const lW = lm[15], rW = lm[16];
    const lIndex = lm[19], rIndex = lm[20]; // ä½¿ç”¨é£ŸæŒ‡æŒ‡å°–ï¼Œè®ŠåŒ–å¹…åº¦æœ€å¤§
    
    // è‚©å¯¬ä½œç‚ºåŸºæº–
    const shoulderWidth = Math.hypot(lS.x - rS.x, lS.y - rS.y);
    if (shoulderWidth === 0) { ctx.restore(); return; }
    
    // è¨ˆç®—æ‹³é ­ä¿‚æ•¸ (æ ¸å¿ƒ)
    const scaleL = getFistScale(lW, lIndex, shoulderWidth);
    const scaleR = getFistScale(rW, rIndex, shoulderWidth);

    if (mode === 'CALIBRATING') {
        drawSkeleton(lm, cw, ch);
        // é¡¯ç¤ºå³æ™‚æ•¸å€¼
        document.getElementById('calib-live-val').innerText = 
            `L:${scaleL.toFixed(2)} | R:${scaleR.toFixed(2)}`;
            
        if (calibration.isMeasuring) {
            if (calibration.step === 0) { // Guard
                calibration.guardScaleL = (calibration.guardScaleL * 0.9) + (scaleL * 0.1); // ç°¡å–®å¹³æ»‘
                calibration.guardScaleR = (calibration.guardScaleR * 0.9) + (scaleR * 0.1);
            } else { // Punch
                if(scaleL > calibration.punchScaleL) calibration.punchScaleL = scaleL;
                if(scaleR > calibration.punchScaleR) calibration.punchScaleR = scaleR;
            }
        }
    }
    else if (mode === 'GAME') {
        drawSkeleton(lm, cw, ch);
        
        // é˜²ç¦¦æª¢æŸ¥ï¼š
        // æª¢æŸ¥æ–¹å¼ï¼šå¦ä¸€éš»æ‰‹çš„å¤§å°å¿…é ˆã€Œæ¥è¿‘é˜²ç¦¦å¤§å°ã€ï¼Œä¸èƒ½å¤ªå¤§
        // é€™è£¡è¨­å®šï¼šå¤§å°ä¸èƒ½è¶…é Reset é–€æª»çš„ 1.2 å€ (çµ¦é»ç©ºé–“ï¼Œä½†ä¸èƒ½æ˜¯å‡ºæ‹³ç‹€æ…‹)
        const isGuardL = scaleL < (GAME_CONFIG.resetL * 1.5);
        const isGuardR = scaleR < (GAME_CONFIG.resetR * 1.5);
        
        // UI æ›´æ–°
        document.getElementById('val-guard-ok').innerText = (isGuardL && isGuardR) ? "BOTH" : (isGuardL ? "L-OK" : (isGuardR ? "R-OK" : "NONE"));
        document.getElementById('val-guard-ok').className = (isGuardL || isGuardR) ? "val pass" : "val fail";

        // ç›¾ç‰Œé¡¯ç¤º (åªè¦æœ‰ä¸€æ‰‹é˜²ç¦¦å°±ç®—æœ‰ç›¾ï¼Œé›™æ‰‹é˜²ç¦¦ç›¾æ›´äº®)
        if (isGuardL && isGuardR) {
            shieldAlpha = Math.min(shieldAlpha + 0.1, 0.9);
            shieldStatus.classList.add('active');
        } else if (isGuardL || isGuardR) {
             shieldAlpha = Math.min(shieldAlpha + 0.05, 0.5);
             shieldStatus.classList.remove('active');
        } else {
            shieldAlpha = Math.max(shieldAlpha - 0.1, 0);
            shieldStatus.classList.remove('active');
        }
        if (shieldAlpha > 0) drawShield(nose, cw, ch, shoulderWidth * 2.5, shieldAlpha);

        // åˆ¤å®š (å·¦æ‰‹æ‰“æ“Šæ™‚ï¼Œå³æ‰‹è¦åœ¨é˜²ç¦¦ç¯„åœå…§)
        const resL = processHand(scaleL, leftState, leftCooldown, GAME_CONFIG.thresholdL, GAME_CONFIG.resetL, isGuardR, 'L');
        const resR = processHand(scaleR, rightState, rightCooldown, GAME_CONFIG.thresholdR, GAME_CONFIG.resetR, isGuardL, 'R');

        leftState = resL.newState;
        rightState = resR.newState;

        if (resL.hit) hitLogic(true, lW.x, lW.y);
        if (resR.hit) hitLogic(false, rW.x, rW.y);

        if (leftCooldown > 0) leftCooldown--;
        if (rightCooldown > 0) rightCooldown--;
        
        drawFloatingTexts(cw, ch);
    }
    
    ctx.restore();
}

function drawShield(center, cw, ch, radiusBase, alpha) {
    const x = center.x * cw;
    const y = center.y * ch;
    const r = radiusBase * cw; 

    const grad = ctx.createRadialGradient(x, y, r * 0.4, x, y, r);
    grad.addColorStop(0, `rgba(255, 215, 0, 0)`);
    grad.addColorStop(0.8, `rgba(255, 215, 0, ${alpha * 0.2})`);
    grad.addColorStop(1, `rgba(255, 255, 0, ${alpha * 0.5})`);

    ctx.beginPath();
    ctx.arc(x, y, r, 0, 2 * Math.PI);
    ctx.fillStyle = grad;
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(x, y, r, 0, 2 * Math.PI);
    ctx.strokeStyle = `rgba(255, 255, 200, ${alpha})`;
    ctx.lineWidth = 3;
    ctx.stroke();
}

function drawSkeleton(lm, cw, ch) {
    ctx.lineWidth = 4; ctx.strokeStyle = "rgba(0, 255, 255, 0.4)"; ctx.lineCap = "round";
    // ç•«æ‰‹è‡‚
    ctx.beginPath();
    ctx.moveTo(lm[11].x*cw, lm[11].y*ch); ctx.lineTo(lm[13].x*cw, lm[13].y*ch); ctx.lineTo(lm[15].x*cw, lm[15].y*ch);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(lm[12].x*cw, lm[12].y*ch); ctx.lineTo(lm[14].x*cw, lm[14].y*ch); ctx.lineTo(lm[16].x*cw, lm[16].y*ch);
    ctx.stroke();
}

function hitLogic(isLeft, x, y) {
    count++;
    countEl.innerText = count;
    countEl.classList.remove('hit-pop'); void countEl.offsetWidth; countEl.classList.add('hit-pop');
    board.style.transform = "translateX(-50%) scale(1.1)";
    setTimeout(()=> board.style.transform = "translateX(-50%) scale(1)", 100);

    if(isLeft) leftCooldown = GAME_CONFIG.cooldownFrames; else rightCooldown = GAME_CONFIG.cooldownFrames;
    playSound();
    
    if (floatTexts.length > 10) floatTexts.shift();
    floatTexts.push({ x, y, text: "HIT!", color: isLeft ? '#00d2ff' : '#ff9f43', life: 20, vy: -5 });
}

function drawFloatingTexts(cw, ch) {
    ctx.scale(-1, 1);
    ctx.font = "900 60px Arial"; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
    for(let i=floatTexts.length-1; i>=0; i--){
        let t = floatTexts[i];
        let rx = -(cw - t.x*cw);
        ctx.fillStyle = t.color;
        ctx.strokeText(t.text, rx, t.y*ch); ctx.fillText(t.text, rx, t.y*ch);
        t.y += t.vy/ch; t.life--;
        if(t.life<=0) floatTexts.splice(i, 1);
    }
}
</script>
</body>
</html>
