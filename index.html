<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V26 è–èª•å¯¬å®¹ç‰ˆ</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* å…¨å±€è¨­å®š */
    body { font-family: 'Segoe UI', monospace; margin: 0; overflow: hidden; background: #000; color: white; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; opacity: 0; transition: opacity 1s; }
    video { display: none; }

    /* ==================== */
    /* Phase 1: è–èª•å¤œç©º   */
    /* ==================== */
    #scene-intro {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
        background: linear-gradient(to bottom, #000011, #0a0a2a);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: opacity 1s;
    }
    .moon {
        position: absolute; top: 10%; right: 15%;
        width: 100px; height: 100px; background: #fff; border-radius: 50%;
        box-shadow: 0 0 40px #fff, 0 0 80px #ffffcc;
        animation: glow 3s infinite alternate;
    }
    @keyframes glow { from { box-shadow: 0 0 40px #fff; } to { box-shadow: 0 0 60px #fff, 0 0 100px #ffffcc; } }
    .snowflake {
        position: absolute; top: -10px; color: #fff; font-size: 1em; opacity: 0.8;
        animation: fall linear infinite;
    }
    @keyframes fall { to { transform: translateY(110vh); } }
    .intro-box { z-index: 10; text-align: center; }
    h1 { font-size: 60px; text-shadow: 0 0 20px #00d2ff; margin-bottom: 20px; }
    p { font-size: 18px; color: #ccc; margin-bottom: 40px; }
    .btn-main {
        padding: 15px 50px; font-size: 24px; border: none; border-radius: 50px;
        background: #e17055; color: white; cursor: pointer; font-weight: bold;
        box-shadow: 0 0 20px rgba(225, 112, 85, 0.6); transition: transform 0.2s;
    }
    .btn-main:hover { transform: scale(1.1); background: #fab1a0; }

    /* ==================== */
    /* Phase 2: æ ¡æ­£ç•«é¢   */
    /* ==================== */
    #scene-calibration {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 90;
        background: rgba(0,0,0,0.85); display: none;
        flex-direction: column; align-items: center; justify-content: center;
        text-align: center;
    }
    .calib-step { font-size: 36px; margin-bottom: 20px; color: #00d2ff; font-weight: bold; }
    .calib-instr { font-size: 20px; color: #ddd; margin-bottom: 40px; max-width: 600px; line-height: 1.5; }
    .calib-data { font-family: monospace; font-size: 24px; color: #fab1a0; margin-bottom: 30px; border: 1px solid #555; padding: 15px; border-radius: 10px; background: rgba(0,0,0,0.5); }

    /* ==================== */
    /* Phase 3: éŠæˆ²ä»‹é¢   */
    /* ==================== */
    #scene-game { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; display: none; }

    /* Debug å„€è¡¨æ¿ */
    .debug-panel {
        position: absolute; top: 20px; left: 20px;
        background: rgba(0, 0, 0, 0.6); border: 1px solid #444;
        padding: 15px; border-radius: 10px; text-align: left;
        color: #fff; font-size: 12px; width: 220px; pointer-events: auto;
    }
    .debug-header { border-bottom: 1px solid #555; margin-bottom: 5px; color: #aaa; font-size: 11px; }
    .debug-row { display: flex; justify-content: space-between; margin-bottom: 3px; }
    .val { font-weight: bold; font-family: monospace; }
    .pass { color: #00ff00; } .fail { color: #ff5555; }

    /* è¨ˆåˆ†æ¿ */
    .score-container { 
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center;
    }
    .score-board { 
        padding: 10px 50px; border-radius: 20px; text-align: center; 
        background: rgba(0, 0, 0, 0.6); border: 3px solid #555; 
        transition: transform 0.1s;
    }
    #count { font-size: 110px; font-weight: 900; line-height: 1; color: #fff; }
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; }
    
    /* æµ®å‹•æ–‡å­— */
    .float-text { position: absolute; font-weight: 900; font-size: 40px; color: white; pointer-events: none; }

    /* ç›¾ç‰Œç‹€æ…‹æ–‡å­— */
    #shield-status {
        margin-top: 10px; font-size: 16px; font-weight: bold; color: #555; text-shadow: 0 0 5px black;
        transition: color 0.3s, text-shadow 0.3s;
    }
    #shield-status.active { color: #ffd700; text-shadow: 0 0 15px #ffd700; }

</style>
</head>
<body>

<video id="input_video" playsinline></video>
<canvas id="output_canvas"></canvas>

<div id="scene-intro">
    <div class="moon"></div>
    <div id="snow-container"></div>
    <div class="intro-box">
        <h1>XMAS BOXING</h1>
        <p>V26 è–èª•å¯¬å®¹ç‰ˆ - è¼•é¬†é€£æ“Š</p>
        <button class="btn-main" onclick="startCalibrationFlow()">æˆ‘æº–å‚™å¥½äº†!</button>
    </div>
</div>

<div id="scene-calibration">
    <div id="calib-step-text" class="calib-step">æ­¥é©Ÿ 1/2</div>
    <div id="calib-instr-text" class="calib-instr">
        è«‹æ‰“å‡º<b>å·¦ç›´æ‹³</b>ä¸¦å®šä½ä¸å‹•ã€‚<br>
        ç³»çµ±å°‡ç´€éŒ„ä½ çš„è‡‚é•·ï¼Œä¸éœ€è¦ä¼¸åˆ°æ¥µé™ã€‚
    </div>
    <div class="calib-data">
        Extension Ratio: <span id="calib-live-ratio">0.00</span> %
    </div>
    <button id="calib-btn" class="btn-main" onclick="runCalibrationStep()">é–‹å§‹åµæ¸¬ (3ç§’)</button>
</div>

<div id="scene-game">
    <div class="debug-panel">
        <div class="debug-header">LEFT ARM (Target: ><span id="limit-lr">0.00</span>)</div>
        <div class="debug-row"><span>Ratio:</span> <span id="val-lr" class="val">0.00</span></div>
        <div class="debug-row"><span>Speed:</span> <span id="val-ls" class="val">0.00</span></div>
        <div class="debug-row"><span>Other Guard:</span> <span id="val-lg" class="val">NO</span></div>
        
        <div class="debug-header" style="margin-top:10px;">RIGHT ARM (Target: ><span id="limit-rr">0.00</span>)</div>
        <div class="debug-row"><span>Ratio:</span> <span id="val-rr" class="val">0.00</span></div>
        <div class="debug-row"><span>Speed:</span> <span id="val-rs" class="val">0.00</span></div>
        <div class="debug-row"><span>Other Guard:</span> <span id="val-rg" class="val">NO</span></div>
    </div>

    <div class="score-container">
        <div class="score-board" id="score-board">
            <div class="count-label">COMBO</div>
            <div id="count">0</div>
        </div>
        <div id="shield-status">ğŸ›¡ï¸ SHIELD ACTIVE ğŸ›¡ï¸</div>
    </div>
</div>

<script>
// --- 0. é›ªèŠ±ç‰¹æ•ˆ ---
function createSnow() {
    const container = document.getElementById('snow-container');
    for (let i = 0; i < 50; i++) {
        const d = document.createElement('div');
        d.className = 'snowflake';
        d.innerHTML = 'â„';
        d.style.left = Math.random() * 100 + 'vw';
        d.style.animationDuration = (Math.random() * 3 + 2) + 's';
        d.style.fontSize = (Math.random() * 10 + 10) + 'px';
        container.appendChild(d);
    }
}
createSnow();

// --- 1. è®Šæ•¸èˆ‡è¨­å®š ---
let mode = 'INTRO';
let count = 0;
let leftState = 0, rightState = 0;
let leftCooldown = 0, rightCooldown = 0;
let floatTexts = [];
let lastLeftSpan = 0, lastRightSpan = 0; 
let shieldAlpha = 0; 

// é˜²ç¦¦è¨˜æ†¶ (V26 å¢å¼·)
let leftGuardTime = 0;
let rightGuardTime = 0;
const GUARD_MEMORY_MS = 800; // [å¤§å¯¬å®¹] é˜²ç¦¦è¨˜æ†¶å»¶é•·åˆ° 0.8 ç§’

// æ ¡æ­£èˆ‡éŠæˆ²åƒæ•¸
let calibration = {
    step: 0,
    maxLeftRatio: 0, maxRightRatio: 0,
    isMeasuring: false
};

let GAME_CONFIG = {
    triggerRatio_L: 0.85, 
    triggerRatio_R: 0.85,
    
    resetRatio: 0.60,      
    minSpeed: 0.012,       // [å¯¬å®¹] é€Ÿåº¦é–€æª»å†é™ä¸€é»
    
    guardDistRatio: 0.95,  // [å¤§å¯¬å®¹] é˜²ç¦¦åœˆåŠ å¤§ï¼Œå¹¾ä¹åªè¦æ‰‹åœ¨é ­é™„è¿‘å°±ç®—
    cooldownFrames: 5      
};

// DOM
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const video = document.getElementById('input_video');
const countEl = document.getElementById('count');
const board = document.getElementById('score-board');
const shieldStatus = document.getElementById('shield-status');

// éŸ³æ•ˆ
const PUNCH_SOUND_URL = 'punch.mp3'; 
let audioContext, punchBuffer;
async function loadSound() {
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        const res = await fetch(PUNCH_SOUND_URL);
        const buf = await res.arrayBuffer();
        punchBuffer = await audioContext.decodeAudioData(buf);
    } catch(e) {}
}
function playSound() {
    if (!audioContext || !punchBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const src = audioContext.createBufferSource();
    src.buffer = punchBuffer;
    src.connect(audioContext.destination);
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    src.start(0);
}

// --- 2. æ ¸å¿ƒå¹¾ä½•è¨ˆç®— (å½ˆåŠ›ç¹© V24 Logic) ---

function getDist(a, b) {
    return Math.sqrt(Math.pow(a.x-b.x, 2) + Math.pow(a.y-b.y, 2) + Math.pow(a.z-b.z, 2));
}

function getExtensionRatio(shoulder, elbow, wrist) {
    const upperArm = getDist(shoulder, elbow);
    const foreArm = getDist(elbow, wrist);
    const totalArmLength = upperArm + foreArm;
    const currentSpan = getDist(shoulder, wrist);
    if (totalArmLength === 0) return 0;
    return currentSpan / totalArmLength;
}

// --- 3. æµç¨‹èˆ‡æ ¡æ­£ ---

async function startCalibrationFlow() {
    await loadSound();
    document.getElementById('scene-intro').style.opacity = 0;
    setTimeout(() => { document.getElementById('scene-intro').style.display = 'none'; }, 1000);
    document.getElementById('scene-calibration').style.display = 'flex';
    
    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    pose.onResults(onResults);
    
    const camera = new Camera(video, { onFrame: async () => { await pose.send({image: video}); }, width: 1280, height: 720 });
    await camera.start();
    mode = 'CALIBRATING';
    canvas.style.opacity = 0.4;
}

function runCalibrationStep() {
    const btn = document.getElementById('calib-btn');
    calibration.isMeasuring = true;
    let timeLeft = 3;
    btn.disabled = true;
    
    const timer = setInterval(() => {
        btn.innerText = `åµæ¸¬ä¸­... ${timeLeft}`;
        timeLeft--;
        if (timeLeft < 0) {
            clearInterval(timer);
            calibration.isMeasuring = false;
            
            if (calibration.step === 0) {
                playSound();
                calibration.step = 1;
                document.getElementById('calib-step-text').innerText = "æ­¥é©Ÿ 2/2";
                document.getElementById('calib-instr-text').innerHTML = "ç´€éŒ„å®Œæˆã€‚<br>è«‹æ‰“å‡º<b>å³ç›´æ‹³</b>ä¸¦å®šä½ã€‚";
                btn.innerText = "é–‹å§‹åµæ¸¬ (3ç§’)";
                btn.disabled = false;
            } else {
                playSound();
                finishCalibration();
            }
        }
    }, 1000);
}

function finishCalibration() {
    // [å¤§å¯¬å®¹ä¿®æ”¹]ï¼šå–æ ¡æ­£å€¼çš„ 80% ä½œç‚ºé–€æª» (åŸæœ¬90%)
    // é€™æ¨£ä½ å‡ºæ‹³åªè¦æœ‰8åˆ†ç›´ï¼Œå°±ç®—éé—œ
    GAME_CONFIG.triggerRatio_L = Math.max(0.65, calibration.maxLeftRatio * 0.80);
    GAME_CONFIG.triggerRatio_R = Math.max(0.65, calibration.maxRightRatio * 0.80);
    
    console.log("Config:", GAME_CONFIG);

    document.getElementById('scene-calibration').style.display = 'none';
    document.getElementById('scene-game').style.display = 'block';
    canvas.style.opacity = 1;
    
    document.getElementById('limit-lr').innerText = GAME_CONFIG.triggerRatio_L.toFixed(2);
    document.getElementById('limit-rr').innerText = GAME_CONFIG.triggerRatio_R.toFixed(2);
    
    mode = 'GAME';
}

// --- 4. éŠæˆ²ä¸»è¿´åœˆ ---

function processHand(ratio, state, cooldown, lastSpan, oppGuardLastTime, label) {
    let newState = state;
    let hit = false;
    
    const velocity = ratio - lastSpan;
    const isLeft = (label === 'L');
    const threshold = isLeft ? GAME_CONFIG.triggerRatio_L : GAME_CONFIG.triggerRatio_R;
    
    // [å¯¬å®¹] æª¢æŸ¥é˜²ç¦¦è¨˜æ†¶ (åªè¦ 800ms å…§æœ‰é˜²ç¦¦éå°±ç®—)
    const now = Date.now();
    const isGuarded = (now - oppGuardLastTime) < GUARD_MEMORY_MS;

    const elR = document.getElementById(`val-${isLeft?'l':'r'}r`);
    const elS = document.getElementById(`val-${isLeft?'l':'r'}s`);
    const elG = document.getElementById(`val-${isLeft?'l':'r'}g`);

    if (state === 0) { // Ready
        const passRatio = ratio > threshold;
        const passSpeed = velocity > GAME_CONFIG.minSpeed; 
        const passGuard = isGuarded;

        // å¦‚æœä¸‰è€…éƒ½é€šé
        if (passRatio && passSpeed && passGuard && cooldown <= 0) {
            newState = 1;
            hit = true;
        }

        if (elR) {
            elR.innerText = ratio.toFixed(2);
            elS.innerText = velocity.toFixed(3);
            elG.innerText = isGuarded ? "YES" : "NO";
            
            elR.className = passRatio ? "val pass" : "val fail";
            elS.className = passSpeed ? "val pass" : "val fail";
            elG.className = passGuard ? "val pass" : "val fail";
        }
    } 
    else if (state === 1) { newState = 2; } 
    else if (state === 2) { 
        if (ratio < GAME_CONFIG.resetRatio) {
            newState = 0; 
        }
    }
    return { newState, hit };
}

function onResults(results) {
    if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }
    const cw = canvas.width, ch = canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, cw, ch);
    ctx.globalAlpha = (mode === 'CALIBRATING') ? 0.5 : 1.0;
    ctx.drawImage(results.image, 0, 0, cw, ch);
    ctx.globalAlpha = 1.0;

    if (!results.poseLandmarks) { ctx.restore(); return; }
    
    const lm = results.poseLandmarks;
    const nose = lm[0];
    const lS = lm[11], lE = lm[13], lW = lm[15];
    const rS = lm[12], rE = lm[14], rW = lm[16];
    const scale = Math.hypot(lS.x - rS.x, lS.y - rS.y);
    const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

    if (!nose || !lS || !rS) { ctx.restore(); return; }

    const lRatio = getExtensionRatio(lS, lE, lW);
    const rRatio = getExtensionRatio(rS, rE, rW);

    if (mode === 'CALIBRATING') {
        drawSkeleton(lm, cw, ch);
        const isLeft = (calibration.step === 0);
        document.getElementById('calib-live-ratio').innerText = ((isLeft ? lRatio : rRatio) * 100).toFixed(1);

        if (calibration.isMeasuring) {
            if (isLeft) {
                if (lRatio > calibration.maxLeftRatio) calibration.maxLeftRatio = lRatio;
            } else {
                if (rRatio > calibration.maxRightRatio) calibration.maxRightRatio = rRatio;
            }
        }
    } 
    else if (mode === 'GAME') {
        drawSkeleton(lm, cw, ch);
        
        // --- 1. é˜²ç¦¦åˆ¤æ–· (æ›´æ–°æ™‚é–“æˆ³) ---
        const gDist = scale * GAME_CONFIG.guardDistRatio; 
        const now = Date.now();
        
        // åªè¦æ‰‹è…•é€²å…¥ä¸‹å·´ç¯„åœï¼Œå°±æ›´æ–°é˜²ç¦¦æ™‚é–“
        if (Math.hypot(lW.x - chin.x, lW.y - chin.y) < gDist) leftGuardTime = now;
        if (Math.hypot(rW.x - chin.x, rW.y - chin.y) < gDist) rightGuardTime = now;
        
        // UI é¡¯ç¤ºï¼šä½¿ç”¨å¯¬å®¹çš„æ™‚é–“æˆ³
        const l_active = (now - leftGuardTime) < GUARD_MEMORY_MS;
        const r_active = (now - rightGuardTime) < GUARD_MEMORY_MS;

        // ç›¾ç‰Œèˆ‡å…‰ç½©
        if (l_active && r_active) {
            shieldAlpha = Math.min(shieldAlpha + 0.1, 0.8);
            shieldStatus.classList.add('active');
        } else if (l_active || r_active) {
            shieldAlpha = Math.max(shieldAlpha - 0.05, 0.2); // å–®æ‰‹ä¹Ÿçµ¦ä¸€é»é»å…‰
            shieldStatus.classList.remove('active');
        } else {
            shieldAlpha = Math.max(shieldAlpha - 0.1, 0);
            shieldStatus.classList.remove('active');
        }
        if (shieldAlpha > 0) drawShield(nose, cw, ch, scale * 3, shieldAlpha);

        // --- 2. å‡ºæ‹³åˆ¤æ–· ---
        if (lastLeftSpan === 0) { lastLeftSpan = lRatio; lastRightSpan = rRatio; }

        // å·¦æ‰‹æ”»æ“Š -> æª¢æŸ¥å³æ‰‹é˜²ç¦¦æ™‚é–“
        const resL = processHand(lRatio, leftState, leftCooldown, lastLeftSpan, rightGuardTime, 'L');
        // å³æ‰‹æ”»æ“Š -> æª¢æŸ¥å·¦æ‰‹é˜²ç¦¦æ™‚é–“
        const resR = processHand(rRatio, rightState, rightCooldown, lastRightSpan, leftGuardTime, 'R');

        leftState = resL.newState; lastLeftSpan = lRatio;
        rightState = resR.newState; lastRightSpan = rRatio;

        if (resL.hit) hitLogic(true, lW.x, lW.y);
        if (resR.hit) hitLogic(false, rW.x, rW.y);

        if (leftCooldown > 0) leftCooldown--;
        if (rightCooldown > 0) rightCooldown--;
        
        drawDot(lW, l_active, cw, ch);
        drawDot(rW, r_active, cw, ch);
        drawFloatingTexts(cw, ch);
    }
    ctx.restore();
}

function drawShield(center, cw, ch, radiusBase, alpha) {
    const x = center.x * cw;
    const y = center.y * ch;
    const r = radiusBase * cw; 
    const grad = ctx.createRadialGradient(x, y, r * 0.5, x, y, r);
    grad.addColorStop(0, `rgba(255, 215, 0, 0)`);
    grad.addColorStop(0.8, `rgba(255, 215, 0, ${alpha * 0.3})`);
    grad.addColorStop(1, `rgba(255, 255, 0, ${alpha * 0.6})`);
    ctx.beginPath(); ctx.arc(x, y, r, 0, 2 * Math.PI); ctx.fillStyle = grad; ctx.fill();
    ctx.beginPath(); ctx.arc(x, y, r, 0, 2 * Math.PI); ctx.strokeStyle = `rgba(255, 255, 200, ${alpha})`; ctx.lineWidth = 5; ctx.stroke();
}

function drawSkeleton(lm, cw, ch) {
    ctx.lineWidth = 4; ctx.strokeStyle = "rgba(0, 255, 255, 0.4)"; ctx.lineCap = "round";
    ctx.beginPath(); ctx.moveTo(lm[11].x*cw, lm[11].y*ch); ctx.lineTo(lm[13].x*cw, lm[13].y*ch); ctx.lineTo(lm[15].x*cw, lm[15].y*ch); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(lm[12].x*cw, lm[12].y*ch); ctx.lineTo(lm[14].x*cw, lm[14].y*ch); ctx.lineTo(lm[16].x*cw, lm[16].y*ch); ctx.stroke();
}
function drawDot(w, active, cw, ch) {
    ctx.beginPath(); ctx.fillStyle = active ? "#00ff00" : "#d63031";
    ctx.arc(w.x * cw, w.y * ch, 10, 0, 2*Math.PI); ctx.fill();
}
function hitLogic(isLeft, x, y) {
    count++; countEl.innerText = count; countEl.classList.remove('hit-pop'); void countEl.offsetWidth; countEl.classList.add('hit-pop');
    board.style.transform = "translateX(-50%) scale(1.1)"; setTimeout(()=> board.style.transform = "translateX(-50%) scale(1)", 100);
    if(isLeft) leftCooldown = GAME_CONFIG.cooldownFrames; else rightCooldown = GAME_CONFIG.cooldownFrames;
    playSound();
    if (floatTexts.length > 10) floatTexts.shift();
    floatTexts.push({ x, y, text: "HIT!", color: isLeft ? '#00d2ff' : '#ff9f43', life: 20, vy: -5 });
}
function drawFloatingTexts(cw, ch) {
    ctx.scale(-1, 1); ctx.font = "900 60px Arial"; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
    for(let i=floatTexts.length-1; i>=0; i--){
        let t = floatTexts[i]; let rx = -(cw - t.x*cw);
        ctx.fillStyle = t.color; ctx.strokeText(t.text, rx, t.y*ch); ctx.fillText(t.text, rx, t.y*ch);
        t.y += t.vy/ch; t.life--; if(t.life<=0) floatTexts.splice(i, 1);
    }
}
</script>
</body>
</html>
