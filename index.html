<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è–èª•æäºº (V13 Zè»¸æ·±åº¦ç‰ˆ)</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <style>
    /* åŸºç¤ UI */
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      text-align: center; background: #000; color: #fff; margin: 0; overflow: hidden;
    }
    .container { position: relative; width: 100vw; height: 100vh; }
    /* é¡åƒç¿»è½‰ */
    video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

    /* èƒŒæ™¯èˆ‡æ°›åœ */
    .scene-background { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%); }
    
    /* è¨ˆåˆ†æ¿ */
    .score-board { 
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10; 
      background: rgba(0, 0, 0, 0.8); border: 2px solid #555;
      padding: 10px 40px; width: 500px; border-radius: 20px; 
      pointer-events: none; 
    }
    #count { font-size: 90px; font-weight: 900; color: #fff; line-height: 1; text-shadow: 0 0 15px rgba(255,255,255,0.5); }
    .count-title { font-size: 16px; color: #aaa; letter-spacing: 3px; margin-bottom: 5px;}
    
    /* Debug æ•¸æ“šé¡¯ç¤º (è®“ä½ çŸ¥é“ Z è»¸æœ‰æ²’æœ‰æŠ“åˆ°) */
    .debug-info {
        display: flex; justify-content: space-around; font-size: 14px; color: #00ff00; font-family: monospace; margin-top: 5px;
    }

    .status-bar { display: flex; justify-content: space-between; margin-top: 10px; border-top: 1px solid #444; padding-top: 5px;}
    .guard-status { font-size: 16px; font-weight: bold; color: #777; padding: 2px 10px; }
    .guard-status.ok { color: #00b894; text-shadow: 0 0 5px #00b894; }
    .guard-status.no { color: #d63031; }

    #start-btn { 
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 50; 
      padding: 20px 50px; font-size: 24px; font-weight: bold; background: #0984e3; color: white; border: none; border-radius: 50px; cursor: pointer; 
      box-shadow: 0 0 20px rgba(9, 132, 227, 0.8);
    }
    #reset-btn { position: absolute; bottom: 30px; right: 30px; z-index: 100; padding: 10px 20px; background: #d63031; color: white; border: none; border-radius: 5px; cursor: pointer; display: none; }

    .pop-effect { animation: pop 0.1s ease-out; color: #ffeb3b !important; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
  </style>
</head>

<body>
  <div class="scene-background"></div>

  <div class="container">
    <div class="score-board">
      <div class="count-title">DIRECT HITS</div>
      <div id="count">0</div>
      
      <div class="debug-info">
          <div id="debug-left">L-Depth: 0.0</div>
          <div id="debug-right">R-Depth: 0.0</div>
      </div>

      <div class="status-bar">
          <div id="status-left" class="guard-status">LEFT GUARD</div>
          <div id="status-right" class="guard-status">RIGHT GUARD</div>
      </div>
    </div>

    <div class="video-container">
      <video id="input_video" playsinline style="display:none"></video>
      <canvas id="output_canvas"></canvas>
    </div>

    <button id="start-btn" onclick="initGame()">ğŸ¥Š å•Ÿå‹• Z è»¸åµæ¸¬</button>
    <button id="reset-btn" onclick="resetCount()">RESET</button>
  </div>

  <script>
    // --- éŸ³æ•ˆ ---
    const PUNCH_SOUND_URL = 'punch.mp3'; 
    let audioContext = null, punchBuffer = null;
    async function loadSound() {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            const response = await fetch(PUNCH_SOUND_URL);
            const arrayBuffer = await response.arrayBuffer();
            punchBuffer = await audioContext.decodeAudioData(arrayBuffer);
        } catch (e) {}
    }
    function playPunchSound() {
        if (!audioContext || !punchBuffer) return;
        if (audioContext.state === 'suspended') audioContext.resume();
        const source = audioContext.createBufferSource();
        source.buffer = punchBuffer;
        source.connect(audioContext.destination);
        source.start(0);
    }

    // --- è®Šæ•¸ ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { alpha: false });
    const countElement = document.getElementById('count');
    const debugLeft = document.getElementById('debug-left');
    const debugRight = document.getElementById('debug-right');
    const statusLeft = document.getElementById('status-left');
    const statusRight = document.getElementById('status-right');
    const startBtn = document.getElementById('start-btn'); 
    const resetBtn = document.getElementById('reset-btn'); 

    // [V13 åƒæ•¸ - Zè»¸ç‰¹åŒ–]
    const CONFIG = {
        // Zè»¸åˆ¤å®šé–¾å€¼ï¼šæ•¸å€¼è¶Šå¤§ä»£è¡¨æ‰‹ä¼¸å¾—è¶Šé•·
        // é€šå¸¸è‚©è†€åˆ°æ‰‹è…•çš„Zå·®å€¼ï¼Œç¸®æ‰‹æ™‚ç´„ 0.1~0.2ï¼Œä¼¸ç›´æ™‚ç´„ 0.4~0.6 (è¦–è·é›¢è€Œå®š)
        punchZThreshold: 0.35, 
        
        // ç‚ºäº†è®“é€£çºŒå‡ºæ‹³é †æš¢ï¼Œå›æ”¶åˆ¤å®šçš„é–¾å€¼è¦æ¯”è§¸ç™¼ä½
        resetZThreshold: 0.25,

        // 2D ç›®æ¨™åˆ¤å®šï¼šæ‰‹è…•å¿…é ˆé›¢é¼»å­å¤šè¿‘ (ç›¸å°æ–¼è‚©è†€å¯¬åº¦çš„æ¯”ä¾‹)
        hitRadiusRatio: 0.8, 

        guardDistRatio: 0.65, 
        cooldownFrames: 4
    };

    let count = 0;
    let leftStage = "down", rightStage = "down";
    let leftCooldown = 0, rightCooldown = 0;
    let floatingTexts = []; 
    let leftGuardGrace = 0, rightGuardGrace = 0;

    // --- è¼”åŠ©å‡½å¼ ---
    function calculateDistance(a, b) {
      return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }

    function spawnFloatingText(x, y, text, color) {
        if(floatingTexts.length > 20) floatingTexts.shift();
        floatingTexts.push({ x, y, text, color, life: 15, offsetY: 0 });
    }

    function updateUI(newCount, x, y, isLeft) {
       countElement.innerText = newCount;
       countElement.classList.remove('pop-effect');
       void countElement.offsetWidth;
       countElement.classList.add('pop-effect');
       const color = isLeft ? "#00a8ff" : "#ff7f50";
       spawnFloatingText(x, y, "HIT!", color);
    }

    // --- æ ¸å¿ƒé‚è¼¯ (Z-Axis Depth Logic) ---
    function processHandZ(shoulder, wrist, nose, scale, currentStage, label, currentCooldown, otherHandIsGuarding) {
      let nextStage = currentStage;
      const isLeft = label === "L";
      
      // 1. è¨ˆç®— Z è»¸æ·±åº¦å·® (Depth Difference)
      // MediaPipe ä¸­ï¼ŒZ è¶Šå°è¶Šé è¿‘é¡é ­ã€‚
      // æ‰€ä»¥ (shoulder.z - wrist.z) å¦‚æœæ˜¯æ­£çš„å¤§æ•¸ï¼Œä»£è¡¨æ‰‹è…•æ¯”è‚©è†€é è¿‘é¡é ­å¾ˆå¤š
      const zDiff = (shoulder.z - wrist.z); 

      // 2. è¨ˆç®— 2D å‘½ä¸­è·é›¢ (è·é›¢é¼»å­çš„å¹³é¢è·é›¢)
      const distToNose = calculateDistance(wrist, nose);
      const hitRadius = scale * CONFIG.hitRadiusRatio;
      
      // æ›´æ–° Debug è³‡è¨Š
      const debugEl = isLeft ? debugLeft : debugRight;
      debugEl.innerText = `${label}-Z: ${zDiff.toFixed(2)}`;
      if (zDiff > CONFIG.punchZThreshold) debugEl.style.color = "#00ff00"; // ç¶ è‰²ä»£è¡¨æ·±åº¦å¤ 
      else debugEl.style.color = "#555";

      // ç‹€æ…‹æ©Ÿ
      if (currentStage === "down") {
        // åˆ¤å®š HIT çš„æ¢ä»¶ï¼š
        // A. æ·±åº¦å¤  (Z > Threshold)  <-- è§£æ±ºæ­£é¢æ‰“æ‹³ä¼¸ä¸é•·çš„å•é¡Œ
        // B. æº–åº¦å¤  (åœ¨é¼»å­é™„è¿‘çš„åœˆåœˆå…§)
        // C. æ²’å†·å»
        // D. å¦ä¸€éš»æ‰‹æœ‰é˜²ç¦¦
        
        const isHitTarget = distToNose < hitRadius;
        const isExtended = zDiff > CONFIG.punchZThreshold;

        if (currentCooldown === 0 && isExtended && isHitTarget) {
             if (otherHandIsGuarding) {
                nextStage = "punch";
             }
        }
      }
      else if (currentStage === "punch") {
        count++;
        // æ“Šä¸­ç‰¹æ•ˆä½ç½®ç›´æ¥å®šåœ¨æº–å¿ƒ(é¼»å­)ï¼Œå¢åŠ å›é¥‹æ„Ÿ
        updateUI(count, nose.x, nose.y, isLeft); 
        playPunchSound();

        if (isLeft) leftCooldown = CONFIG.cooldownFrames;
        else rightCooldown = CONFIG.cooldownFrames;
        
        nextStage = "retract";
      }
      else if (currentStage === "retract") {
        // å›æ”¶åˆ¤å®šï¼šZ è»¸æ·±åº¦è®Šå° (æ‰‹æ”¶å›ä¾†äº†)
        if (zDiff < CONFIG.resetZThreshold) {
            nextStage = "down"; 
        }
      }
      return nextStage;
    }

    function onResults(results) {
      const cw = canvasElement.width, ch = canvasElement.height;
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, cw, ch);
      canvasCtx.drawImage(results.image, 0, 0, cw, ch);

      // æµ®å‹•æ–‡å­—æ¸²æŸ“
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        let ft = floatingTexts[i];
        ft.life--; ft.offsetY -= 4;
        canvasCtx.save();
        canvasCtx.scale(-1, 1); 
        canvasCtx.font = `900 60px Arial`; 
        canvasCtx.fillStyle = ft.color;
        canvasCtx.strokeStyle = "white"; canvasCtx.lineWidth = 2;
        canvasCtx.strokeText(ft.text, -(cw - (ft.x * cw)), (ft.y * ch) + ft.offsetY);
        canvasCtx.fillText(ft.text, -(cw - (ft.x * cw)), (ft.y * ch) + ft.offsetY); 
        canvasCtx.restore();
        if (ft.life <= 0) floatingTexts.splice(i, 1);
      }

      if (leftCooldown > 0) leftCooldown--;
      if (rightCooldown > 0) rightCooldown--;

      if (results.poseLandmarks) {
        const lm = results.poseLandmarks;
        
        // é—œéµé»
        const nose = lm[0];
        const leftShoulder = lm[11], rightShoulder = lm[12];
        const leftWrist = lm[15], rightWrist = lm[16];
        const mouthLeft = lm[9], mouthRight = lm[10];

        if (nose && leftShoulder && rightShoulder && leftWrist && rightWrist) {
          const shoulderWidth = calculateDistance(leftShoulder, rightShoulder);
          const stableScale = shoulderWidth * 2.5; 
          const chin = { x: (mouthLeft.x + mouthRight.x) / 2, y: (mouthLeft.y + mouthRight.y) / 2 };

          // --- 1. ç¹ªè£½ Hit Zone (æº–å¿ƒ) ---
          // æ ¹æ“šæ‰‹æœ‰æ²’æœ‰ä¼¸éä¾†è®Šè‰²
          const isLeftPunching = (leftShoulder.z - leftWrist.z) > CONFIG.punchZThreshold;
          const isRightPunching = (rightShoulder.z - rightWrist.z) > CONFIG.punchZThreshold;
          
          canvasCtx.beginPath();
          canvasCtx.lineWidth = 5;
          // å¦‚æœæœ‰äººå‡ºæ‹³ä¸”åˆ¤å®šæ·±åº¦å¤ ï¼Œæº–å¿ƒè®Šäº®ç™½ï¼Œå¦å‰‡ç‚ºç´…è‰²
          if (isLeftPunching || isRightPunching) {
             canvasCtx.strokeStyle = "rgba(255, 255, 255, 0.9)";
             canvasCtx.shadowBlur = 20; canvasCtx.shadowColor = "white";
          } else {
             canvasCtx.strokeStyle = "rgba(255, 50, 50, 0.6)";
             canvasCtx.shadowBlur = 0;
          }
          
          // ç•«æº–å¿ƒåœˆåœˆ
          const targetRadius = stableScale * CONFIG.hitRadiusRatio; // åˆ¤å®šç¯„åœ
          canvasCtx.arc(nose.x * cw, nose.y * ch, targetRadius * cw, 0, 2 * Math.PI);
          canvasCtx.stroke();
          
          // åå­—æº–ç·š
          canvasCtx.beginPath(); canvasCtx.lineWidth = 2;
          canvasCtx.moveTo(nose.x * cw - 20, nose.y * ch); canvasCtx.lineTo(nose.x * cw + 20, nose.y * ch);
          canvasCtx.moveTo(nose.x * cw, nose.y * ch - 20); canvasCtx.lineTo(nose.x * cw, nose.y * ch + 20);
          canvasCtx.stroke(); canvasCtx.shadowBlur = 0;

          // --- 2. é˜²ç¦¦åˆ¤å®š ---
          const guardRadius = stableScale * CONFIG.guardDistRatio;
          const leftInZone = (calculateDistance(leftWrist, chin) / stableScale) < CONFIG.guardDistRatio;
          const rightInZone = (calculateDistance(rightWrist, chin) / stableScale) < CONFIG.guardDistRatio;

          if (leftInZone) leftGuardGrace = 5; else if (leftGuardGrace > 0) leftGuardGrace--;
          if (rightInZone) rightGuardGrace = 5; else if (rightGuardGrace > 0) rightGuardGrace--;

          const isLeftGuarding = leftGuardGrace > 0;
          const isRightGuarding = rightGuardGrace > 0;

          // UI æ›´æ–°
          if (isLeftGuarding) { statusLeft.classList.add('ok'); statusLeft.classList.remove('no'); statusLeft.innerText = "DEFENSE OK"; }
          else { statusLeft.classList.add('no'); statusLeft.classList.remove('ok'); statusLeft.innerText = "HANDS UP"; }

          if (isRightGuarding) { statusRight.classList.add('ok'); statusRight.classList.remove('no'); statusRight.innerText = "DEFENSE OK"; }
          else { statusRight.classList.add('no'); statusRight.classList.remove('ok'); statusRight.innerText = "HANDS UP"; }

          // æ‰‹è…•å…‰é»
          function drawWrist(wrist, isGuarding) {
              canvasCtx.beginPath(); canvasCtx.fillStyle = isGuarding ? "#00b894" : "#d63031";
              canvasCtx.arc(wrist.x * cw, wrist.y * ch, 10, 0, 2 * Math.PI); canvasCtx.fill();
          }
          drawWrist(leftWrist, isLeftGuarding);
          drawWrist(rightWrist, isRightGuarding);

          // --- 3. è™•ç†å‡ºæ‹³ (ä½¿ç”¨ Z è»¸é‚è¼¯) ---
          const newLeftStage = processHandZ(leftShoulder, leftWrist, nose, stableScale, leftStage, "L", leftCooldown, isRightGuarding);
          const newRightStage = processHandZ(rightShoulder, rightWrist, nose, stableScale, rightStage, "R", rightCooldown, isLeftGuarding);

          leftStage = newLeftStage;
          rightStage = newRightStage;
        }
      }
      canvasCtx.restore();
    }

    // --- åˆå§‹åŒ– ---
    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ 
        modelComplexity: 1, 
        smoothLandmarks: true, 
        minDetectionConfidence: 0.6, 
        minTrackingConfidence: 0.6 
    });
    pose.onResults(onResults);

    window.initGame = async function() {
      await loadSound();
      if (audioContext && audioContext.state === 'suspended') await audioContext.resume();
      
      const camera = new Camera(videoElement, {
        onFrame: async () => { await pose.send({image: videoElement}); },
        width: 1280, height: 720
      });
      await camera.start();
      startBtn.style.display = 'none'; resetBtn.style.display = 'block';
    }
    window.resetCount = function() { count = 0; countElement.innerText = 0; scoreBoard.classList.remove('fire-lv3'); }
  </script>
</body>
</html>
