<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V16 ç´”æ·¨å…¨è¢å¹•ç‰ˆ</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    /* --- 1. ç‰ˆé¢ä¿®æ­£ï¼šå¼·åˆ¶å…¨è¢å¹•å¡«æ»¿ --- */
    body { 
      font-family: 'Segoe UI', sans-serif; 
      background: #000; margin: 0; overflow: hidden; 
    }
    
    /* è®“ Canvas å›ºå®šåœ¨è¦–çª—æœ€ä¸Šå±¤ä¸¦å¡«æ»¿ */
    canvas { 
        position: fixed; 
        top: 0; left: 0; 
        width: 100vw; height: 100vh; 
        object-fit: cover; /* ç¢ºä¿å¡«æ»¿ç•«é¢ä¸ç•™é»‘é‚Š */
        transform: scaleX(-1); /* é¡åƒ */
        z-index: 0;
    }
    
    /* éš±è—åŸå§‹ Video å…ƒç´  */
    video { display: none; }

    /* --- UI å±¤ (æµ®åœ¨ Canvas ä¹‹ä¸Š) --- */
    .ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ°æŒ‰éˆ• */
        z-index: 10;
        display: flex; flex-direction: column; align-items: center;
    }

    /* --- è¨ˆåˆ†æ¿ç‰¹æ•ˆ --- */
    .score-board { 
      margin-top: 30px;
      padding: 15px 60px; border-radius: 20px; 
      text-align: center; transition: all 0.2s ease-out;
      background: rgba(0, 0, 0, 0.6); 
      border: 3px solid #555;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    
    .count-label { font-size: 14px; color: #aaa; letter-spacing: 4px; font-weight: bold; text-transform: uppercase; margin-bottom: 5px; }
    #count { font-size: 100px; font-weight: 900; line-height: 1; color: #fff; text-shadow: 0 5px 10px rgba(0,0,0,0.5); }

    /* ç‰¹æ•ˆåˆ†ç´š */
    .score-board.tier-1 { border-color: #00d2ff; box-shadow: 0 0 20px #00d2ff; background: rgba(0, 30, 60, 0.8); }
    .tier-1 #count { color: #e0f7fa; text-shadow: 0 0 20px #00d2ff; }

    .score-board.tier-2 { border-color: #ffd700; box-shadow: 0 0 30px #ffd700; background: rgba(60, 50, 0, 0.8); animation: breath 0.5s infinite alternate; }
    .tier-2 #count { color: #fffde7; text-shadow: 0 0 25px #ffd700; }

    .score-board.tier-3 { border-color: #ff4500; box-shadow: 0 0 40px #ff4500; background: rgba(60, 10, 0, 0.8); animation: shake-mild 0.3s infinite; }
    .tier-3 #count { color: #ffccbc; text-shadow: 0 0 30px #ff4500; }

    .score-board.tier-4 { border-color: #d63031; background: rgba(50,0,0,0.9); box-shadow: 0 0 60px #ff0000; animation: shake-hard 0.2s infinite; }
    .tier-4 #count { color: #ffadad; text-shadow: 0 0 40px #ff0000, 0 0 10px #fff; }

    .score-board.tier-5 { border: 5px solid #fff; background: #000; box-shadow: 0 0 80px #fff, 0 0 100px #ff00ff; animation: glitch-anim 0.1s infinite; }

    /* å‹•ç•« Keyframes */
    @keyframes breath { 0% { transform: scale(1); } 100% { transform: scale(1.05); } }
    @keyframes shake-mild { 0% { transform: rotate(-1deg); } 50% { transform: rotate(1deg); } 100% { transform: rotate(0deg); } }
    @keyframes shake-hard { 0% { transform: translate(-2px, 2px); } 50% { transform: translate(2px, -2px); } 100% { transform: translate(0, 0); } }
    @keyframes glitch-anim { 0% { clip-path: inset(10% 0 80% 0); transform: translateX(-2px); } 50% { clip-path: inset(30% 0 10% 0); transform: translateX(2px); } 100% { clip-path: inset(0 0 0 0); } }
    .hit-pop { animation: pop-scale 0.1s ease-out; }
    @keyframes pop-scale { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }

    /* é˜²ç¦¦ç‹€æ…‹ UI */
    .status-container { 
        display: flex; justify-content: center; gap: 20px; 
        margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 10px;
    }
    .guard-box { display: flex; align-items: center; gap: 8px; font-size: 14px; color: #777; font-weight: bold; }
    .guard-led { width: 12px; height: 12px; border-radius: 50%; background: #333; border: 2px solid #555; box-shadow: 0 0 5px #000; transition: all 0.1s; }
    .guard-box.active .guard-led { background: #00ff00; border-color: #fff; box-shadow: 0 0 10px #00ff00; }
    .guard-box.active { color: #00ff00; text-shadow: 0 0 5px rgba(0,255,0,0.5); }

    /* æŒ‰éˆ• */
    #start-btn, #reset-btn { position: absolute; z-index: 100; cursor: pointer; border: none; font-weight: bold; border-radius: 50px; color: white; pointer-events: auto; }
    #start-btn { top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 60px; font-size: 24px; background: linear-gradient(135deg, #0984e3, #74b9ff); box-shadow: 0 0 30px rgba(9, 132, 227, 0.8); }
    #reset-btn { bottom: 30px; right: 30px; padding: 12px 25px; background: #d63031; display: none; box-shadow: 0 0 15px rgba(214, 48, 49, 0.5); }
  </style>
</head>

<body>
  <div class="video-container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
  </div>

  <div class="ui-layer">
    <div class="score-board" id="score-board">
      <div class="count-label">COMBO HITS</div>
      <div id="count">0</div>
      
      <div class="status-container">
          <div id="guard-left" class="guard-box"><div class="guard-led"></div> LEFT</div>
          <div id="guard-right" class="guard-box"><div class="guard-led"></div> RIGHT</div>
      </div>
    </div>
  </div>

  <button id="start-btn" onclick="initGame()">ğŸ¥Š å•Ÿå‹• V16 ç´”æ·¨ç‰ˆ</button>
  <button id="reset-btn" onclick="resetCount()">é‡ç½® (RESET)</button>

  <script>
    // --- éŸ³æ•ˆ ---
    const PUNCH_SOUND_URL = 'punch.mp3'; 
    let audioContext = null, punchBuffer = null;
    async function loadSound() {
        try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            const res = await fetch(PUNCH_SOUND_URL);
            const buf = await res.arrayBuffer();
            punchBuffer = await audioContext.decodeAudioData(buf);
        } catch(e) {}
    }
    function playPunchSound() {
        if (!audioContext || !punchBuffer) return;
        if (audioContext.state === 'suspended') audioContext.resume();
        const src = audioContext.createBufferSource();
        src.buffer = punchBuffer;
        src.connect(audioContext.destination);
        src.playbackRate.value = 0.95 + Math.random() * 0.1;
        src.start(0);
    }

    // --- åƒæ•¸è¨­å®š ---
    const CONFIG = {
        punchZThreshold: 0.35,  // æ·±åº¦åˆ¤å®š
        resetZThreshold: 0.25,  // é‡ç½®åˆ¤å®š
        hitRadiusRatio: 0.85,   // éš±å½¢ç›®æ¨™å¤§å° (é¼»å­å‘¨åœ)
        guardDistRatio: 0.65, 
        cooldownFrames: 3 
    };

    let count = 0;
    let leftStage = "ready", rightStage = "ready";
    let leftCooldown = 0, rightCooldown = 0;
    let leftGuardGrace = 0, rightGuardGrace = 0;
    let floatTexts = []; 

    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { alpha: false });
    const countElement = document.getElementById('count');
    const scoreBoard = document.getElementById('score-board');
    const guardLeftUI = document.getElementById('guard-left');
    const guardRightUI = document.getElementById('guard-right');

    function spawnHitText(x, y, isLeft) {
        if (floatTexts.length > 15) floatTexts.shift();
        floatTexts.push({
            x, y, text: "HIT!", 
            color: isLeft ? '#00d2ff' : '#ff9f43',
            life: 20, vy: -4
        });
    }

    function updateScoreBoardFX() {
        scoreBoard.className = 'score-board'; 
        if (count >= 150) scoreBoard.classList.add('tier-5');
        else if (count >= 100) scoreBoard.classList.add('tier-4');
        else if (count >= 70) scoreBoard.classList.add('tier-3');
        else if (count >= 50) scoreBoard.classList.add('tier-2');
        else if (count >= 30) scoreBoard.classList.add('tier-1');

        countElement.classList.remove('hit-pop');
        void countElement.offsetWidth;
        countElement.classList.add('hit-pop');
    }

    function processHand(shoulder, wrist, nose, scale, stage, cooldown, isOppositeGuarding) {
        let nextStage = stage;
        let isHit = false;
        const zDepth = shoulder.z - wrist.z;
        const distToNose = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
        const hitZone = scale * CONFIG.hitRadiusRatio;
        
        // åˆ¤å®šæ‰“æ“Šç¯„åœ (é›–ç„¶ä¸ç•«åœˆï¼Œä½†ä»éœ€åˆ¤å®šæ˜¯å¦åœ¨æ­£é¢)
        const inHitZone = distToNose < hitZone;

        if (stage === "ready") {
            if (zDepth > CONFIG.punchZThreshold && inHitZone && cooldown <= 0 && isOppositeGuarding) {
                nextStage = "punch";
                isHit = true;
            }
        } else if (stage === "punch") {
            nextStage = "retract";
        } else if (stage === "retract") {
            if (zDepth < CONFIG.resetZThreshold) nextStage = "ready";
        }
        return { nextStage, isHit };
    }

    function onResults(results) {
        // [ä¿®æ­£] Canvas å°ºå¯¸é–å®šç‚º Video åŸå§‹è§£æåº¦
        if (videoElement.videoWidth > 0 && (canvasElement.width !== videoElement.videoWidth)) {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
        }
        const cw = canvasElement.width;
        const ch = canvasElement.height;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, cw, ch);
        canvasCtx.drawImage(results.image, 0, 0, cw, ch);

        if (results.poseLandmarks) {
            const lm = results.poseLandmarks;
            const nose = lm[0];
            const leftS = lm[11], rightS = lm[12];
            const leftW = lm[15], rightW = lm[16];
            const chin = { x: (lm[9].x + lm[10].x)/2, y: (lm[9].y + lm[10].y)/2 };

            if (nose && leftS && rightS && leftW && rightW) {
                const scale = Math.hypot(leftS.x - rightS.x, leftS.y - rightS.y) * 2.5;

                // --- é˜²ç¦¦ ---
                const guardDist = scale * CONFIG.guardDistRatio;
                if (Math.hypot(leftW.x - chin.x, leftW.y - chin.y) < guardDist) leftGuardGrace = 5; else if (leftGuardGrace > 0) leftGuardGrace--;
                if (Math.hypot(rightW.x - chin.x, rightW.y - chin.y) < guardDist) rightGuardGrace = 5; else if (rightGuardGrace > 0) rightGuardGrace--;

                const isGuardL = leftGuardGrace > 0;
                const isGuardR = rightGuardGrace > 0;

                if (isGuardL) guardLeftUI.classList.add('active'); else guardLeftUI.classList.remove('active');
                if (isGuardR) guardRightUI.classList.add('active'); else guardRightUI.classList.remove('active');

                // --- å‡ºæ‹³ ---
                // [æ³¨æ„] é€™è£¡ç§»é™¤ç•«åœˆåœˆçš„ç¨‹å¼ç¢¼ï¼Œåªä¿ç•™é‚è¼¯
                const resL = processHand(leftS, leftW, nose, scale, leftStage, leftCooldown, isGuardR);
                const resR = processHand(rightS, rightW, nose, scale, rightStage, rightCooldown, isGuardL);

                leftStage = resL.nextStage;
                rightStage = resR.nextStage;

                if (resL.isHit) { count++; leftCooldown = CONFIG.cooldownFrames; playPunchSound(); updateScoreBoardFX(); spawnHitText(leftW.x, leftW.y, true); }
                if (resR.isHit) { count++; rightCooldown = CONFIG.cooldownFrames; playPunchSound(); updateScoreBoardFX(); spawnHitText(rightW.x, rightW.y, false); }

                if (leftCooldown > 0) leftCooldown--;
                if (rightCooldown > 0) rightCooldown--;
                countElement.innerText = count;

                // --- ç¹ªè£½æ‰‹è…•å…‰é» (ä¿ç•™é€™å€‹) ---
                function drawDot(wrist, isActive) {
                    canvasCtx.beginPath();
                    // é˜²ç¦¦æ™‚ç¶ è‰²ï¼Œæ”¾ä¸‹æ™‚æš—ç´…è‰²
                    canvasCtx.fillStyle = isActive ? "#00ff00" : "rgba(255, 50, 50, 0.5)";
                    canvasCtx.arc(wrist.x * cw, wrist.y * ch, isActive ? 12 : 8, 0, 2 * Math.PI);
                    
                    // åŠ ä¸€é»ç™¼å…‰æ•ˆæœ
                    canvasCtx.shadowBlur = isActive ? 15 : 0;
                    canvasCtx.shadowColor = isActive ? "#00ff00" : "transparent";
                    
                    canvasCtx.fill();
                    canvasCtx.shadowBlur = 0; // reset
                }
                drawDot(leftW, isGuardL);
                drawDot(rightW, isGuardR);
            }
        }

        // --- ç¹ªè£½ HIT æ–‡å­— ---
        canvasCtx.save();
        canvasCtx.scale(-1, 1);
        canvasCtx.font = "italic 900 60px Arial";
        canvasCtx.lineWidth = 3;
        canvasCtx.strokeStyle = "white";
        for (let i = floatTexts.length - 1; i >= 0; i--) {
            let t = floatTexts[i];
            const rx = -(cw - (t.x * cw));
            const ry = (t.y * ch);
            canvasCtx.fillStyle = t.color;
            canvasCtx.strokeText(t.text, rx, ry);
            canvasCtx.fillText(t.text, rx, ry);
            t.y += t.vy / ch; t.life--;
            if (t.life <= 0) floatTexts.splice(i, 1);
        }
        canvasCtx.restore();
        canvasCtx.restore();
    }

    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    pose.onResults(onResults);

    async function initGame() {
        await loadSound();
        const camera = new Camera(videoElement, {
            onFrame: async () => { await pose.send({image: videoElement}); },
            width: 1280, height: 720
        });
        await camera.start();
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('reset-btn').style.display = 'block';
    }
    window.resetCount = function() { count = 0; countElement.innerText = 0; updateScoreBoardFX(); }
  </script>
</body>
</html>
