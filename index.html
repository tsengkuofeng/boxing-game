<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è–èª•æäºº (V12 é¡é¢æ‰“æ“Šç‰ˆ)</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <style>
    /* åŸºç¤è¨­å®š */
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      text-align: center; background: transparent; color: #fff; margin: 0; overflow: hidden; user-select: none; -webkit-user-select: none;
    }
    .container { position: relative; width: 100vw; height: 100vh; }
    /* é¡åƒç¿»è½‰ */
    video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

    /* èƒŒæ™¯ */
    .scene-background { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; overflow: hidden; background: #000; }
    .night-sky { position: absolute; top: 0; left: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, #020111 10%, #191d3a 50%, #2d3e5e 90%); }
    .moon { position: absolute; top: 50px; right: 50px; width: 80px; height: 80px; background: #fefcd7; border-radius: 50%; box-shadow: 0 0 20px #fefcd7, 0 0 50px rgba(254, 252, 215, 0.4); }
    .snow-ground { position: absolute; bottom: 0; left: 0; width: 100%; height: 30%; background: #fffafa; border-top: 5px solid #e3e3e3; border-radius: 50% 50% 0 0 / 20px 20px 0 0; }
    
    /* è¨ˆåˆ†æ¿ */
    .score-board { 
      position: absolute; top: 30px; left: 50%; transform: translateX(-50%); z-index: 10; 
      background: rgba(0, 0, 0, 0.85); 
      padding: 15px 40px; width: 480px;
      border-radius: 20px; 
      border: 3px solid rgba(255, 255, 255, 0.2); pointer-events: none; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    }
    #count { font-size: 100px; font-weight: 900; color: #fff; line-height: 1; text-shadow: 0 0 20px rgba(0,0,0,0.8); margin: 5px 0; }
    .count-title { font-size: 18px; color: #aaa; letter-spacing: 5px; font-weight: bold; text-transform: uppercase; }
    
    .status-bar { width: 100%; display: flex; justify-content: space-between; margin-top: 10px; padding-top: 10px; border-top: 1px solid #444; }
    .guard-status { 
        font-size: 16px; font-weight: bold; padding: 6px 15px; border-radius: 8px; 
        color: #777; background: #1a1a1a; border: 1px solid #333; transition: all 0.1s;
    }
    .guard-status.bad { background: #d63031; color: white; border-color: #ff7675; box-shadow: 0 0 10px rgba(214, 48, 49, 0.5); }
    .guard-status.good { background: #00b894; color: white; border-color: #55efc4; box-shadow: 0 0 10px rgba(0, 184, 148, 0.5); }

    #start-btn { 
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 50; 
      padding: 25px 60px; font-size: 28px; font-weight: 900; background: linear-gradient(135deg, #0984e3, #74b9ff); 
      color: white; border: 4px solid rgba(255, 255, 255, 0.5); border-radius: 50px; cursor: pointer; 
      box-shadow: 0 0 30px rgba(9, 132, 227, 0.8); animation: pulse 1.5s infinite;
    }
    @keyframes pulse { 0% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.05); } 100% { transform: translate(-50%, -50%) scale(1); } }

    #reset-btn {
      position: absolute; bottom: 40px; right: 40px; z-index: 100;
      background: #d63031; color: white; border: 2px solid white; padding: 12px 25px; 
      font-size: 16px; font-weight: bold; border-radius: 30px; cursor: pointer; display: none; 
    }
    #reset-btn:active { transform: scale(0.95); }

    .pop-effect { animation: pop 0.1s ease-out; color: #ffeaa7 !important; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.4); } 100% { transform: scale(1); } }
    .fire-lv3 { border-color: #e17055 !important; box-shadow: 0 0 60px #e17055; background: rgba(225, 112, 85, 0.2); }
  </style>
</head>

<body>
  <div class="scene-background">
    <div class="night-sky"><div class="moon"></div></div>
    <div class="snow-ground"></div>
  </div>

  <div class="container">
    <div class="score-board">
      <div class="count-title">Face Hits</div>
      <div id="count">0</div>
      
      <div class="status-bar">
          <div id="status-left" class="guard-status">å·¦æ‰‹é˜²ç¦¦</div>
          <div id="status-right" class="guard-status">å³æ‰‹é˜²ç¦¦</div>
      </div>
    </div>

    <div class="video-container">
      <video id="input_video" playsinline style="display:none"></video>
      <canvas id="output_canvas"></canvas>
    </div>

    <button id="start-btn" onclick="initGame()">ğŸ¥Š ç„æº–è‡‰éƒ¨é–‹å§‹ (START)</button>
    <button id="reset-btn" onclick="resetCount()">é‡ç½® (RESET)</button>
  </div>

  <script>
    // --- 0. éŸ³æ•ˆ ---
    const PUNCH_SOUND_URL = 'punch.mp3'; 
    let audioContext = null, punchBuffer = null;

    async function loadSound() {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            const response = await fetch(PUNCH_SOUND_URL);
            const arrayBuffer = await response.arrayBuffer();
            punchBuffer = await audioContext.decodeAudioData(arrayBuffer);
        } catch (e) { console.error("éŸ³æ•ˆ error", e); }
    }

    function playPunchSound() {
        if (!audioContext || !punchBuffer) return;
        if (audioContext.state === 'suspended') audioContext.resume();
        const source = audioContext.createBufferSource();
        source.buffer = punchBuffer;
        source.connect(audioContext.destination);
        source.start(0);
    }

    // --- 1. è®Šæ•¸ ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { alpha: false });
    const countElement = document.getElementById('count');
    const scoreBoard = document.querySelector('.score-board'); 
    const statusLeft = document.getElementById('status-left');
    const statusRight = document.getElementById('status-right');
    const startBtn = document.getElementById('start-btn'); 
    const resetBtn = document.getElementById('reset-btn'); 

    // [V12 é‡å°è‡‰éƒ¨æ‰“æ“Šçš„åƒæ•¸èª¿æ•´]
    const CONFIG = {
        // [é€è¦–è£œå„Ÿ] å› ç‚ºå¾€é¡é ­æ‰“æ‹³æ‰‹è‡‚æœƒè®ŠçŸ­ï¼Œå¤§å¹…é™ä½è§¸ç™¼æ¯”ä¾‹
        baseTriggerRatio: 0.55, // åŸæœ¬æ˜¯ 0.70
        fastTriggerRatio: 0.40, // å¿«æ‹³åªéœ€ 0.40
        resetRatio: 0.35,   
        
        // é€Ÿåº¦é–€æª»ç¶­æŒ
        minSpeed: 0.015,     
        fastSpeed: 0.05,     
        
        // [é€è¦–è£œå„Ÿ] å¾€æ­£å‰æ–¹æ‰“ï¼Œè§’åº¦ä¸æœƒåˆ°180ï¼Œæ”¾å¯¬è§’åº¦é™åˆ¶
        minAngle: 100,      
        
        guardDistRatio: 0.65, 
        cooldownFrames: 3 
    };

    let count = 0;
    let leftStage = "down", rightStage = "down";
    let leftCooldown = 0, rightCooldown = 0;
    let globalHitCooldown = 0;
    let floatingTexts = []; 
    let prevLeftWrist = { x: 0, y: 0 }, prevRightWrist = { x: 0, y: 0 };
    let leftGuardGrace = 0, rightGuardGrace = 0;
    const MAX_GRACE_FRAMES = 8; 

    // --- 2. é‹ç®— ---
    function calculateDistance(a, b) {
      return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }

    function calculateAngle(a, b, c) {
        let radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
        let angle = Math.abs(radians * 180.0 / Math.PI);
        if (angle > 180.0) angle = 360 - angle;
        return angle;
    }

    function spawnFloatingText(x, y, text, color) {
        if(floatingTexts.length > 20) floatingTexts.shift();
        floatingTexts.push({ x, y, text, color, life: 20, offsetY: 0 });
    }

    function updateUI(newCount, x, y, isLeft) {
       countElement.innerText = newCount;
       countElement.classList.remove('pop-effect');
       void countElement.offsetWidth;
       countElement.classList.add('pop-effect');
       if (newCount >= 50) scoreBoard.classList.add('fire-lv3');

       const color = isLeft ? "#00a8ff" : "#ff7f50";
       // è®“æ–‡å­—ç›´æ¥å‡ºç¾åœ¨è‡‰éƒ¨é™„è¿‘ï¼Œè€Œä¸æ˜¯æ‹³é ­ä½ç½®ï¼Œå¢åŠ æ‰“æ“Šæ„Ÿ
       spawnFloatingText(x, y, "HIT!", color);
    }

    // --- 3. æ ¸å¿ƒé‚è¼¯ (V12 é¡é¢åˆ¤å®š) ---
    function processHand(shoulder, wrist, scale, currentStage, label, currentCooldown, config, speed, angle, otherHandIsGuarding, nose) {
      const wristDist = calculateDistance(shoulder, wrist);
      const ratio = wristDist / scale;
      let nextStage = currentStage;
      const isLeft = label === "L";

      // [V12 é«˜åº¦èˆ‡ç›®æ¨™ä¿®æ­£] 
      // 1. é˜²æ­¢æ‰“å¤©ç©ºï¼šæ‹³é ­ä¸å¾—é«˜æ–¼çœ‰æ¯›å¤ªå¤š (nose.y - offset)
      // 2. é˜²æ­¢æ‰“åœ°æ¿/èº«é«”ï¼šæ‹³é ­ä¸å¾—ä½æ–¼è‚©è†€å¤ªä½ (shoulder.y + offset)
      // ç°¡å–®ä¾†èªªï¼šy å¿…é ˆè½åœ¨ è‡‰éƒ¨~èƒ¸å£ é€™å€‹å€é–“
      // æ³¨æ„ï¼šCanvasåº§æ¨™ y è¶Šå¤§è¶Šä¸‹é¢
      
      const upperLimit = nose.y - 0.2; // çœ‰æ¯›ä¸Šæ–¹ä¸€é»é»
      const lowerLimit = shoulder.y + 0.1; // è‚©è†€ä¸‹æ–¹ä¸€é»é»

      // å¦‚æœè¶…å‡ºæ”»æ“Šå€é–“ï¼Œè¦–ç‚ºç„¡æ•ˆæˆ–é‡ç½®
      if (wrist.y < upperLimit || wrist.y > lowerLimit) {
          // å¤ªé«˜æˆ–å¤ªä½éƒ½ä¸ç®—ï¼Œä½†ä¸ä¸€å®šé‡ç½®ï¼Œåªæ˜¯ç„¡æ³•è§¸ç™¼ punch
          // ä½†å¦‚æœå¤ªä½(å‚æ‰‹)ï¼Œè¦èƒ½å¤ é‡ç½®
           if (wrist.y > shoulder.y + 0.2) return "down";
      }

      if (currentStage === "down") {
        const activeTriggerRatio = (speed > config.fastSpeed) ? config.fastTriggerRatio : config.baseTriggerRatio;

        // åˆ¤å®šè§¸ç™¼ï¼š
        // 1. ä¼¸å±•å¤  (ratio) 
        // 2. é€Ÿåº¦å¤  (speed) 
        // 3. è§’åº¦å¤  (angle)
        // 4. [æ–°å¢] é«˜åº¦å¿…é ˆåœ¨æœ‰æ•ˆæ”»æ“Šå€é–“ (Hit Box)
        const inHitBox = (wrist.y >= upperLimit && wrist.y <= lowerLimit);

        if (globalHitCooldown === 0 && currentCooldown === 0 && ratio > activeTriggerRatio && speed > config.minSpeed && angle > config.minAngle) {
            
            if (otherHandIsGuarding && inHitBox) {
                nextStage = "punch";
            }
        }
      }
      else if (currentStage === "punch") {
        count++;
        // æ“Šä¸­ä½ç½®ç›´æ¥é¡¯ç¤ºåœ¨è‡‰éƒ¨é™„è¿‘ï¼Œæ›´æœ‰æ‰“æ“Šæ„Ÿ
        updateUI(count, nose.x, nose.y, isLeft); 
        playPunchSound();

        if (isLeft) leftCooldown = config.cooldownFrames;
        else rightCooldown = config.cooldownFrames;
        
        globalHitCooldown = 4; 
        nextStage = "retract";
      }
      else if (currentStage === "retract") {
        if (ratio < config.resetRatio) {
            nextStage = "down"; 
        }
      }
      return nextStage;
    }

    function onResults(results) {
      const targetWidth = Math.min(window.innerWidth, 1280); 
      const targetHeight = targetWidth * (videoElement.videoHeight / videoElement.videoWidth || 0.75);
      if (canvasElement.width !== targetWidth) {
          canvasElement.width = targetWidth; canvasElement.height = targetHeight;
      }
      const cw = canvasElement.width, ch = canvasElement.height;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, cw, ch);
      canvasCtx.drawImage(results.image, 0, 0, cw, ch);

      // æµ®å‹•æ–‡å­—
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        let ft = floatingTexts[i];
        ft.life--; ft.offsetY -= 3;
        canvasCtx.save();
        canvasCtx.scale(-1, 1); 
        canvasCtx.font = `900 60px Arial`; 
        canvasCtx.fillStyle = ft.color;
        canvasCtx.strokeStyle = "white"; canvasCtx.lineWidth = 2;
        canvasCtx.strokeText(ft.text, -(cw - (ft.x * cw)), (ft.y * ch) + ft.offsetY);
        canvasCtx.fillText(ft.text, -(cw - (ft.x * cw)), (ft.y * ch) + ft.offsetY); 
        canvasCtx.restore();
        if (ft.life <= 0) floatingTexts.splice(i, 1);
      }

      if (leftCooldown > 0) leftCooldown--;
      if (rightCooldown > 0) rightCooldown--;
      if (globalHitCooldown > 0) globalHitCooldown--;

      if (results.poseLandmarks) {
        const lm = results.poseLandmarks;
        const nose = lm[0];
        const mouthLeft = lm[9], mouthRight = lm[10];
        const leftShoulder = lm[11], rightShoulder = lm[12];
        const leftElbow = lm[13], rightElbow = lm[14];
        const leftWrist = lm[15], rightWrist = lm[16];

        if (nose && mouthLeft && mouthRight && leftShoulder && rightShoulder && leftWrist && rightWrist) {
          const shoulderWidth = calculateDistance(leftShoulder, rightShoulder);
          const stableScale = shoulderWidth * 2.5; 
          const chin = { x: (mouthLeft.x + mouthRight.x) / 2, y: (mouthLeft.y + mouthRight.y) / 2 };

          // --- [V12] ç¹ªè£½ç›®æ¨™æº–å¿ƒ (Target Scope) ---
          // ç•«åœ¨é¼»å­ä¸Šï¼Œæé†’ä½¿ç”¨è€…ã€Œå¾€é€™è£¡æ‰“ã€
          canvasCtx.beginPath();
          canvasCtx.lineWidth = 3;
          canvasCtx.strokeStyle = "rgba(255, 50, 50, 0.8)"; // ç´…è‰²æº–å¿ƒ
          canvasCtx.arc(nose.x * cw, nose.y * ch, 30, 0, 2 * Math.PI); // å¤–åœˆ
          canvasCtx.stroke();
          
          canvasCtx.beginPath();
          canvasCtx.moveTo(nose.x * cw - 40, nose.y * ch);
          canvasCtx.lineTo(nose.x * cw + 40, nose.y * ch); // æ©«ç·š
          canvasCtx.moveTo(nose.x * cw, nose.y * ch - 40);
          canvasCtx.lineTo(nose.x * cw, nose.y * ch + 40); // ç›´ç·š
          canvasCtx.stroke();

          // ç•«ä¸€å€‹åŠé€æ˜ç´…é»åœ¨ä¸­å¿ƒ
          canvasCtx.beginPath();
          canvasCtx.fillStyle = "rgba(255, 0, 0, 0.3)";
          canvasCtx.arc(nose.x * cw, nose.y * ch, 10, 0, 2 * Math.PI);
          canvasCtx.fill();


          // --- é˜²ç¦¦åˆ¤å®š ---
          const leftInZone = (calculateDistance(leftWrist, chin) / stableScale) < CONFIG.guardDistRatio;
          const rightInZone = (calculateDistance(rightWrist, chin) / stableScale) < CONFIG.guardDistRatio;

          if (leftInZone) leftGuardGrace = MAX_GRACE_FRAMES; else if (leftGuardGrace > 0) leftGuardGrace--;
          if (rightInZone) rightGuardGrace = MAX_GRACE_FRAMES; else if (rightGuardGrace > 0) rightGuardGrace--;

          const isLeftGuarding = leftGuardGrace > 0;
          const isRightGuarding = rightGuardGrace > 0;

          function drawWristIndicator(wrist, isGuarding) {
              canvasCtx.beginPath();
              canvasCtx.shadowBlur = 10;
              canvasCtx.shadowColor = isGuarding ? "#00FF00" : "#FF0000";
              canvasCtx.fillStyle = isGuarding ? "#00b894" : "#d63031";
              canvasCtx.arc(wrist.x * cw, wrist.y * ch, 12, 0, 2 * Math.PI);
              canvasCtx.fill();
              canvasCtx.shadowBlur = 0;
          }
          drawWristIndicator(leftWrist, isLeftGuarding);
          drawWristIndicator(rightWrist, isRightGuarding);

          if (isLeftGuarding) {
              statusLeft.classList.add('good'); statusLeft.classList.remove('bad');
              statusLeft.innerHTML = "OK";
          } else {
              statusLeft.classList.add('bad'); statusLeft.classList.remove('good');
              statusLeft.innerHTML = "é˜²ç¦¦";
          }

          if (isRightGuarding) {
              statusRight.classList.add('good'); statusRight.classList.remove('bad');
              statusRight.innerHTML = "OK";
          } else {
              statusRight.classList.add('bad'); statusRight.classList.remove('good');
              statusRight.innerHTML = "é˜²ç¦¦";
          }

          // --- è™•ç†å‡ºæ‹³ (å‚³å…¥ Nose é€²è¡Œç›®æ¨™åˆ¤å®š) ---
          let leftSpeed = calculateDistance(leftWrist, prevLeftWrist);
          let leftAngle = calculateAngle(leftShoulder, leftElbow, leftWrist);
          let rightSpeed = calculateDistance(rightWrist, prevRightWrist);
          let rightAngle = calculateAngle(rightShoulder, rightElbow, rightWrist);

          const newLeftStage = processHand(leftShoulder, leftWrist, stableScale, leftStage, "L", leftCooldown, CONFIG, leftSpeed, leftAngle, isRightGuarding, nose);
          const newRightStage = processHand(rightShoulder, rightWrist, stableScale, rightStage, "R", rightCooldown, CONFIG, rightSpeed, rightAngle, isLeftGuarding, nose);

          leftStage = newLeftStage;
          rightStage = newRightStage;

          prevLeftWrist = { x: leftWrist.x, y: leftWrist.y };
          prevRightWrist = { x: rightWrist.x, y: rightWrist.y };
        }
      }
      canvasCtx.restore();
    }

    // --- åˆå§‹åŒ– (é«˜æ•ˆèƒ½æ¨¡å¼) ---
    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ 
        modelComplexity: 1, 
        smoothLandmarks: true, 
        minDetectionConfidence: 0.6, 
        minTrackingConfidence: 0.6 
    });
    pose.onResults(onResults);

    window.initGame = async function() {
      console.log("å•Ÿå‹• V12 é¡é¢æ‰“æ“Šç‰ˆ...");
      statusLeft.innerText = "..."; statusRight.innerText = "...";
      await loadSound();
      if (audioContext && audioContext.state === 'suspended') await audioContext.resume();
      
      const camera = new Camera(videoElement, {
        onFrame: async () => { await pose.send({image: videoElement}); },
        width: 1280, height: 720
      });

      try {
          await camera.start();
          startBtn.style.display = 'none'; resetBtn.style.display = 'block';
      } catch (e) { alert("ç›¸æ©Ÿæ¬Šé™éŒ¯èª¤"); }
    }
    window.resetCount = function() { count = 0; countElement.innerText = 0; scoreBoard.classList.remove('fire-lv3'); }
  </script>
</body>
</html>
